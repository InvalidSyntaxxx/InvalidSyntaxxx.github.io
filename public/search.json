[{"title":"C++ map排序","path":"//[object Object]/2024/03/17/map排序/","content":"C++ map按key或按value排序map按key排序（1）map默认按照 key 从小到大排序 12map&lt;string,int&gt; hash;//等价于 map&lt;string,int, less&lt;string&gt;&gt; hash; （2）map按照 key 从大到小排序 1map&lt;string,int, greater&lt;string&gt; &gt; hash; map按value值排序按 value 值排序没有直接的方法，但我们可以把 map 存到 vector 中，再对 vector 进行自定义排序 重写 vector 的 cmp 函数 123bool cmp(pair&lt;string,int&gt; a, pair&lt;string, int&gt; b) &#123; return a.second &lt; b.second;//从小到大排序&#125; 把 map 存到 vector 中进行排序 123456789map&lt;string,int&gt; m;m[&quot;a&quot;] = 2;m[&quot;b&quot;] = 3;m[&quot;c&quot;] = 1;vector&lt;pair&lt;string,int&gt; &gt; vec(m.begin(),m.end());/* *vec(m.begin(),m.end()代表用map的所有元素创建vector*/sort(vec.begin(),vec.end(),cmp);","tags":["C++"]},{"title":"99行实现C++线程池类","path":"//[object Object]/2024/03/16/99行实现C-线程池类/","content":"C++线程池实现主要思想让每一个thread创建后，就去执行调度函数：循环获取task，然后执行。 这个循环该什么时候停止呢？ 很简单，当线程池停止使用时，循环停止。 这样一来，就保证了thread函数的唯一性，而且复用线程执行task。 总结一下，我们的线程池的主要组成部分有二： 任务队列（Task Queue） 线程池（BMP） 线程池与任务队列之间的匹配操作，是典型的生产者-消费者模型，本模型使用了两个工具：一个mutex + 一个conditional_variable。mutex就是锁，保证任务的添加和移除（获取）的互斥性；一个条件变量保证多个线程获取task的同步性：当任务队列为空时，线程应该等待（阻塞）。 BMP.h： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#ifndef THREAD_POOL_H#define THREAD_POOL_H#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;condition_variable&gt;#include &lt;vector&gt;#include &lt;future&gt;template &lt;typename T&gt;class safeQueue // 线程安全队列类&#123;private: std::queue&lt;T&gt; _m_queue; // 线程队列 std::mutex _m_lock; // 线程锁public: bool empty() &#123; std::lock_guard&lt;std::mutex&gt; en_lock(_m_lock); // 对函数直接加互斥锁，lock_guard自动回收 return _m_queue.empty(); // 返回队列是否为空 &#125; void push(T value) &#123; std::lock_guard&lt;std::mutex&gt; en_lock(_m_lock); _m_queue.push(value); // 压入队列 &#125; bool pop(T &amp;t) &#123; std::lock_guard&lt;std::mutex&gt; en_lock(_m_lock); if (_m_queue.empty()) // 如果队列为空，返回false &#123; return false; &#125; t = std::move(_m_queue.front()); // 取出队列中的第一个元素 _m_queue.pop(); // 弹出队列中的第一个元素 return true; &#125; int size() &#123; std::lock_guard&lt;std::mutex&gt; en_lock(_m_lock); return _m_queue.size(); // 返回队列大小 &#125;&#125;;class BMP // 线程池类&#123;private: class worker // 工作线程类 &#123; private: uint32_t _worker_id; // 工作线程id BMP *_m_pool; // 线程池指针 public: worker(const uint32_t id, BMP *pool) : _worker_id(id), _m_pool(pool) &#123;&#125; void operator()() // 重载操作符 &#123; std::function&lt;void()&gt; func; // 基础函数 bool dequeued; while (!_m_pool-&gt;_m_shutdown) // 如果线程池没有关闭 &#123; // 取出任务，唤醒进程，执行工作函数 &#123; // 为线程环境加锁，互访问工作线程的休眠和唤醒 std::unique_lock&lt;std::mutex&gt; lock(_m_pool-&gt;_m_conditional_mutex); // 如果队列为空，线程休眠 if (_m_pool-&gt;_m_queue.empty()) &#123; _m_pool-&gt;_m_conditional_lock.wait(lock); &#125; // 取出队列中的任务 dequeued = _m_pool-&gt;_m_queue.pop(func); &#125; // 如果成功取出，执行工作函数 if (dequeued) &#123; func(); &#125; &#125; &#125; &#125;; bool _m_shutdown; // 线程池是否关闭 safeQueue&lt;std::function&lt;void()&gt;&gt; _m_queue; // 执行函数安全队列 std::vector&lt;std::thread&gt; _m_threads; // 线程队列 std::mutex _m_conditional_mutex; // 线程休眠锁互斥量 std::condition_variable _m_conditional_lock; // 线程环境锁，让线程处于休眠或者唤醒状态public: BMP(const int n_threads = 2) : _m_threads(std::vector&lt;std::thread&gt;(n_threads)), _m_shutdown(false) &#123;&#125; BMP(const BMP &amp;) = delete; // 删除拷贝构造函数 BMP(BMP &amp;&amp;) = delete; // 删除移动构造函数 BMP &amp;operator=(const BMP &amp;) = delete; // 删除拷贝赋值操作符 BMP &amp;operator=(BMP &amp;&amp;) = delete; // 删除移动赋值操作符 void init() &#123; for (uint32_t i = 0; i &lt; _m_threads.size(); i++) &#123; // 初始化工作线程 _m_threads.at(i) = std::thread(worker(i, this)); &#125; &#125; void shutdown() &#123; _m_shutdown = true; _m_conditional_lock.notify_all(); // 通知唤醒所有工作进程 for (uint32_t i = 0; i &lt; _m_threads.size(); i++) // 等待所有线程完成 &#123; if (_m_threads[i].joinable()) // 判断线程是否在等待 &#123; _m_threads[i].join(); // 等待当前线程完成 &#125; &#125; &#125; // 任务提交函数 template &lt;typename F, typename... Args&gt; auto submit(F &amp;&amp;f, Args &amp;&amp;...args) -&gt; std::future&lt;decltype(f(args...))&gt; &#123; // 知道这是函数绑定和参数转发，但语法太难了。。。 // 用std::function包装函数，std::bind绑定参数，std::forward转发参数 std::function&lt;decltype(f(args...))()&gt; func = std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); // 封装函数指针 auto task_ptr = std::make_shared&lt;std::packaged_task&lt;decltype(f(args...))()&gt;&gt;(func); std::function&lt;void()&gt; wrapper_func = [task_ptr]() &#123; (*task_ptr)(); &#125;; // 队列通用安全封包函数，并压入安全队列 _m_queue.push(wrapper_func); // 唤醒一个等待中的线程 _m_conditional_lock.notify_one(); // 返回先前注册的任务指针 return task_ptr-&gt;get_future(); &#125;&#125;;#endif test.cpp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// test.cpp#include &lt;iostream&gt;#include &lt;random&gt;#include &quot;BMP.h&quot;std::random_device rd; // 真实随机数产生器std::mt19937 mt(rd()); //生成计算随机数mtstd::uniform_int_distribution&lt;int&gt; dist(-1000, 1000); //生成-1000到1000之间的离散均匀分布数auto rnd = std::bind(dist, mt);// 设置线程睡眠时间void simulate_hard_computation()&#123; std::this_thread::sleep_for(std::chrono::milliseconds(2000 + rnd()));&#125;// 添加两个数字的简单函数并打印结果void multiply(const int a, const int b)&#123; simulate_hard_computation(); const int res = a * b; std::cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; res &lt;&lt; std::endl;&#125;// 添加并输出结果void multiply_output(int &amp;out, const int a, const int b)&#123; simulate_hard_computation(); out = a * b; std::cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; out &lt;&lt; std::endl;&#125;// 结果返回int multiply_return(const int a, const int b)&#123; simulate_hard_computation(); const int res = a * b; std::cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; res &lt;&lt; std::endl; return res;&#125;void example()&#123; // 创建3个线程的线程池 BMP pool(3); // 初始化线程池 pool.init(); // 提交乘法操作，总共30个 for (int i = 1; i &lt;= 3; ++i) for (int j = 1; j &lt;= 10; ++j) &#123; pool.submit(multiply, i, j); &#125; // 使用ref传递的输出参数提交函数 int output_ref; auto future1 = pool.submit(multiply_output, std::ref(output_ref), 5, 6); // 等待乘法输出完成 future1.get(); std::cout &lt;&lt; &quot;Last operation result is equals to &quot; &lt;&lt; output_ref &lt;&lt; std::endl; // 使用return参数提交函数 auto future2 = pool.submit(multiply_return, 5, 3); // 等待乘法输出完成 int res = future2.get(); std::cout &lt;&lt; &quot;Last operation result is equals to &quot; &lt;&lt; res &lt;&lt; std::endl; // 关闭线程池 pool.shutdown();&#125;int main()&#123; example(); return 0;&#125; 执行结果 参考 基于C++11实现线程池 - 知乎 (zhihu.com)","tags":["C++"],"categories":["文章","专业技术"]},{"title":"C++实现LRU算法","path":"//[object Object]/2024/03/15/C-实现LRU算法/","content":"C++实现LRU算法描述原题：146. LRU 缓存 - 力扣（LeetCode） 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例 输入[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4] 解释 12345678910LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示 1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 10000 0 &lt;= value &lt;= 105 最多调用 2 * 105 次 get 和 put 核心代码本题的思想在于要在O(1)时间复杂度上完成 get 和 put 操作。对于 get 则使用哈希表(C++的 std::unordered_map)，对于 put 则使用双链表，同时采用伪头尾指针记录，即可在O(1)时间内完成操作。理解结构图很重要，数据结构图如下： 哈希表1std::unordered_map&lt;int, LinkListNode*&gt; _hashmap; // 记录哈希表 双链表123456789// 链表节点typedef struct LinkListNode &#123; int key, value; LinkListNode* prev; LinkListNode* next; LinkListNode():key(0),value(0),prev(nullptr),next(nullptr)&#123;&#125;; LinkListNode(int key, int value):key(key),value(value),prev(nullptr),next(nullptr)&#123;&#125;&#125;LinkListNode; 初始化 1234567// 初始化双链表 LRUCache(int capacity):_capacity(capacity), _size(0) &#123; _dummyHead = new LinkListNode(); _dummyTail = new LinkListNode(); _dummyHead-&gt;next = _dummyTail; _dummyTail-&gt;prev = _dummyHead; &#125; ⭐获取cache12345678910// 按关键字获取cache int get(int key) &#123; if(!_hashmap.count(key)) &#123; // cache 不命中，返回-1 return -1; &#125; // LRU核心：cache 命中，返回值，同时更新节点到头部 LinkListNode* node = _hashmap[key]; moveToHead(node); return node-&gt;value; &#125; ⭐加入cahce1234567891011121314151617181920212223242526// 向cache加入节点 void put(int key, int value) &#123; if(!_hashmap.count(key)) &#123; // cache 不命中 LinkListNode* node = new LinkListNode(key, value); // 是否移除尾部元素 if(_size &gt;= _capacity)&#123; // 当前元素大于等于cache容量，移除尾元素 // !重点!:不要忘记去除哈希表内key, value _hashmap.erase(_dummyTail-&gt;prev-&gt;key); // 去除尾节点，即LRU核心：替换掉最近最少使用的元素 removeNode(_dummyTail-&gt;prev); &#125; else &#123; // size加1，对应下面添加新节点 _size++; &#125; // 记录新的节点到哈希表 _hashmap[key] = node; // 将新的节点增加到双链表头节点 addToHead(node); &#125; else &#123; // 取出cache命中的节点，更新新值 LinkListNode* node = _hashmap[key]; node-&gt;value = value; // LRU核心，被使用则更新节点到双链表头部 moveToHead(node); &#125; &#125; 剩下的 删除指定节点 、移动指定节点到头节点、增加节点到头节点 实现如下 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 链表节点typedef struct LinkListNode &#123; int key, value; LinkListNode* prev; LinkListNode* next; LinkListNode():key(0),value(0),prev(nullptr),next(nullptr)&#123;&#125;; LinkListNode(int key, int value):key(key),value(value),prev(nullptr),next(nullptr)&#123;&#125;&#125;LinkListNode;class LRUCache &#123;private: // 记录cache 总容量 int _capacity; // 记录当前 cache 占用个数 int _size; std::unordered_map&lt;int, LinkListNode*&gt; _hashmap; // 记录哈希表 LinkListNode* _dummyHead; LinkListNode* _dummyTail;public: // 初始化双链表 LRUCache(int capacity):_capacity(capacity), _size(0) &#123; _dummyHead = new LinkListNode(); _dummyTail = new LinkListNode(); _dummyHead-&gt;next = _dummyTail; _dummyTail-&gt;prev = _dummyHead; &#125; // 按关键字获取cache int get(int key) &#123; if(!_hashmap.count(key)) &#123; // cache 不命中，返回-1 return -1; &#125; // LRU核心：cache 命中，返回值，同时更新节点到头部 LinkListNode* node = _hashmap[key]; moveToHead(node); return node-&gt;value; &#125; // 向cache加入节点 void put(int key, int value) &#123; if(!_hashmap.count(key)) &#123; // cache 不命中 LinkListNode* node = new LinkListNode(key, value); // 是否移除尾部元素 if(_size &gt;= _capacity)&#123; // 当前元素大于等于cache容量，移除尾元素 // 不要忘记去除哈希表内key, value _hashmap.erase(_dummyTail-&gt;prev-&gt;key); // 去除尾节点，即LRU核心：替换掉最近最少使用的元素 removeNode(_dummyTail-&gt;prev); &#125; else &#123; // size加1，对应下面添加新节点 _size++; &#125; // 记录新的节点到哈希表 _hashmap[key] = node; // 将新的节点增加到双链表头节点 addToHead(node); &#125; else &#123; // 取出cache命中的节点，更新新值 LinkListNode* node = _hashmap[key]; node-&gt;value = value; // LRU核心，被使用则更新节点到双链表头部 moveToHead(node); &#125; &#125; // 删除节点并释放内存 void removeNode(LinkListNode* node) &#123; if(node == nullptr) return; node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; delete node; &#125; // 移动节点到双链表头部 void moveToHead(LinkListNode* node) &#123; if(node == nullptr) return; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next = _dummyHead-&gt;next; node-&gt;prev = _dummyHead; _dummyHead-&gt;next-&gt;prev = node; _dummyHead-&gt;next = node; &#125; // 增加节点到双链表头部 void addToHead(LinkListNode* node) &#123; if(node == nullptr) return; node-&gt;next = _dummyHead-&gt;next; node-&gt;prev = _dummyHead; _dummyHead-&gt;next-&gt;prev = node; _dummyHead-&gt;next = node; &#125;&#125;; 运行结果","tags":["C++"]},{"title":"C++基础","path":"//[object Object]/2024/03/12/C-基础/","content":"Bustub前置知识：C++STLC++ STL详解超全总结(快速入门STL)-CSDN博客 string 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt; // 引入 string 头文件int main () &#123; string s1 = &quot;123&quot;; string s2 = &quot;456&quot;;\tstring s = s1 + s2; // 支持 + 连接符 string s;\tcin &gt;&gt; s; //读入字符串，遇空格，回车结束 string s = &quot;xing ma qi&quot;;\tchar ch[] = s.c_str(); // 实现string向char数组的转换&#125; 函数 意义 s.size() 、s.length() 字符串的字符个数 s.max_size() string对象最多包含的字符数 s.capacity() 同上？？？ 12345678910111213s.push_back()\t//在末尾插入s.push_back(&#x27;a&#x27;)\t//末尾插入一个字符as.insert(pos,element)\t//在pos位置插入elements.insert(s.begin(),&#x27;1&#x27;)\t//在第一个位置插入1字符s.append(str)\t//在s字符串结尾添加str字符串s.append(&quot;abc&quot;)erase(iterator p)\t//删除字符串中p所指的字符erase(iterator first, iterator last)\t//删除字符串中迭代器区间[first,last)上所有字符erase(pos, len)\t//删除字符串中从索引位置pos开始的len个字符clear()\t//删除字符串中所有字符s.substr(pos,n)\t// 截取从pos索引开始的n个字符 map：内部用红黑树实现，具有自动排序（按键从小到大）功能。 unordered_map：内部用哈希表实现，内部元素无序杂乱。 C++11新功能 auto关键字 Lambda 智能指针(unique_ptr, shared_ptr, weak_ptr) 右值引用 元组 auto关键字 常用在循环中 12345// Iterating using autofor (auto itr = mapOfStrs.begin(); itr != mapOfStrs.end(); ++itr)&#123; std::cout &lt;&lt; itr-&gt;first &lt;&lt; &quot;::&quot; &lt;&lt; itr-&gt;second &lt;&lt; std::endl;&#125; auto类型确定后不可变 123auto x = 1;// This will cause a compile-time error because &#x27;x&#x27; is of type int// x = &quot;dummy&quot;; 返回类型为 auto 123456auto sum(int x, int y) -&gt; int &#123; return x + y;&#125;// Calling the function that returns &#x27;auto&#x27;auto value = sum(3, 5); 可变参数模板可变参数模板是可以接受任意数量参数的模板。 log函数工作原理： 它打印第一个参数。 它以递归方式调用其余参数。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;// Function to end the recursion of variadic template functionvoid log() &#123; // This can be empty or used to print something that marks the end of output.&#125;template&lt;typename T, typename... Args&gt;void log(T first, Args... args) &#123; std::cout &lt;&lt; first; if constexpr (sizeof...(args) &gt; 0) &#123; std::cout &lt;&lt; &quot; , &quot;; log(args...); &#125; else &#123; std::cout &lt;&lt; std::endl; // New line for the last element &#125;&#125;int main()&#123; // Calling log() functio with 3 arguments log(1 , 4.3 , &quot;Hello&quot;); // Calling log() functio with 4 arguments log(&#x27;a&#x27;, &quot;test&quot;, 78L, 5); // Calling log() functio with 2 arguments log(&quot;sample&quot;, &quot;test&quot;); return 0;&#125; delete关键字delete关键字可以应用于函数，使它们不可调用 下面是删除函数的简单示例： 1void someFunction（） = delete; 隐式类型转换可能很方便，但很危险。如果类型意外转换，它们可能会导致数据丢失或逻辑错误。删除特定的构造函数可以防止这些不需要的转换。例如： 123456// A constructor that might lead to implicit conversionsUser(int userId, std::string userName);// Creating an object with potentially problematic conversionsUser obj4(5.5, &quot;Riti&quot;); // double to intUser obj5(&#x27;a&#x27;, &quot;Riti&quot;); // char to int 若要防止这些转换，请将这些构造函数声明为 deleted： 123// Deleting constructors to prevent implicit conversionsUser(double userId, std::string userName) = delete;User(char userId, std::string userName) = delete; 在这里，我们将删除两个可能导致隐式转换的构造函数： 限制在堆上创建对象, 要确保仅在堆栈（而不是堆上）创建类的实例，您可以删除 new 运算符： 12345class User &#123; // ... // Delete the new operator to prevent heap allocation void* operator new(size_t) = delete;&#125;; 此行确保 new 运算符不能与 User 类一起使用。因此，以下代码将触发编译时错误 12// Error: Use of deleted function &#x27;static void* User::operator new(size_t)&#x27;User* userPtr = new User(1, &quot;Riti&quot;); std::bind是一种通用工具，用于通过将参数绑定到给定函数来创建新的函数对象 123456789101112#include &lt;iostream&gt;#include &lt;functional&gt; // 包含这个头文件以使用 std::bindusing namespace std;int add(int first, int second)&#123; return first + second;&#125;int main()&#123; auto add_func = std::bind(&amp;add, std::placeholders::_1, std::placeholders::_2); cout &lt;&lt; &quot;result:&quot; &lt;&lt; add_func(1, 3) &lt;&lt; endl; return 0;&#125; Lambda123[capture](parameters) mutable exception -&gt; return_type &#123; // function body&#125; [capture] []：未捕获任何内容。 [x, &amp;y]：x按值捕获，y按引用捕获。 [=]：作用域中的所有变量都按值捕获。 [&amp;]：作用域中的所有变量都通过引用捕获。 三个示例 123456int y = 10;auto lambda = [&amp;y](int x) mutable &#123; y = x * y; // 这是有效的，因为 y 是通过引用捕获的，并且 lambda 是 &#x27;mutable&#x27; std::cout &lt;&lt; y &lt;&lt; std::endl;&#125;;lambda(5); // 输出 50 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;int main()&#123; int arr[] = &#123;1, 2, 3, 4, 5&#125;; int discount = 50; // 按值捕获 std::for_each(arr, arr + sizeof(arr) / sizeof(int), [=](int x) mutable &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; // 无法在此处修改“discount”，因为它是按值捕获的，除非使用“mutable”。 discount = 20; &#125;); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;discount Vaue: &quot; &lt;&lt; discount &lt;&lt; std::endl; return 0;&#125;/* 输出：1 2 3 4 5 discount Vaue: 50*/ 列表初始化用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt; template &lt;class T&gt;struct S &#123; std::vector&lt;T&gt; v; S(std::initializer_list&lt;T&gt; l) : v(l) &#123; std::cout &lt;&lt; &quot;constructed with a &quot; &lt;&lt; l.size() &lt;&lt; &quot;-element list &quot;; &#125; void append(std::initializer_list&lt;T&gt; l) &#123; v.insert(v.end(), l.begin(), l.end()); &#125; std::pair&lt;const T*, std::size_t&gt; c_arr() const &#123; return &#123;&amp;v[0], v.size()&#125;; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list &#125;&#125;; template &lt;typename T&gt;void templated_fn(T) &#123;&#125; int main()&#123; S&lt;int&gt; s = &#123;1, 2, 3, 4, 5&#125;; // 复制初始化 s.append(&#123;6, 7, 8&#125;); // 函数调用中的列表初始化 std::cout &lt;&lt; &quot;The vector size is now &quot; &lt;&lt; s.c_arr().second &lt;&lt; &quot; ints: &quot;; for (auto n : s.v) std::cout &lt;&lt; n &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &quot;Range-for over brace-init-list: &quot;; for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作 std::cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; &#x27; &#x27;; auto al = &#123;10, 11, 12&#125;; // auto 的特殊规则 std::cout &lt;&lt; &quot;The list bound to auto has size() = &quot; &lt;&lt; al.size() &lt;&lt; &#x27; &#x27;; // templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式， // 它无类型，故 T 无法推导 templated_fn&lt;std::initializer_list&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // OK templated_fn&lt;std::vector&lt;int&gt;&gt;(&#123;1, 2, 3&#125;); // 也 OK&#125; 什么是左值什么是右值？理解 C/C++ 中的左值和右值 | nettee 的 blog 左值 (lvalue, locator value) 表示占据内存中某个可识别的位置 的 对象。 右值 (rvalue) 则使用排除法来定义。一个表达式不是 左值 就是 右值 。 那么，右值是一个 不表示内存中某个可识别位置的对象的表达式。 左/右值转换123int a = 1;int b = 2;int c = a + b; // a, b, c是左值，但在 &quot;+&quot; 运算时转换为了右值。即左值隐式转化为右值。 但是，右值不能转换为左值！不过右值可以显式转化为左值 123int arr[] = &#123;1, 2&#125;;int *p = &amp;arr[0];*(p+1) = 10; // p+1 为右值，但指针符号 * 将 p+1 转换为左值。 ⭐右值引用右值引用，这个功能自C++11起才可用。移动语义是C++11新增的重要功能，其重点是对右值的操作。右值可以看作程序运行中的临时结果，右值引用可以避免复制提高效率。&amp;&amp;用法示例： 12345678910111213141516171819#include &lt;iostream&gt;struct Foo &#123; ~Foo() &#123;std::cout &lt;&lt; &quot;destruction&quot; &lt;&lt; std::endl;&#125;&#125;;Foo FooFactory() &#123; return Foo();&#125;int main() &#123; std::cout &lt;&lt; &quot;before copy constructor...&quot; &lt;&lt; std::endl; Foo foo1 = FooFactory(); std::cout &lt;&lt; &quot;after copy constructor...&quot; &lt;&lt; std::endl &lt;&lt; std::endl; // 引用右值，避免生成新对象 Foo&amp;&amp; foo2 = FooFactory(); std::cout &lt;&lt; &quot;life time ends!&quot; &lt;&lt; std::endl &lt;&lt; std::endl; return 0;&#125; 用clang编译器编译上述代码， 运行结果如下： 12345678910before copy constructor...destructiondestructionafter copy constructor...destructionlife time ends!destructiondestruction 从输出结果看，第二种写法少了一次destruction输出，特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象。这意味着通过右值引用(&amp;&amp;)，foo2直接引用FooFactory返回的对象，避免了对象复制。 移动语义认识C++移动语义与右值引用 - 知乎 (zhihu.com) 移动语义的“移动”，意味着把某对象持有的资源或内容转移给另一个对象。 12// vec_red = vec_orange; // vec_orange被绑定到const std::vector&lt;int&gt; &amp;类型vec_red = std::move(vec_orange); // vec_orange被绑定到std::vector&lt;int&gt; &amp;&amp;类型 vec_orange是一个左值（它有名字），不经过std::move()的转型则会绑定到一个左值引用；而std::move()则把它转为一个右值引用，从而匹配到移动赋值运算符函数。 例子：std::unique_ptr 简易实现 12345678910111213141516171819202122template &lt;typename T&gt;class my_unique_ptr&#123; T* ptr_;public: // 移动构造函数和移动赋值函数 my_unique_ptr(my_unique_ptr&amp;&amp; other): ptr_(std::exchange(other.ptr_, nullptr))&#123;&#125; my_unique_ptr&amp; operator=(my_unique_ptr&amp;&amp; rhs) &#123; if (this != &amp;rhs) &#123; if (ptr_) &#123; // 释放当前拥有的指针 delete ptr_; &#125; ptr_ = std::exchange(rhs.ptr_, nullptr); // 夺取rhs的指针 &#125; return *this; &#125; // 禁止复制构造函数和复制赋值函数 my_unique_ptr(const my_unique_ptr&amp;) = delete; my_unique_ptr&amp; operator=(const my_unique_ptr&amp;) = delete;&#125; noexceptnoexcept 是一个异常说明符，用于告诉编译器一个函数不会抛出任何异常。 如上图所示那般，老的元素是被拷贝到新的内存空间中的。是的，classes容器确实使用的是拷贝构造函数。那么此时我们会想到，既然classes容器已经不需要之前的内存中的数据了，那么将老数据放到新的内存空间中应该使用移动语义，而非拷贝操作。 那么为什么classes容器没有使用移动语义呢？ 此时，我们需要提及一个概念，即”强异常保证（strong exception guarantee）”。所谓强异常保证，即当我们调用一个函数时，如果发生了异常，那么应用程序的状态能够回滚到函数调用之前： 那么强异常保证和决定使用移动语义或拷贝操作又有什么关系呢？ 这是因为容器的push_back函数是具备强异常保证的，也就是说，当push_back函数在执行操作的过程中（由于内存不足需要申请新的内存、将老的元素放到新内存中等），如果发生了异常（内存空间不足无法申请等），push_back函数需要确保应用程序的状态能够回滚到调用它之前。以上面的例子来说，当第2次执行classes.push_back(A);时，如果发生了异常，应用程序的状态会回滚到第1次执行classes.push_back(A);之后，即classes容器中只有一个元素。 由于我们的移动构造函数没有使用noexcept说明符，也就是我们没有保证移动构造函数不会抛出异常。因此，为了确保强异常保证，就只能使用拷贝构造函数了。那么拷贝构造函数同样没有保证不会抛出异常，为什么就能用呢？这是因为拷贝构造函数执行之后，被拷贝对象的原始数据是不会丢失的。因此，即使发生异常需要回滚，那些已经被拷贝的对象仍然完整且有效。但移动语义就不同了，被移动对象的原始数据是会被清除的，因此如果发生异常，那些已经被移动的对象的数据就没有了，找不回来了，也就无法完成状态回滚了。 总结 移动语义让程序员在复制对象时有所选择。 右值引用是C++语法层面表示移动语义的机制。 std::move()没有移动任何东西，只是把一个表达式转型（cast）为右值。 尽量让具有移动语义的函数noexcept C++多线程C++并发编程（C++11到C++17）-阿里云开发者社区 (aliyun.com) C++11提供如下4种语义的互斥量（mutex） ： std::mutex，独占的互斥量，不能递归使用。 std::timed_mutex，带超时的独占互斥量，不能递归使用。 std::recursive_mutex，递归互斥量，不带超时功能。 std::recursive_timed_mutex，带超时的递归互斥量。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;mutex&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#define TRY_MUTEX 0#define MY_MUTEX 1volatile int counter(0); // non-atomic counterstd::mutex mtx;void increases10k()&#123; for(int i=0;i&lt;10000;i++) &#123;#if TRY_MUTEX if(mtx.try_lock()) &#123; ++counter; mtx.unlock(); &#125;#elif MY_MUTEX mtx.lock(); ++counter; mtx.unlock();#endif &#125;&#125;int main(int argc,char **argv)&#123; std::thread threads[10]; for(int i=0;i&lt;10;i++) &#123; threads[i]=std::thread(increases10k); &#125; for(auto&amp; th:threads) th.join(); std::cout &lt;&lt; &quot; successful increases of the counter &quot; &lt;&lt; counter &lt;&lt;std::endl; return 0;&#125; 编译： 1g++ -o mutex_test mutex_test.c -std=c++11 -lpthread 执行效果： 123456# try_lock$ ./mutex_test successful increases of the counter 53612# lock$ vim mutex_test.c successful increases of the counter 100000 可以看到try_lock只是尝试加锁，不管是否成功都不阻塞，而lock如果加锁失败会一直阻塞直到加锁成功。 API C++标准 说明 lock_guard C++11 实现严格基于作用域的互斥体所有权包装器 unique_lock C++11 实现可移动的互斥体所有权包装器 shared_lock C++14 实现可移动的共享互斥体所有权封装器 scoped_lock C++17 用于多个互斥体的免死锁 RAII 封装器 锁定策略 C++标准 说明 defer_lock C++11 类型为 defer_lock_t，不获得互斥的所有权 try_to_lock C++11 类型为try_to_lock_t，尝试获得互斥的所有权而不阻塞 adopt_lock C++11 类型为adopt_lock_t，假设调用方已拥有互斥的所有权 上面的几个类（lock_guard，unique_lock，shared_lock，scoped_lock）都使用了一个叫做RAII的编程技巧。 future API C++标准 说明 async C++11 异步运行一个函数，并返回保有其结果的std::future future C++11 等待被异步设置的值 packaged_task C++11 打包一个函数，存储其返回值以进行异步获取 promise C++11 存储一个值以进行异步获取 shared_future C++11 等待被异步设置的值（可能为其他 future 所引用） 可以在并发环境中使用的工具，它们都位于&lt;future&gt;头文件中。 std::future可以看成存储器，存储一个未来返回值。先在主线程内创建一个promise对象，从promise对象中获得future对象；再将promise引用传递给任务线程，在任务线程中对promise进行set_value，主线程可通过future获得结果。 std::future提供了一个重要方法就是.get()，这将阻塞主线程，直到future就绪。注意：.get()方法只能调用一次。 此外，std::future不支持拷贝，支持移动构造。c++提供的另一个类std::shared_future支持拷贝。 可以通过下面三个方式来获得std::future。 std::promise的get_future函数 std::packaged_task的get_future函数 std::async 函数 asyncstd::async的第一个参数：std::launch::deferred【延迟调用】和std::launch::async【强制创建一个线程】。 std::launch::deferred:表示线程入口函数调用被延迟到std::future对象调用wait()或者get()函数 调用才执行。如果wait()和get()没有调用，则不会创建新线程，也不执行函数；如果调用wait()和get()，实际上也不会创建新线程，而是在主线程上继续执行； std::launch::async:表示强制这个异步任务在 新线程上执行，在调用std::async()函数的时候就开始创建线程。 std::launch::deferred|std::launch::async:这里的“|”表示或者。如果没有给出launch参数，默认采用该种方式。操作系统会自行评估选择async or defer，如果系统资源紧张，则采用defer，就不会创建新线程。避免创建线程过长，导致崩溃。 嘶，async默认的launch方式将由操作系统决定，这样好处是不会因为开辟线程太多而崩溃，但坏处是这种不确定性会带来问题。std::async在使用时不仅要注意launch的不确定性，还有一个坑：async返回的future对象的析构是异步的。 ⭐总结 互斥量（Mutex）：作用：互斥量用于实现临界区的互斥访问，确保在同一时刻只有一个线程可以访问被互斥锁保护的共享资源。 特点和使用：使用 std::mutex 或其变体（如 std::recursive_mutex）来创建互斥锁。通过 std::lock_guard 或 std::unique_lock 来管理互斥锁的锁定和解锁。适用于需要保护共享资源免受并发访问的场景。 1234567891011#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void example_function() &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); // 互斥区，对共享资源的访问受到保护 // ...&#125; // 锁在此处自动释放 条件变量（Condition Variable） 作用：条件变量用于实现线程之间的协同操作，允许一个线程等待某个特定条件的发生，而其他线程可以在条件满足时通知等待的线程。 特点和使用：使用 std::condition_variable 创建条件变量。与互斥锁一起使用，通常需要 std::unique_lock 进行锁的管理。适用于线程之间需要等待某个条件满足才能继续执行的情况。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;std::mutex mtx;std::condition_variable cv;bool condition = false;void producer() &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); condition = true; cv.notify_one();&#125;void consumer() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); cv.wait(lock, []&#123; return condition; &#125;); // 条件满足后继续执行&#125;int main() &#123; std::thread producer_thread(producer); std::thread consumer_thread(consumer); producer_thread.join(); consumer_thread.join(); return 0;&#125; 期望（std::future 和 std::promise）： 作用：期望用于异步编程，允许一个线程获取另一个线程的异步任务的结果。 特点和使用：使用 std::future 表示异步任务的未来结果，使用 std::promise 设置异步任务的值。 通过 std::async 或 std::packaged_task 创建异步任务。 适用于在一个线程中执行任务，而另一个线程等待任务的结果。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;future&gt;int add(int a, int b) &#123; return a + b;&#125;int main() &#123; std::promise&lt;int&gt; promise_result; std::future&lt;int&gt; future_result = promise_result.get_future(); std::thread([&amp;](std::promise&lt;int&gt;&amp; p) &#123; p.set_value(add(1, 2)); &#125;, std::ref(promise_result)).detach(); int result = future_result.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 总结 互斥量用于保护共享资源，防止并发访问。 条件变量用于线程之间的协同操作，等待某个条件满足后继续执行。 期望用于异步编程，允许一个线程获取另一个线程的异步任务的结果。 类型转换"},{"title":"Hello World","path":"//[object Object]/2024/03/12/Hello-Stellar/","content":"考研结束，博客重启从2023年5月份准备考研到2024年3月，我的博客已经闲置了将近半年之久…. 考研心路去年3月份找工作的时候，想着能找一份不错的前端实习开发，结果大厂小厂投了十几家，过了一个月之久都没什么进展。。。。 无奈之下，5月份辞掉老师那边的实习工作，开始备战24考研，妄想重开。 备战历程。。。3.12后续更新 再说说博客8月份————我的阿里轻量云服务器过期了 9月份————我的域名 wangwangyz.site过期了 期间在认真准备考研（基础太差…）, 导致我的网站以及我的服务器任何脚本、程序都没来得及备份， 重新开始这次我的目标不再是前端方向（以前的还是太烂了…），而是C++后台开发和杂谈大模型相关的了（要开始好好规划和准备未来了😫😫😫不能贪玩了）。"},{"title":"计算机网络大作业","path":"//[object Object]/2023/05/16/计算机网络大作业/","content":"实验要求 wireshark的深入学习与掌握，如过滤器的使用，归纳方法 通过实验阐述ARP的工作原理 利用实验结果分析 ICMP 协议的报文结构字段定义 基于实验数据深入分析 TCP 协议的连接过程原理，报文的分片等功能 从校园网发起向外网中某 Web 服务器的访问，记录并分析从 MAC 层协议、IP 协议、TCP 协议一直到 HTTP 协议的过程 1. Wireshark学习 1.1 什么是Wireshark？Wireshark 是一个网络数据包分析器。以下是 Wireshark 提供的众多功能中的一部分： 适用于_UNIX_和_Windows_。 从网络接口 捕获实时数据包数据。 显示包含_非常详细协议信息的_数据包。 _保存_捕获的数据包数据。 以多种捕获文件格式 导出部分或全部数据包。 根据许多标准 过滤数据包。 根据许多条件 搜索数据包。 根据过滤器对数据包显示 进行着色。 创建各种_统计数据_。 ….等等 1.2 Wireshark支持的网络类型Wireshark使用 libpcap/WinPcap 捕获库，其捕获机制不支持在所有平台上捕获所有网络类型。各平台支持的网络类型如下： Interface Linux macOS Windows 蓝牙 ✅ ❌ ❌ 以太网 ✅ ✅ ✅ USB ✅ ❌ ❌ 无线局域网 ✅ ✅ ✅ PPP链路 ✅ ✅ ✅ 蓝牙 - 捕获蓝牙流量 - 目前仅限于在 linux 上附加堆栈。 以太网 - 在不同的以太网拓扑上捕获，包括交换网络。 USB - 捕获原始 USB 流量。 WLAN - 在 802.11（WLAN、Wi-Fi）接口上捕获，包括“监控模式”、原始 802.11 标头和无线电信息。 PPP链接 - 在拨号线路、ISDN 连接和 PPP-over-Ethernet（PPPoe，例如 ADSL）上捕获。 1.3 Wireshark过滤器1.3.1 实验环境系统 信息 操作系统名称 Microsoft Windows 11 家庭中文版 版本 10.0.22621 版本 22621 处理器 Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz，2112 Mhz，4 个内核，8 个逻辑处理器 系统类型 基于 x64 的电脑 网卡类型 Intel(R) Wireless-AC 9462 Wireshark版本 4.0.5-64bit 1.3.2 界面 Wireshark首页主要分为以下几个界面： 菜单栏（包括文件、编辑、视图、捕获等功能） 工具栏（开始/停止捕获、查找分组等） 过滤栏（用于设置过滤条件进行数据包列表过滤） 数据列表区（显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。） 数据详细区（显示数据包的所有详细信息内容） 数据字节区（显示数据包原始字节流信息） 数据统计区（统计捕获到的分组数） 1.3.3 过滤器的使用Wireshark的过滤器可以分为两种主要类型：捕获过滤器 和 显示过滤器。 捕获过滤器：使用Wireshark的捕获过滤器，用户可以过滤捕获的数据包以匹配用户指定的条件。这些过滤器可以根据协议、源/目标IP地址、端口、协议标志等条件进行设置。捕获过滤器可以手动输入或通过菜单选择，也可以从过滤器面板中选择预定义的过滤器。 显示过滤器：使用Wireshark的显示过滤器，用户可以将已捕获的数据包按照指定的条件进行过滤，并只显示与这些条件匹配的数据包。这些条件可以基于协议、源/目标IP地址、端口、时间戳等。显示过滤器可以通过在过滤器面板中手动输入或选择预定义的过滤器来创建。显示过滤器可以帮助用户快速查找感兴趣的数据包，也可以节省屏幕空间和处理时间。 1.3.3.1 捕获过滤器捕获过滤器位于菜单栏的 捕获–&gt; 捕获过滤器。用于捕获数据包前设置捕获条件。 1.3.3.2显示过滤器显示过滤器位于首页的 工具栏下方 的输入框。 当我们在终端输入 ping www.baidu.com 时，在捕获时未设置抓包过滤规则直接通过网卡进行抓取所有数据包，如下 此时数据包内容较多，为了筛选我们想要的信息，则需要在显示过滤器中添加我们想要的过滤条件 如：ip.addr == 39.156.66.14 ，得到如下结果 即可得到我们想要的 Ping 之后的 ICMP 报文。这基本上满足了我们的需求！ 1.3.3.3 过滤规则总结当使用Wireshark时，可以使用过滤规则来筛选和查看感兴趣的数据包。以下是一些常用的Wireshark过滤规则： 过滤特定IP地址：可以使用以下过滤器来查看特定IP地址的数据包： 1ip.addr == x.x.x.x //x.x.x.x为特定IP地址 过滤特定IP地址和端口号：可以使用以下过滤器来查看特定IP地址和端口号的数据包： 1(ip.addr == x.x.x.x) &amp;&amp; (tcp.port == n) //x.x.x.x为特定IP地址，n为端口号 过滤特定协议：可以使用以下过滤器来查看特定协议的数据包： 123tcp //只显示TCP协议的数据包udp //只显示UDP协议的数据包icmp //只显示ICMP协议的数据包 过滤特定的数据包大小：可以使用以下过滤器来查看特定大小的数据包： 123frame.len == n //只显示大小为n的数据包frame.len &gt; n //只显示大小大于n的数据包frame.len &lt; n //只显示大小小于n的数据包 过滤特定的数据包类型：可以使用以下过滤器来查看特定类型的数据包： 123dns //只显示DNS数据包http //只显示HTTP数据包ssl //只显示SSL数据包 过滤特定的数据包内容：可以使用以下过滤器来查看特定内容的数据包： 123http.request.method == &quot;POST&quot; //只显示HTTP POST请求http.response.code == 200 //只显示HTTP 200响应dns.qry.name == &quot;www.example.com&quot; //只显示请求www.example.com的DNS数据包 这些是常用的Wireshark过滤规则示例。还有很多其他过滤规则，可以根据具体情况进行选择和设置。 官网显示过滤器参考：https://www.wireshark.org/docs/dfref/ 2. ARP 原理探究ARP（Address Resolution Protocol，地址解析协议）是一种用于将IP地址映射到物理MAC地址的协议。ARP是在本地网络中运行的协议，其目的是为了在不同网络层之间建立映射关系，使得数据包能够正确地被传送到其目的地。 2. 1 实验准备两台主机A、B，且连接同一个局域网。 2.1.1 查看主机IP地址和MAC地址Windows 下打开命令提示符，输入ipconfig/all： 得到当前A主机的MAC地址为 A4-B1-C1-9B-28-**，校园网下IP地址为：192.168.1.101 B主机的MAC地址为 **D8-12-65-6E-D3-****，校园网下IP地址为 192.168.1.100 主机 IP地址 MAC地址 A 192.168.1.101 A4-B1-C1-9B-28-** B（实验机） 192.168.1.100 D8-12-65-6E-D3-** 2.2 查看ARP表在 A 主机下查看当前 ARP 表，输入 arp -a，结果如下: 此时并未有 B 主机的 ARP表项。 2.3 Wireshark捕获后台打开相应网卡开始捕获，此时 A 主机命令提示符输入ping 192.168.1.100，向B发送 ICMP 报文以及 A主机发送ARP广播。 此时在重新输入 arp -a，发现得到 B 主机的相应MAC地址，实验成功！ 2.4 Wireshark分析ARP原理 首先，假设主机A需要向主机B发送一个数据包，但是不知道主机B的物理地址（MAC地址），只知道主机B的IP地址，主机A将一个ARP请求广播到本地网络中的所有设备，请求包含目标IP地址和发送者MAC地址（通常是广播地址）。 交换机S接收到ARP请求，并将其转发到本地网络中的所有设备。由于这是一个广播消息，因此每个设备都会接收到此请求。主机B接收到ARP请求，检查其中的IP地址是否匹配自己的IP地址。如果是，主机B会向主机A发送一个ARP响应，该响应包含其MAC地址。 ARP响应被广播到本地网络中的所有设备，主机A接收到响应并保存主机B的MAC地址到其ARP缓存中，以备将来使用。 通过上述实验，我们可以看出ARP的工作原理是通过广播的方式，在本地网络中进行的。ARP请求和响应都是广播消息，这意味着所有的网络设备都能够接收到并处理它们。ARP缓存记录了IP地址和对应的MAC地址，这可以避免重复的ARP请求并加速数据包的传输。 总结：ARP是一种在本地网络中工作的协议，它允许主机在不知道目标MAC地址的情况下查找目标设备的物理地址，从而实现数据包的正确传输。 3. ICMP 协议的报文结构定义3.1 获取ICMP报文由于 Ping 工作在应用层且直接使用网络层的 ICMP 协议，根据这个原理，在命令提示符输入 ping 192.168.1.100 即可在 Wireshark 捕获到 ICMP 报文，在显示过滤器里面输入 icmp 即可得到相应的 ICMP 报文数据。 3.2 ICMP结构分析3.2.1 IP数据报查看IP数据报，观察IP数据报的首部字段及其内容，其报文结构如下： 3.2.2 ICMP 数据报点击Internet Control Message Protocol展开，查看 ICMP报文，如下分别为ICMP询问报文的回送请求报文和回答报文的首部字段。 由此我们可以得到的 ICMP报文结构定义如下： 类型（8 bits）：表示ICMP报文的类型，共有14种类型（例如回显请求、回显响应、目标不可达等）。Type的值在1~255之间，不同的类型有不同的Code值。 代码（8 bits）：表示ICMP报文的代码，用于更精确地描述ICMP报文的目的。Code的值在0~255之间，不同的Code值对应不同的类型。 校验和（16 bits）：是ICMP报文的校验和，用于检测数据是否传输过程中发生了错误。 数据（可变长度）：是ICMP报文的数据部分，其长度取决于ICMP报文的类型和代码。 4. TCP 原理探究4.1 实验准备 获取 www.baidu.com 的实际IP地址，在命令提示符输入： 1ping www.baidu.com 得到当前 www.baidu.com 的 IP 地址为：39.156.66.14 打开 Wireshark 捕获，开始抓取数据包，并在显示过滤器加入过滤条件： 1ip.addr == 39.156.66.14 4.2 TCP 三次握手原理此时在主机的浏览器搜索栏输入 www.baidu.com 进入百度网站，在 Wireshark 中观察TCP报文的捕获情况，如下： 可以看到浏览器打开百度网站时，本主机与百度服务器进行了 TCP三次握手 ，根据这三次握手，分析 TCP连接管理的原理。 4.2.1 第一次握手阶段由于 TCP协议是负责主机 端到端 的连接，因此本主机操作系统随机选取其中一个 动态端口号（49152~65535），本例中选取了 54617 作为源端口号，目的端口号是百度服务器提供的 HTTPS端口 443，由于此报文是 TCP同步报文，因此此时 ACK 位为 0（Not set），SYN 位为 1，随机序列号为 948123796。此时为客户端请求建立链接阶段，客户端进入 同步已发送 状态，等待服务器端确认，如图所示，TCP报文如下： 4.2.2 第二次握手阶段此时源端口为百度服务器提供的 HTTPS端口 443，目的端口为本主机的 54617，确认号为 948123796+1，即表示已成功收到 第一次握手阶段 的请求建立连接报文！此时第二次握手阶段的TCP报文随机选取一个序列号为 3375721040，同步位和确认位均为 1。百度服务器将该数据包发送给客户端以表示确认连接请求，服务器端进入同步已接收 状态。TCP报文如下所示： 4.2.3 第三次握手阶段本主机收到第二次握手阶段的TCP报文后，向百度服务器发送一个确认报文，表示收到了确认信息。该报文中的ACK字段值为收到的 3375721040+1，并且序列号为收到的ACK值 948123796+1。客户端和服务器端进入 连接已建立 状态，完成三次握手，此时 TCP 报文如下： 至此本主机和百度服务器成功建立可靠的TCP连接！随后客户端与服务器端之间可以开始传输数据。 4.3 报文的分片4.3.1 不分片报文传输 较短 IP 报文 观察不分片标志对于较短的 IP 报文传输的影响，在 命令提示符中输入 ping -l 1472 -f 192.168.1.102，意思是向 192.168.1.102 主机发送长度为 1472字节的数据包，但是此 IP报文 不进行分片，结果如图所示： 可见以太网帧总长度为 IP首部 20 + ICMP首部 8 + 数据长度1472 ＝1500（小于等于 MTU 的 1500），不分片标志的片位移为 0，由此可知：不分片标志对较小的 IP 报文传输没有影响。 较大 IP 报文 观察不分片标志对较大 IP 报文传输的影响，在 命令提示符中输入 ping -l 1473 -f 192.168.1.102，结果如图所示： 可见：由于IP报文的长度（IP首部 20 + ICMP首部 8 + 数据长度1473 ＝1501 ）过大（超过了 MTU 的 1500 长度），不分片标志会导致超过 MTU 的长报文无法传输。 4.3.2 分片报文传输打开命令提示符，输入ping -l 3000 -n 1 192.168.1.102，意思为只发送一个大小为3000的数据包。结果如下： 需要封装在 IP数据包里面发送的数据大小为 8（ICMP首部）+3000（数据包）= 3008。 第一个分片不能超过 MTU，所以为 20（IP首部）+ 1480（数据分片）= 1500；第二个分片不能超过 MTU，所以也为 20（IP首部）+ 1480（数据分片）= 1500；由于 3008（数据总长度）- 1480 - 1480 = 48，因此第三个分片大小为 20（IP首部） + 48（剩余数据）=68。分析结果与实验数据一致！ 5. Web服务器连接过程 要求：从校园网发起向外网中某 Web 服务器的访问，记录并分析从 MAC 层协议、IP 协议、TCP 协议一直到 HTTP 协议的过程。 5.1 访问云 Web服务器以个人网站 http://47.94.12.50 为例，后台打开 Wireshark嗅探，显示过滤器输入 ip.addr == 47.94.12.50。 5.2 收到的数据报文在Wireshark嗅探到的数据报文如下所示： 首先 主机先与云服务器进行第一次 TCP 连接，完成三次握手，然后应用层使用 HTTP 协议进行传输，最后传输层使用 TCP四次挥手释放第一次 TCP 连接。下面根据自下而上地分析从 MAC 层协议、IP 协议、TCP 协议一直到 HTTP 协议的过程。 5.3 MAC 协议以首次收到的 HTTP 报文为例，其收到的以太网帧数据如下： 由 以太网Ⅱ 帧的格式可知，此以太网帧的目的地址为 ca:9e:6b:d1:d7:**，源地址为 a4:b1:c1:9b:28:** ，类型为 0x0800。由于在我们抓到的包中，前八个字节的前导码和帧开始符已经被网卡过滤掉了所以我们抓不到。 常见的类型对应值如下： 值 协议 0x0800 IPv4 0x0806 ARP 0x86DD IPv6 0x88CC LLDP 0x8035 RARP 我们的帧类型为0x0800 是一个 IPv4 的封装帧，后面的冗余校验也和前导码一样，已经被网卡删掉了，所以捕获不到，以太网的头部就已经全部抽离了，我们继续分析下一层协议：IPv4。 5.4 IPv4 协议由此 IP报文 可知： 版本：4（即 IPv4，0x0100 = 4）； 首部长度：20（即 5 * 4B = 20B）； ECN：Not-ECT（显式拥塞通知Explicit Congestion Notification，简称ECN，00代表不支持 ECN）； DF：1（不分片）； MF：0（没有分片）； Offset：0（没有偏移）； 由于以太网有 MTU 的包大小限制，IPv4 选择了通过分片重组的方式来向上层的传输层协议提供传输任意包大小的能力，DF、MF、Offset位就是用来进行分片控制的。 TTL：0x40 = 64，代表了这个包的存活时间，还剩 64 s； 上层协议：0x06 = 6，代表 TCP， 常见取值如下： 取值 协议 1 ICMP 6 TCP 17 UDP 源 IP 地址：192.168.93.86 目的 IP 地址：47.94.12.50 5.5 TCP协议IP 数据部分就是 TCP报文，其数据如下： 源端口： c0 8a -&gt; 49290。 目的端口：00 50 -&gt; 80 。 最大端口值为 2^16-1 = 65535，端口号划分成了三段： 端口范围 用途 0-1023 公认端口。常见的公认端口有：ftp(21)、ssh(22 )、smtp(25)、http(80 )、https(443) 等。 1024-49151 用户自用。一般操作系统会随机在其中选择可用端口。 49152-65535 保留端口。一般不推荐使用，因为用户端口也很够用了。 序列号：2288663079。 确认号：2099426961。 之后紧接着是九个启用中的标志位，下面我们来逐位分析。 NS: ECN-nonce，显式拥塞通知（Explicit Congestion Notification），这个是和 IP 层的 ECN 一样，主动表示发生了网络拥塞的信号。 CWR: Congestion Window Reduced，这个是配合 ECN 标志位使用的，用来通知发送者拥塞窗口已经调小。 ECE：ECN-Echo，这个标志位主要是用 TCP 连接在握手的时候用来协商两端是否都支持显示拥塞控制。 URG: Urgent Pointer field significant，代表存在于选项中的紧急指针字段已经启用，需要尽快处理这些数据，不过使用的范围不广。 ACK: Acknowledgment field significant，代表 ACK 字段有效。 PSH: Push Function，用于将缓冲区内的所有数据全部发送，不再等待，同时对端在收到 PSH 标志时，应立即将数据全部递交给上层应用处理，不用再等待数据合并提交。PSH 标志位和 TCP_NoDelay 选项的区别在于，PSH 是 TCP 报文中的字段，对端也会做出对应的响应，而 TCP_NoDelay 只是内核的一个参数，用于在当前应用中关闭 Nagle 算法。 RST: Reset，用于重置当前连接，一般用于拒绝连接，或者出现错误时指示重建连接。 SYN: Synchronize sequence numbers，同步序列号，用于建立连接并同步序列号。 FIN: Finish, 用于关闭连接，表明没有数据要发送了。 在我们的包中，这九个标志位分别是：000011000，ACK = 1，PSH = 1，代表 ACK 字段是生效的， 窗口大小：259，单位是字节。 校验和：5c 05 ，这个校验和在计算时不仅包括头部，也包括了传输内容。 紧急指针：我们这里 URG 标志位是 0，所以也就不存在紧急指针，这 16 位全是 0。 TCP 的选项字段：TCP 选项是不定长的。 5.6 HTTP 协议 由此 HTTP报文可知主机通过 HTTP/1.1 协议使用 GET 的请求方法向 服务器 资源发起请求。 Host ：47.94.12.50，代表了请求资源所属的主机。 User-Agent：Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36，代表主机使用的 HTTP 协议的客户端类型。 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7， 代表客户端这边支持任何类型的资源。 5.7 总结计算机网络的组成可以自底向上地总结为以下几个层次，每个层次负责不同的功能和任务： 物理层 物理层是计算机网络的最底层，负责传输原始的比特流。 它定义了电气、光学和机械接口的规范，以及传输介质的特性和传输速率等。 主要任务是将比特流从发送端传输到接收端，没有对数据进行处理或分析。 数据链路层 数据链路层建立在物理层之上，负责在直接相连的节点之间可靠地传输数据。 它将比特流划分为帧，处理错误检测和纠正，以及帧的传输控制。 主要任务是提供可靠的数据传输，并处理节点之间的通信错误。 网络层 网络层是在数据链路层之上，处理不同网络之间的数据包转发和路由选择。 它负责将数据包从源主机传输到目标主机，通过路由选择算法确定数据包的最佳路径。 主要任务是实现逻辑上的主机到主机的通信，以及网络互联和互操作性。 传输层 传输层建立在网络层之上，提供端到端的数据传输和服务质量控制。 它为应用程序提供可靠的数据传输和错误恢复，并进行流量控制和拥塞控制。 主要任务是确保数据在源主机和目标主机之间的可靠传输，以及提供端到端的连接和通信服务。 应用层 应用层是网络的最高层，提供特定应用程序和用户之间的接口。 它包括各种应用层协议和服务，例如电子邮件、文件传输、Web浏览等。 主要任务是为用户提供各种应用程序和服务，以满足特定的通信需求。 通过这次Wireshark抓包实验帮助了我更深层次地理解每一层的功能和责任，以及它们如何协同工作来实现可靠的数据通信和应用服务！","tags":["计算机网络"],"categories":["学习笔记","专业技术"]},{"title":"IPFS简介","path":"//[object Object]/2023/03/11/ipfs简介/","content":"https://zhuanlan.zhihu.com/p/32615963 Peer-to-peer hypermedia protocol 什么是IPFS星际文件系统(InterPlanetary File System). IPFS 是一个分布式的web, 点到点超媒体协议. 可以让我们的互联网速度更快, 更加安全, 并且更加开放. IPFS协议的目标是取代传统的互联网协议HTTP。 为什么有IPFS众所周知, 互联网是建立在HTTP协议上的. HTTP协议是个伟大的发明, 让我们的互联网得以快速发展.但是互联网发展到了今天HTTP逐渐出来了不足. HTTP的中心化是低效的, 并且成本很高使用HTTP协议每次需要从中心化的服务器下载完整的文件(网页, 视频, 图片等), 速度慢, 效率低. 如果改用P2P的方式下载, 可以节省近60%的带宽. P2P将文件分割为小的块, 从多个服务器同时下载, 速度非常快. Web文件经常被删除回想一下是不是经常你收藏的某个页面, 在使用的时候浏览器返回404(无法找到页面), http的页面平均生存周期大约只有100天. Web文件经常被删除(由于存储成本太高), 无法永久保存. IPFS提供了文件的历史版本回溯功能(就像git版本控制工具一样), 可以很容易的查看文件的历史版本, 数据可以得到永久保存 中心化限制了web的成长我们的现有互联网是一个高度中心化的网络. 互联网是人类的伟大发明, 也是科技创新的加速器. 各种管制将对这互联网的功能造成威胁, 例如: 互联网封锁, 管制, 监控等等. 这些都源于互联网的中心化.而分布式的IPFS可以克服这些web的缺点. 互联网应用高度依赖主干网主干网受制于诸多因素的影响, 战争, 自然灾害, 互联网管制, 中心化服务器宕机等等, 都可能是我们的互联网应用中断服务. IPFS可以是互联网应用极大的降低互联网应用对主干网的依赖. IPFS的目标IPFS不仅仅是为了加速web. 而是为了最终取代HTTP协议, 使互联网更加美好 IPFS包含哪些内容IPFS是一个协议，类似http协议 定义了基于内容的寻址文件系统 内容分发 使用的技术分布式哈希、p2p传输、版本管理系统 IPFS是一个文件系统 有文件夹和文件 可挂载文件系统 IPFS是一个web协议 可以像http那样查看互联网页面 未来浏览器可以直接支持 ipfs:/ 或者 fs:/ 协议 IPFS是模块化的协议 连接层：通过其他任何网络协议连接 路由层：寻找定位文件所在位置 数据块交换：采用BitTorrent技术 IPFS是一个p2p系统 世界范围内的p2p文件传输网络 分布式网络结构 没有单点失效问题 IPFS天生是一个CDN 文件添加到IPFS网络，将会在全世界进行CDN加速 bittorrent的带宽管理 IPFS拥有命名服务 IPNS：基于SFS（自认证系统）命名体系 可以和现有域名系统绑定","categories":["思想感悟","学习笔记"]},{"title":"常见HTTP状态码及简介","path":"//[object Object]/2023/03/11/常见http状态码及简介/","content":"HTTP状态码所有状态码的第一个数字代表了响应的五种状态之一（消息、成功、重定向、请求错误、服务器错误）。 消息（1xx）这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。 100 Continue（继续）客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 成功（2xx）这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 200 OK（成功） 请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。 204 No Content（没有内容）服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 重定向（3xx）这一类型的状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。 301 Moved Permanently（永久移除）被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 302 Move Temporarily（暂时移动）请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 注意：同301 304 Not Modified（未修改）如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 请求错误（4xx）这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。 400 Bad Request（错误请求） 语义有误，当前请求无法被服务器理解。 请求参数有误。 401 Unauthorized（未经授权）当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。 403 Forbidden（被禁止）服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found（找不到）请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 405 Method Not Allowed（不允许的方法）请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 408 Request Timeout（请求超时）请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 服务器错误（5xx）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 500 Internal Server Error（内部服务器错误）服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 502 Bad Gateway（错误的网关）作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable（服务不可用）由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 详细链接 HTTP状态码401、404等代码的意思","tags":["HTTP","计算机网络"],"categories":["学习笔记","专业技术"]},{"title":"制作网页ChatGPT聊天机器人","path":"//[object Object]/2023/03/10/vue制作chatgpt聊天机器人/","content":"单页面实现ChatGPT聊天机器人，给你的网站加点活力！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot; style=&quot;display: flex;flex-flow: column;margin: 20 &quot;&gt; &lt;div style=&quot;display: flex;justify-content: center;align-items: center;margin: 20&quot;&gt; &lt;textarea type=&quot;text&quot; v-model=&quot;info&quot; cols=&quot;40&quot; rows=&quot;3&quot; style=&quot;margin:15&quot;&gt;&lt;/textarea&gt; &lt;button v-on:click=&quot;ask()&quot;&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;div style=&quot;display: flex;justify-content: center;align-items: center;&quot;&gt; &lt;textarea name=&quot;res&quot; id=&quot;res&quot; cols=&quot;100&quot; rows=&quot;20&quot;&gt;&#123;&#123;res&#125;&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; const &#123;createApp&#125; = Vue createApp(&#123; data() &#123; return &#123; MAX_TOKEN: 4096, total: 0, info: &#x27;如果一个面包发臭了，应该怎么办？&#x27;, messages: [], res: &#x27;&#x27;, api: &#x27;你的OpenAI key&#x27; &#125; &#125;, methods: &#123; ask() &#123; if (!this.info) &#123; return; &#125; else &#123; this.messages.push(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: this.info&#125;) this.total++; &#125; // 限制max_token，大于5个问题时删除首元素 while (this.total.length &gt; 1) &#123; this.total = this.tota - 1; this.messages.shift() &#125; this.res = &#x27;请求中...&#x27; axios.post(&#x27;https://api.openai.com/v1/chat/completions&#x27;, &#123; messages: this.messages, max_tokens: this.MAX_TOKEN / 2, model: &quot;gpt-3.5-turbo-0301&quot; //选择最新的模型，能支持到6月1号 &#125;, &#123; headers: &#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;, &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + this.api&#125; &#125;).then(response =&gt; &#123; this.res = response.data[&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;]; this.messages.push(response.data[&#x27;choices&#x27;][0][&#x27;message&#x27;]); this.total ++; &#125;) &#125; &#125; &#125;).mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 缺点： 外网IP+国外手机号 命令限制，只能最高4096tokens 所以，我自己开发了一个聊天室，支持移动端和PC端。单独聊天或群聊都可以和ChatGPT聊天 地址：https://chat.wangwangyz.site/","tags":["Vue"],"categories":["学习笔记"]},{"title":"MySQL性能优化","path":"//[object Object]/2023/03/10/mysql性能优化/","content":"MySQL性能调优 存储数据类型优化 尽量避免使用 NULL 尽量使用可以的最小数据类型。但也要确保没有低估需要存储的范围 整型比字符串操作代价更低 使用 MySQL 内建的数据类型（比如date、time、datetime），比用字符串更快 基本数据类型 数字 整数 - TINYINT (8) - SMALLINT (16) - MEDIUMINT (24) - INT (32) - BIGINT (64) 整数类型有可选的 unsigned 属性 int(1)与int(11)，对于存储和计算来说，这两者本质是没有区别的 实数（存储小数、存储比 BIGINT 更大的数） float double float 和 double支持使用标准的浮点运算进行近似的计算。 decimal decimal 类型用于存储精确的小数，支持精确的计算。 因为在进行精确计算时需要额外的空间和计算开销，所以尽量只对小数才使用decimal。比如，财务数据。另外如果数据量大的话，可以考虑使用bigint代替decimal，只需将存储的货币单位根据小数的位数乘以相应的倍数即可。 字符串 CHAR 1、char 类型是定长的；2、适合存储很短的字符串，例如：密码的 md5 值；3、适合存储经常进行变更的值。 VARCHAR 1、字符串列的长度比平均长度大很多；2、列的更新很少，所以碎片不是问题；3、使用了像 UTF-8 这样复杂的字符集，因为该字符集中每个字符可能使用不同的字节来进行存储；4、存储可变长的字符串。 BLOB 和 TEXT 两者都是为存储很大的数据而设计的字符串数据类型，不同的是两者分别采用二进制和字符方式存储。 MySQL 在处理两个类型的值时，处理基本相同，仅有的不同是 BLOB 类型是以二进制格式来存储的，所以没有排序规则和字符集，而 text 类型有排序规则和字符集。 枚举 枚举可以把一些不重复的字符串存储成一个预定义的集合。 MySQL 会在存储枚举类型时粉肠紧凑，会根据列的值的数量压缩到一个或者两个字节中。 MySQL 会在内部将每个值在列表中的位置保存成整数，而这些『数字–字符串』的对应关系，会保存在 .frm 文件中。 所以当该列需要新添加一个新的枚举值时，必须添加在之前枚举列表的最后面，否则就会出现数据错乱的问题。切记。 日期类型 DATETIME 该类型能保存大范围的值，从 1001 年到 9999 年，精度为秒。他会把时间封装到 YYYYMMDDHHIISS 的整数中，没有时区概念。使用 8 个字节的存储空间。 TIMESTAMP 该类型保存了从 1970-01-01 00：00：00（格林威治时间）以来的秒数。该类型使用 4 个字节的存储空间，所以只能表示 1970 到 2023 年，其值还具有时区的概念。 BIT 存储更紧凑。但所有这些位类型，不管底层存储格式和存储方式，从技术上来说都是字符串类型。虽然用它存储数据更紧凑，但是对于大部分应用来说，最好避免使用该类型。 SET 特殊类型的数据 某些数据的类型并不直接和内置的类型一致。所以需要一定的转换进行存储。 低于秒级的时间戳 低于秒级的时间需要在引用层做处理，一般可以通过存储两个或者多个列来存储（一个存储秒级的时间戳，另外的存储秒级以下的） ipv4 地址 我们常见到有人会用 varchar (15) 来存错一个 IP 地址，IP 地址实际是一个 32 位的无符号整数，所以应该用无符号整数来存储 IP 地址。MySQL 提供了 INET_ATON () 和 INET_NTOA () 函数在这两表示方法之间转换。 IP地址存储通过在应用程序中进行 字符型 到 无符号整型 的转换，而不是使用MySQL的 INET_ATON() 函数，插入整数IP时MySQL的负载可能会稍微降低。 https://bafford.com/2009/03/09/mysql-performance-benefits-of-storing-integer-ip-addresses/ 三层架构说明 第一层，用于连接处理、授权认证、安全认证等等。大多数基于客户端 / 服务器端的工具或者服务器都有类似架构。 第二层，是 MySQL 架构的核心部分。MySQL 的大部分核心服务功能大都在这一层。包括查询解析、分析、优化、缓存以及所有的内置函数的实现，还有所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、试图等。 第三层，存储引擎层。存储引擎负责 MySQL 中数据的存储和读取。每个存储引擎都有自己的优势和劣势。MySQL 服务器层通过 API 与存储引擎进行通信。存储引擎本身是不会解析 SQL，且不同的存储引擎之间也是不会相互通信。 MySQL 服务器接收 / 处理一个查询请求的过程 当 MySQL 服务器接收到一个查询请求，首先会对当前的连接请求进行认证，认证其用户名和密码信息。 连接成功之后，会继续验证该连接是否具有执行某个特定查询的权限。 所有的验证都通过，如果是 select 操作，MySQL 会先检查查询缓存中是否存在该缓存，如果存在直接返回结果。不存在继续下一步。 解析查询，并创建内部数据结构（生成 解析树），然后对解析树进行各种优化（包括，重写查询，决定表的读取顺序、选择合适的索引等等）。 通过存储引擎存储或者提取结果。 如果是 select 操作，生成查询缓存。 返回结果。 根据控制的不同层次，MySQL 的并发控制可以分为： 服务器层 存储引擎层 实现并发控制的方法策略：**锁机制** 共享锁（shared lock）&lt;======&gt; 读锁（read lock） 排它锁（exclusive lock） &lt;======&gt; 写锁（write lock） 如何选择适合的锁？**锁策略** 锁的粒度越小，系统的并发性越高 所得操作越多，系统的开销越大 所以所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡。 MySQL并发控制MySQL 中锁策略类型MySQL 不同的存储引擎中用到的锁策略基本有两种。一种是表级锁，另一种是行级锁。 表锁，一种开销最小的锁策略。 一个用户对表进行写操作时，需要先获得写锁，这是其他用户读该表进行的读写操作都会进行阻塞。只有当前写操作被释放之后，其他人才能活的读锁。当当前表有读锁时，其他人也可以继续获得读锁。读锁是共享性的不同的读锁之间是互相不阻塞的。 另外，写锁的优先级高于读锁。所以当有多个锁请求存在是，读锁的请求会被优先插入到锁队列的前边。 行锁，最大程度支持并发处理，同时也是锁开销最大的锁策略。 顾名思义，行级锁只在将要修改的记录行上进行锁操作，对其他的行的操作没有影响。 尽管我们一般提到的锁，都处于存储引擎这一层，但是 MySQL 本身在某些情况下，也会对锁策略进行控制。比如表的 alter table 操作，会对表本身使用表锁，而直接忽略存储引擎的锁机制。 MySQL 中死锁问题解决方法 死锁，即两个或者多个事务在同一资源上相互占用，并请求占用对方已经占用的资源的情况。 既然有锁存在，当然就会有死锁的情况发生。那么 MySQL 中是如何处理死锁问题的呢？ 死锁的通常解决方案有两种，即： 死锁检测机制 超时机制 InnoDB 存储引擎在检测到有死锁发生的处理方法是，将当前持有最少的行级锁的事务进行回滚。待打破死锁后，重新执行因为死锁而回滚的事务。","tags":["MySQL"],"categories":["学习笔记","专业技术"]},{"title":"Nginx原理剖析（一）","path":"//[object Object]/2023/03/08/nginx原理剖析（一）/","content":"http://www.aosabook.org/en/nginx.html https://www.kancloud.cn/kancloud/master-nginx-develop/51798 Nginx概述Nginx 是一个 模块化、事件驱动、异步、单线程和非阻塞 的 Web服务器，大量使用 多路复用 和 事件通知 ，并将特定任务用于单独进程。Nginx worker 可以处理数千个并发连接和请求。 Nginx代码结构12345678910111213141516171819.├── auto #自动检测系统环境以及编译相关的脚本│ ├── cc #关于编译器相关的编译选项的检测脚本│ ├── lib #nginx编译所需要的一些库的检测脚本│ ├── os #与平台相关的一些系统参数与系统调用相关的检测│ └── types #与数据类型相关的一些辅助脚本├── conf #存放默认配置文件，在make install后，会拷贝到安装目录中去├── contrib #存放一些实用工具，如geo配置生成工具（geo2nginx.pl）├── html #存放默认的网页文件，在make install后，会拷贝到安装目录中去├── man #nginx的man手册└── src #存放nginx的源代码 ├── core #nginx的核心源代码，包括常用数据结构的定义，以及nginx初始化运行的核心代码如main函数 ├── event #对系统事件处理机制的封装，以及定时器的实现相关代码 │ └── modules #不同事件处理方式的模块化，如select、poll、epoll、kqueue等 ├── http #nginx作为http服务器相关的代码 │ └── modules #包含http的各种功能模块 ├── mail #nginx作为邮件代理服务器相关的代码 ├── misc #一些辅助代码，测试c++头的兼容性，以及对google_perftools的支持 └── os #主要是对各种不同体系统结构所提供的系统函数的封装，对外提供统一的系统调用接口 Worker模型Nginx 不会为每个连接创建一个进程或线程 Nginx 所做的是检查网络和存储的状态，初始化新连接，将它们添加到运行循环，并异步处理直到完成，此时连接被释放并从运行循环中删除。 Nginx通过kqueue、epoll和事件端口等获得有关入站和出站流量、磁盘操作、Socket读取或写入、超时等的异步反馈 nginx 生成多个worker 来处理连接，所以它可以很好地跨多个内核进行扩展？ worker对于某些磁盘使用和 CPU 负载模式，应调整Nginx 的数量 ：如果负载模式是 CPU 密集型的——例如，处理大量 TCP/IP、执行 SSL 或压缩——Nginx 的数量应与 CPU 内核的数量相匹配worker；如果负载主要受磁盘 I/O 限制——例如，从存储中提供不同的内容集，或大量代理 ，worker的数量可能是CPU核心数量的一倍半到两倍。 Nginx 1.9.11开始增加加载动态模块支持，从此不再需要替换nginx文件即可增加第三方扩展 Nginx 进程角色Nginx 在内存中运行多个进程；有一个主进程和多个worker进程。在 nginx 1.x 版本中，所有进程都是单线程的。所有进程主要使用 共享内存 进行进程间通信。 主进程负责以下任务： 读取和验证配置 创建、绑定和关闭Socket worker启动、终止和维护配置的进程数 在不中断服务的情况下重新配置 控制不间断的二进制升级（启动新的二进制文件并在必要时回滚） 重新打开日志文件 编译嵌入式 Perl 脚本 这些worker进程接受、处理和处理来自客户端的连接，提供反向代理和过滤功能，并完成 nginx 能够完成的几乎所有其他工作。 *+ 缓存加载程序进程负责检查磁盘缓存项并使用缓存元数据填充 nginx 的内存数据库。本质上，缓存加载器准备 nginx 实例来处理已经存储在磁盘上专门分配的目录结构中的文件。它遍历目录，检查缓存内容元数据，更新共享内存中的相关条目，然后在一切干净并准备好使用时退出。 *+ 缓存管理器主要负责缓存过期和失效。它在 nginx 正常运行期间保留在内存中，并在出现故障时由主进程重新启动。 Nginx配置nginx 配置保存在许多纯文本文件中，这些文件通常位于/usr/local/etc/nginxor 中/etc/nginx。主配置文件通常称为 nginx.conf 配置文件最初由主进程读取和验证。nginx 配置的编译只读形式可供进程使用，worker因为它们是从主进程派生出来的。配置结构由通常的虚拟内存管理机制自动共享。 nginx 配置有几个不同的上下文如：main, http, server, upstream, location（以及 mail邮件代理）用于指令块。上下文永远不会重叠。 Nginx内幕大多数特定于协议和应用程序的功能都是由 nginx 模块完成的，而不是核心。 在内部，nginx通过模块的管道或链处理连接。换句话说，每个操作都有一个模块在做相关的工作；例如，压缩、修改内容、执行服务器端包括、通过FastCGI或uwsgi协议与上游应用服务器通信或与memcached通信。","tags":["Linux","Nginx"],"categories":["学习笔记","专业技术"]},{"title":"LiteChat 即时通讯","path":"//[object Object]/2023/02/26/litechat聊天室/","content":"即时通讯体验地址：https://chat.wangwangyz.site Github地址：https://github.com/InvalidSyntaxxx/LiteChat-Client 欢迎来唠嗑~ 项目概况移动端 Web端 项目功能 移动端兼容 用户信息的修改(头像/用户名/密码) 群聊/私聊 创建群/加入群/退群/模糊搜索群 添加好友/删好友/模糊搜索用户 消息分页 好友/群新消息提醒 表情包 图片发送/图片预览 在线人数统计 自定义主题 重连提醒 ChatGPT群聊/单人聊天 游客体验 书籍下载 游戏体验 技术概览 Typescript：JavaScript 的一个超集，它最大的优势是提供了类型系统和提高了代码的可读性和可维护性。 Vue2.6.x：前端渐进式框架。 Socket/io：实现实时通信，websocket第三方库。 Vuex：专为 Vue.js 应用程序开发的状态管理模式。 Nestjs：是一个用于构建高效、可扩展的 Node.js 服务端应用框架，基于 TypeScript 编写并且结合了 OOP1、FP2、FRP3 的相关理念。 Typeorm: 支持最新的 JavaScript 特性并提供额外的特性以帮助你开发任何使用数据库的应用程序。 **ES6+**：采用ES6+语法，箭头函数、async/await等等语法很好用。 **SASS(SCSS)**：用SCSS做CSS预处理语言，可以使用最高效的方式，以少量的代码创建复杂的设计。","tags":["MySQL","NestJS","Nginx","TypeScript","Vue"],"categories":["学习笔记","文章","专业技术"]},{"title":"小网页开发","path":"//[object Object]/2022/11/12/摄影展-小网页开发/","content":"开发了一个小网页，用于展示Bing每日一图，大伙过来瞧瞧嘿嘿(〃∀〃)，有什么不足之处欢迎留言指正吖(◡‿◡) 源码：https://github.com/InvalidSyntaxxx/CodeCollection/tree/main/%E5%89%8D%E7%AB%AF/Web%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B/mid-term 各位喜欢的话可以自取，不过是原生HTML+比较久远的技术… 效果图 食用方式 PC 首先要确认是掉发收集站哦！，然后鼠标移到说说/随想录一栏，再点击摄影展(瞎起的名哈哈哈)，就可以啦！ 移动端 和PC一样，不过需要点击右上角的搜索图标，然后点击说说/随想录就看到摄影展啦！结语 想不到说什么哈哈，因为目前还在开发中…，并不是最终效果 ———— 2022年11月12日15点50分","tags":["html","Javascript","分享","Python"],"categories":["学习笔记"]},{"title":"Less初学","path":"//[object Object]/2022/11/06/less初学/","content":"变量1234567@width: 10px;@height:@width + 10px;#header&#123; width: @width; height: @height&#125; 混合123456789101112.bordered&#123; border-top: dotted 1px black; border-bottom:solid 2px black;&#125;#menu a &#123; color: #111; .bordered();&#125;.post a &#123; color: red; .bordered();&#125; 嵌套123456789#header&#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &#125;&#125; 等价于 123456789#header &#123; color: black;&#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px;&#125; @规则 嵌套和冒泡123456789101112.component &#123; width: 300px; @media (min-width: 768px) &#123; width: 600px; @media (min-resolution: 192dpi) &#123; background-image: url(/img/11.png); &#125; &#125; @media (min-width: 1280px) &#123; width: 800px; &#125;&#125; 等价于 123456789101112131415161718.component &#123; width: 300px;&#125;@media (min-width: 768px) &#123; .component &#123; width: 600px; &#125;&#125;@media (min-width: 768px) and (min-resolution: 192dpi) &#123; .component &#123; background-image: url(/img/retina2x.png); &#125;&#125;@media (min-width: 1280px) &#123; .component &#123; width: 800px; &#125;&#125; 运算*转义任何 ~&quot;anything&quot; 或 ~&#39;anything&#39; 形式的内容都将按原样输出，除非 interpolation。 123456@min768: ~&quot;(min-width: 768px)&quot;;.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; 编译为： 12345@media (min-width: 768px) &#123; .element &#123; font-size: 1.2rem; &#125;&#125; 注意，从 Less 3.5 开始，可以简写为： 123456@min768: (min-width: 768px);.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; 函数Less 函数手册 命名空间和访问符12345678910111213141516#bundle()&#123; .button&#123; display: block; border: 1px solid black; &amp;:hover &#123; background-color: white; &#125; &#125; .tab &#123;...&#125; .citation &#123;...&#125;&#125;#header a &#123; color: orange; #bundle.button(); // 或者 #bundle &gt; .button&#125; 如果不希望它们出现在输出的 CSS 中，例如 #bundle .tab，请将 () 附加到命名空间（例如 #bundle()）后面 作用域123456789101112131415161718@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125;/** 两者一样*/@var: red;#page &#123; #header &#123; color: @var; // white &#125; @var: white;&#125; 导入12@import &quot;library&quot;; // library.less@import &quot;typo.css&quot;;","categories":["文章"]},{"title":"遗传算法","path":"//[object Object]/2022/10/03/遗传算法/","content":"数学公式完整版：https://blog.csdn.net/weixin_51245887/article/details/126918727 遗传算法概述背景知识生物遗传概念 遗传算法中的作用 适应度（Fitness） 适应函数值。度量某个物种对于生存环境的适应程度 选择（Selection） 决定以一定的概率从种群中选择若干个个体的操作 交叉（Crossover） 通过交配原则产生一组新解的过程 变异（Mutation） 编码的某一个分量发生变化的过程 编码（Coding） 表现型到基因型的映射 解码（Decoding） 基因型到表现型的映射 群体（population） 选定的一组解 种群（reproduction） 根据适应函数值选取的一组解 适者生存 算法停止时，最优目标值的解有最大的可能被保留 个体 解 染色体（chromosome） 解的编码（字符串、向量等） 基因（gene） 解中每一分量的特征（如各分量的值） 遗传算法（GA）概要 枚举法 启发式算法 搜索算法 原理 是模拟生物在自然环境下的进化和遗传过程而形成的一种 自适应全局优化概率方法 其采纳了 自然进化模型，从代表问题可能潜在解集的一个 种群 开始 适者生存、优胜劣汰 算法过程 初始化。设置进化代数计数器t⭠0；设置最大进化代数T；随机生成M个个体作为初始群体P(0)。 个体评价。计算群体P(t)中各个个体的适应度。 选择运算。将选择算子作用于群体。 交叉运算。将交叉算子作用于群体。 变异运算。将变异算子作用于群体。群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。 终止条件判断。若t≤T，则：t⭠t+1，转到步骤二；若t&gt;T，则以进化过程中所得到的具有最大适应度的个体作为最优解输出，终止计算。 示意图 特点 遗传算法以 决策变量的编码 作为运算对象 遗传算法直接以 目标函数值 作为搜索信息 遗传算法同时使用 多个搜索点 的搜索信息 遗传算法使用 概率搜索技术 基本遗传算法由 Holland 提出，简称 SGA（Simple Genetic Algorithm）。 构成要素 染色体编码方法 使用 固定长度的二进制符号串 来表示群体中的个体 个体适应度评价 基本遗传算子 算法的运行参数 伪代码描述123456789101112131415161718Procedure SGAbegin// 初始值，M为个体总数，t为代数，T为最大进化数 M=PopulationSize, t=0, T=maxGeneration;init P(t); // 初始化群体P，一开始为第0代while(t&lt;=T): for i=1 to M do: Evaluate Fitness of P(t); for i=1 to M do: Selection Operation to P(t); for i=1 to M/2 do: Crossover Operation to P(t); for i=1 to M do: Mutation operation to P(t); for i=1 to M do: P(t+1)=P(t) t=t+1end 算法图解参考上图 个体适应度评价 所有个体适应度必须为正数或零，不能为负数。 适应度函数变换常用方法但实际优化问题中的目标函数值有正也有负，优化目标有求函数最大 值，也有求函数最小值，显然上面两式保证不了所有情况下个体的适应度 都是非负数这个要求，需要进行适应度函数尺度转换，将 目标函数值 f(x) 变换为个体的适应度F(x) 。 比例选择又称为轮盘赌选择（Roulette Wheel ） 遗传算法的应用步骤 确定决策变量及其各种约束条件，即确定出个体的表现型 X 和问题的解空间。 建立优化模型，即确定出目标函数的类型及其数学描述形式或量化方法。 确定表示可行解的染色体编码方法，也即确定个体的基因型 X 及遗传算法的搜索空间。 确定解码方法，即确定出由个体基因型 X 到个体表现型 X 的对应关系或转换方法。 确定个体适应度的量化评价方法，即确定由目标函数值 $f(x)$ 到个体适应度 $F(x)$ 的转换规则。 设计遗传算子，即确定选择运算、交叉运算和变异运算等遗传算子的操作方法。 确定遗传算法的有关运行参数，即确定出遗传算法的 $M,T,p_{c},p_{m}$ 等参数。 模式定理模式 模式（schema）表示一些相似的模块。他描述了在某些位置上的具有相似结构特征的个体编码串的一个子集。 例如：模式 $H = 1**11$，模式 $H = 00**$ ，“$$”代表通配符。 模式阶 在模式H中具有确定基因值的位置数目称该模式的模式阶（schema order），记为 $ o(H)$。 例如：$o(100_01_)=5，o(*******0)=1$ 模式定义长度 模式 H 中第一个确定基因值的位置和最后一个确定基因值的位置之间的距离称为该模式的模式定义长度（Schema Defining Length），记为 $δ(H)$。 例如：$δ(11*0**_) = 3，δ(0_**1) = 4，δ(**0***) = 1$ 在选择算子的作用下$$ \\frac{m(H,t)}{m(H,t+1)}=\\frac{\\bar{F}(t)}{f(H,t)}\\ \\Longleftrightarrow m(H,t+1)=m(H,t)\\frac{f(H,t)}{ \\bar{F}(t)}\\ let \\quad \\frac{f(H,t)}{\\bar{F}(t)}=1+C \\ \\Longrightarrow m(H,t+1)=m(H,t)(1+C)\\ \\Longrightarrow m(H,t)=m(H,O)·(1+C)^{t} $$ 其中 符号 含义 $t$ 在进化过程中的第 $t$ 代 $H$ 模式 $H$ $m(H, t)$ 当前群体 $P(t)$ 中与 $H$ 匹配的个体数 $\\bar F(t)$ 第 t 代群体的平均适应度 $f(H,t)$ 群体中 H 隐含的总个体的平均适应度 结论：在选择算子作用下，对于平均适应度高于群体平均适应度的模式，其样本数将呈指数级增长：而对于平均适应度低于群体平均适应度的模式，其样本数将呈指数级减少。 在交叉算子的作用下$$ m(H,t+1)≥m(H,t)·(1+C)·[1-p_{c}·\\frac{δ(H)}{l-1}] $$ $δ(H)$越小，则$m(H,t)$越容易呈指数级增长； $δ(H)$越大，则$m(H,t)$越不容易呈指数级增长。 在变异算子的作用下某一模式被破坏的概率： $$ 1-(1-p_{m})^{o(H)} $$ 当 $p_{m}&lt;&lt;1$ 时： $$ 1-(1-p_{m})^{o(H)}≈o(H)·p_{m} $$ 在变异算子的作用下，模式 H 的生存概率： $$ p_{s}≈1-o(H)·p_{m} $$ $o(H)$越小，模式 H 越易于生存； $o(H)$越大，模式 H 越易于被破坏。 在算子总作用下$$ m(H,t+1)≥m(H,t)·\\frac{f(H,t)}{\\bar F(t)}·[1-p_{c}·\\frac{δ(H)}{l-1}-o(H)·p_{m}] $$ ⭐总结：遗传算法中，在选择、交叉和变异算子的作用下，具有低阶、短的定义长度，并且平均适应度高于群体平均适应度的模式将按指数级增长。 【积木块假设】 个体的基因块通过选择、交叉、变异等遗传算子的作用，能够相互拼接在一起，形成适应度更高的个体编码串。 遗传算法基本实现技术编码编码方法很大程度上决定了如何进行群体的遗传进化运算以及遗传进化运算的效率。 常见的编码分类：二进制编码、浮点编码、符号编码。 二进制编码编码 假设某一参数的取值范围 [$U_{min},U_{max}$ ] , 我们用长度为 n 的二进制编码符号串来表示参数，共产生 $2^{n}$ 种不同的编码，δ为二进制编码的编码精度。则： $$ δ = \\frac{U_{max}-U_{min}}{2^{n}-1} $$ 解码 假设某一个体的编码是： $$ X:b_{i}b_{i-1}b_{i-2}····b_{2}b_{1} $$ 则解码公式为： $$ x = U_{min}+(\\sum_{i=1}^{n}b·2^{i-1})· \\frac{U_{max}-U_{min}}{2^{n}-1} $$ [例] 设 -3.0 ≤ x ≤ 12.1 , 精度要求 δ = 1/10000 由编码公式 格雷码编码 格雷码特点：两个相邻的编码串之间只有一位编码值不同。 解码和编码过程：决策变量 ↔二进制↔格雷码 浮点数编码个体的每个基因值用_某一范围内_的一个浮点数来表示，个体的编码长度等于其决策变量的个数。 编码方法 某一个优化问题含有5个变量 $x_{i}(i=1,2, … ,5)$，每个变量都有其对应的上下限$[U_{min}^{i}, U_{max}^{i}]$，则： 就表示一个个体的基因型，其对应的表现型是： $x = [5.80,6.90,3.50,3.80,5.00]^{T}$ 符号编码个体染色体编码串中基因值取自一个无数值含义、只有代码含义的符号集。 多参数级联编码将各个参数分别以某种编码方法进行编码，然后再将它们的编码按一 定顺序联接在一起就组成了表示全部参数的个体编码。这种编码方法 称为多参数级联编码方法。 $$ \\underbrace{b_{11}b_{12}···b_{1l_{1}}}{x{1}}\\underbrace{b_{21}b_{22}···b_{2l_{2 }}}{x{2}}····\\underbrace{b_{n1}b_{n2}···b_{nl_{1}}}{x{n}} $$ 多参数交叉编码方法将各个参数中起主要作用的码位集中在一起。 编码方法 先对各个参数进行分组编码 取各个参数编码串中的最高位联接在一起作为前n位编码；再取次高位同上…… 参数编码： $$ \\overbrace{b_{11}b_{12}b_{13}···b_{1m}}^{x_{1}}\\overbrace{b_{21}b_{22}b_{23}···b_{2m}}^{x_{2}}····\\overbrace{b_{n1}b_{n2}b_{n3}···b_{nm}}^{x_{n}} $$ 个体编码串： $$ b_{11}b_{21}b_{31}···b_{n1} b_{12}b_{22}b_{32}···b_{n2} ··· b_{1m}b_{2m}b_{3m}···b_{nm} $$ 适应度函数度量个体适应度的函数称为适应度函数。 目标函数是指所关心的目标 (某一变量y) 与相关的因素 ( 某些变量$x_{i}$ ) 的函数关系。 适应度尺度变换对个体适应度所做的扩大或者缩小变换 常见变换方法： 线性尺度变换 $F^{‘}=aF+b$ 乘幂尺度变换 $F^{‘}=F^{k}$ 指数尺度变换 $F^{‘}=exp(-βF)$ （$F$：原适应度，$F’$：尺度变换后的新适应度） 选择算子遗传算法使用选择算子（或称复制算子， Reproduction Operator）来对群体中的个体进行优胜劣汰操作；适应度 较高的个体被遗传到下一代群体中的概率较大；适应度较 低的个体被遗传到下一代群体中的概率较小. 比例选择各个个体被选中的概率与其适应度大小成正比。设群体大小为M，个体 i 的适应度为$F_{i}$，则个体i被选中的概率$p_{is}$为: $$ p_{is}=F_{i}/\\sum_{i=1}^{M}F_{i} \\quad\\quad (i=1,2,3,…,M) $$ 最优保存策略 找出当前群体中适应度最高的个体和适应度最低的个体。 若当前群体中最佳个体的适应度比总的迄今为止的最好个体的适应度还要高，则以当前种群中的最佳个体作为新的迄今为止的最好个体。 用迄今为止的最好个体替换掉当前群体中的最差个体 确定式采样选择 计算群体中各个个体在下一代群体中的期望生存数目$N_{i}$: $$ N_{i} = M · F_{i}/\\sum^{M}_{i=1}F_{i}\\quad\\quad (i=1,2,3,…,M) $$ 用$N_{i}$的整数部分确定各个对应个体在下一代群体中的生存数目。 按照$N_{i}$的小数部分对个体进行降序排序，顺序取前 $M-\\sum ^{M}_{i=1}[N_{i}]$ 个个体加入到下一代群体中。 无回放随机选择亦称期望值选择方法(Expected Value Model)。 计算群体中各个个体在下一代群体中的期望生存数目$N_{i}$: $$ N_{i} = M · F_{i}/\\sum^{M}_{i=1}F_{i}\\quad\\quad (i=1,2,3,…,M) $$ 若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去0.5，若未参与交叉运算，则它在下一代中的生存期望数目减去1.0。 随着选择过程的进行，若某一个个体的生存期望数目小于0时，则该个体就不在有机会被选中。 无回放余数随机选择 计算群体中各个个体在下一代群体中的期望生存数目$N_{i}$: $$ N_{i} = M · F_{i}/\\sum^{M}_{i=1}F_{i}\\quad\\quad (i=1,2,3,…,M) $$ 用$N_{i}$的整数部分$N_{i}$确定各个对应个体在下一代群体中的生存数目。 以$F_{i}-N_{i}·\\sum^{M}{i=1}F/M$ 为各个个体的新的适应度，用比例选择方法来确定下一代群体中还未确定的 $M-\\sum ^{M}{i=1}N_{i}$ 个体。 排序选择对群体中各个个体按其适应度大小来进行排序，基于这个排序来分配各个个体被选中的概率。 对群体中的所有个体按其适应度大小进行降序排序。 根据具体求解问题，设计一个概率分配表，将各个概率值按上述排列次序分配给各个个体。 以各个个体所分配到的概率值作为其能够被遗传到下一代的概率，基于这些概率值用比例选择的方法来产生下一代群体。 随机联赛选择每次选取几个个体之中适应值最高的一个个体遗传到下一代群体。 从群体中随机选取N个个体进行适应度大小的比较，将其中适应度最高的个体遗传到下一代群体中。 将上述过程重复M次，就可得到下一代群体中的M个个体。 交叉算子交叉算子是指对两个相互配对的染色体按某种方式相互交换其部分基因，从而形成两个新的个体 单点交叉在个体编码串中只随机设置一个交叉点，然后在该点相互交换两个配对的部分染色体。 特点：若邻接基因座之间的关系能提供较好的个体性状和较高的个体适应度的话，则这种单点交叉操作破坏这种个体性状和降低个体适应度的可能性最小。 双点交叉在个体编码串中随机设置两个交叉点，然后再进行部分基因交换。 在相互配对的两个个体编码串中随机设置两个交叉点 交换两个个体在所设定的两个交叉点之间的部分染色体 多点交叉在个体编码串中 随机设置两个交叉点，然后进行基因交换。 均匀交叉两个配对个体的每一个基因座上的基因都以相同的交叉概率进行交换。 随机产生一个与个体编码串长度等长的屏蔽字 $W=w_{1}w_{2}…w_{i}…w_{l}$，其中 $l$ 为个体编码串长度。 由下述规则从 A 和 B 两个父代个体中产生出两个新的子代个体 A’ 和 B’。 若 $w_{i}=0$，则 A’ 在第 i 个基因座上的基因值继承 A 的对应基因值，B’ 在第 i 个基因座上的基因值继承 B 的对应基因值。 若 $w_{i} =1$，则 A’ 在第 i 个基因座上的基因值继承 B 的对应基因值，B’ 在第 i 个基因座上的基因值继承 A 的对应基因值。 算术交叉由两个个体的线性组合而产生出两个新的个体。 假设有两个个体$X_{A}$和$X_{B}$之间进行算术交叉，则交叉运算后所产生的两个新个体是: $$ \\left{\\begin{matrix} X_{A}^{t+1} = \\alpha X_{B}^{t} + (1 - \\alpha )X_{A}^{t} \\ X_{B}^{t+1} = \\alpha X_{A}^{t} + (1 - \\alpha )X_{B}^{t} \\end{matrix}\\right. $$ 其中 α 是一参数，如果 α (0&lt; α &lt;1)是一个常数，则为 均匀算术交叉；如果 α 是一个由进化代数所决定的变量，则称为非均匀算术交叉。 确定两个个体进行线性组合的系数 α。 依据上式生成新的两个个体。 变异算子变异算子是指将个体染色体编码串中的某些基因座上的基因值用该基因座的其它等位基因来替换，从而形成一个新的个体。 基本位变异个体编码串中以变异概率 $P_{c}$ 随机指定的某一位或某几位基因座上的基因值作变异运算。 均匀变异分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。 假设有一个个体为$X = x_{1}x_{2}…x_{k}…x_{l}$，若$x_{k}$为变异点，其取值范围为$[U^{k}{min}, U^{k}{max}]$，在该点对个体 X 进行均匀变异操作后，可得到一个新的个体 $X’= x_{1}x_{2}…x’_{k}…x_{l}$，其变异的新基因值是： $$ x’{k} = U^{k}{min}+r·(U_{max}^{k}-U_{min}^{k}) $$ 其中，r 为 [0,1] 范围内符合均匀分布的一个随机数。 依次指定个体编码串中的没个基因座为变异点。 对每一个变异点，以变异概率 $P_{m}$ 从对应基因的取值范围内取一随机数来替代原有基因值。 边界变异随机地取基因座的两个对应边界基因值之一去替代原有基因值。(是均匀变异操作的一个变形) 在进由$X = x_{1}x_{2}…x_{k}…x_{l}$向$X’= x_{1}x_{2}…x’_{k}…x_{l}$的边界变异操作时，若变异点xk的基因取值范围为$[U^{k}{min}, U^k{max}]$，则新的$x’_{k}$由下式确定： $$ x’{k}=\\left{\\begin{matrix} U^{k}{min} \\quad ,\\quad if \\quad random(0,1) =0 \\ U^{k}_{max} \\quad ,\\quad if \\quad random(0,1) =1 \\end{matrix}\\right. $$ 式中，random(0，1) 表示以均等的概率从0、1中任取其一。 非均匀变异不是取均匀分布的随机数去替换原有的基因值，而是对原有基因作一随机扰动，以扰动后的结果作为变异后的新基因值。 在进由$X = x_{1}x_{2}…x_{k}…x_{l}$向$X’= x_{1}x_{2}…x’_{k}…x_{l}$的边界变异操作时，若变异点xk的基因取值范围为$[U^{k}{min}, U^k{max}]$，则新的$x’_{k}$由下式确定： $$ x’{k}=\\left{\\begin{matrix} x{k}+ \\Delta (t,U^{k}{max}-x{k}) \\quad ,\\quad if \\quad random(0,1) =0 \\ x_{k}- \\Delta (t,x_{k}-U^{k}_{min}) \\quad ,\\quad if \\quad random(0,1) =1 \\end{matrix}\\right. $$ △(t, y)表示 [0,y] 范围内符合非均匀分布的一个随机数，要求随着进化代数t的增加，△(t, y)接近于0的概率也逐渐增加。 例如，△(t, y)可按下式定义： $$ \\Delta (t, y) = y·(1-r^{(1-t/T)b}) $$ 其中，r为 [0,1] 范围内符合均匀分布的一个随机数，T是最大进化代数，b是一个系统参数。它决定了随机扰动对进化代数t的依赖程度。 高斯变异进行变异操作时，用符合均值为μ、方差为$σ^{2}$的正态分布的一个随机数来替换原有基因值。 假定有12个在[0,1]范围内均匀分布的随机数$r_{i}(i=1,2,..,12)$，则符合$N(μ,σ^{2})$正态分布的一个随机数Q可由下式求得: $$ Q=μ+σ(\\sum_{i=1}^{12}r_{i}-6) $$ 遗传算法高级实现技术倒位算子倒位算子是颠倒个体编码中随机指定的两个基因座之间的基因排列顺序，从而形成一个新的染色体。 过程： 在个体编码串中随机指定两个基因座之后的位置为倒位点。 以倒位概率 $P_{i}$ 颠倒这两个倒位点之间的基因排列顺序。 二倍体 生物学中，二倍体是指含有两个同源基因组的个体。 重要特性 二倍体的记忆能力 能够记忆以前经历过的环境及变化。 显性操作的鲁棒性 在显性操作的作用下，能够用其另一同源染色体对其进行校正。 双基因座显性映射由 Hollstien 提出，每个二进制基因用两个基因来描述，一个称为 函数基因，取通常含义的 1 或 0；另一个称为 修饰基因，取值为 M（显性） 或 m（隐形）。当两个同源染色体中至少有一个修饰基因是M时，呈显性，否则为隐性。 之后 Hollstien 简化为 单基因座显性映射 ，描述基 因的字符集为${0, 1, 1_{0}}$，其中 $1_{0}$ 为隐性的 1，1 为显性的 1。 与GA不同 显性形状也能进化，同源染色体之间需进行交叉操作 变异操作需考虑隐性性状 对个体进行交叉、变异运算后，需进行显性操作 DiploidyGA算法 初始化，并设置进化代数计数器初值：t=1 。 随机产生具有二倍体结构的初始群体 P(0)。 对初始群体 P(0) 进行显性操作。 评价初始群体P(0)中各个个体的适应度。 交叉操作：$P’(t)⬅Crossover[p(t)]$。由每两个随机配对的二倍体个体进行交叉操作时，共可产生四个单倍体个体。 变异操作：$P’’(t)⬅Mutation[p’(t)]$ 。在对群体中各个个体进行变异操作时，需要考虑隐性基因的作用。 对群体$P’’(t)$进行显性操作。 评价群体$P’’(t)$中各个个体的适应度。 个体选择、复制操作。 终止条件判断。若不满足终止条件，则：ｔ⬅ｔ＋１，转到第３步，继续进行进化操作过程；若满足终止条件，则输出当前最优个体，结束。 变长度染色体遗传算法 编码 $$ X^{m}:(i_{1},v_{i})(i_{2},v_{2})···(i_{k},v_{k})···(i_{n},v_{n}) $$ $i_{k}$是所描述的基因在原常规染色体中的 基因座编号，$v_{k}$为对应的基因值。 例： 解码 这能有什么用？？？？这么能扯 算法步骤(MessyGA) 初始化。随机产生M个染色体，长度全部为 k的个体，以它们作为变长度遗传算法的初始个体集合P(0)，其中k为根据问题的不同而设定的一个参数，并且 $k ≤ l $。 适应度评价。 基本处理阶段。对群体P(t)施加选择算子，以保留适应度较高的个体。 并列处理阶段。对群体P(t)世家变异算子、切断算子和拼接算子，以生成新的个体。 重复2-4步，直到满足终止条件为止。 切断算子 切断算子以某一预先指定的概率，在变长度染色 体中随机选择一个基因座，在该处将个体的基因型 切断，使之成为二个个体的基因型 。 拼接算子 拼接算子以某一预先指定的概率，将二个个体的 基因型连接在一起，使它们合并为一个个体的基因型。 遗传算法的运行参数 编码串的长度 l 群体大小M（一般建议取值20~100） 交叉概率$P_{c}$（一般建议取值0.4~0.99） 变异概率$P_{m}$（一般建议取值0.0001~0.1） 终止代数T（一般建议取值100~1000） 规定最大迭代次数T 规定最小的偏差 观察适应度的变化趋势 代沟G 表示每一代群体中被替换掉的个体在全部个体中所占的百分比。 G=1.0表示群体中的全部个体都是新产生的。 约束条件的处理方法搜索空间限定法对遗传算法的搜索空间的大小加以限制，使得搜索空间中表示一个个体的点与解空间中表示一个可行解的点有一一对应关系。 实现方法：1、用编码方法来保证总是能够产生出在解空间中有对应可行解的染色体。 2、用程序来保证直到产生出在解空间中有对应可行解的染色体之前，一直进行交叉运算和变异运算。 可行解变换法寻找出一种个体基因型个个体表现型之间的多对一的变换关系，使进化过程中所产生的个体总能够通过这个变化而转化成解空间中满足约束条件的一个可行解。 罚函数法对在解空间中无对应的可行解的个体，计算其适应度时，处以一个罚函数，从而降低个体适应度，使该个体被遗传到下一代群体中的机会减少。 下式对个体适应度进行调整： $$ F’(X)=\\left{\\begin{matrix} F(X) \\quad \\quad \\qquad X 满足约束条件\\ F(X)-P(X) \\quad X不满足约束条件 \\end{matrix}\\right. $$ F(X)为原适应度，F’(X)为新适应度，P(X)为罚函数。 小生境遗传算法在生物学上，**小生境(Niche)**是指特定环境下的一种生存环境。 生物在 其进化过程中，一般总是与自己相同的物种生活在一起，共同繁衍后 代；它们也都是在某一特定的地理区域中生存。 实现方法 基于预选择的小生境———（Cavicchio，1970） 基于排挤的小生境————（De Jong，1975） 基于共享函数的小生境——（Goldberg和Richardson，1987） 基于预选择的小生境算法仅当新产生的子代个体的适应度 超过其父代个体的适应度 时，所产生出的子代个体才能替换其父代个体而遗传到下 一代群体中，否则父代个体仍保留在下一代群体中。 基于排挤的小生境算法算法步骤： 初始化。建立初始群体，确定遗传参数，设定排挤银子CF。 计算个体适应度。 遗传操作（选择、交叉和变异） 从当前群体中随机选取群体规模的1/CF个个体组成排挤因子成员。 比较新产生的个体与排挤因子成员中最相似的个体，形成新的当前群体。 重复2-6步，直到满足终止条件。 特点：随着排挤过程的进行，群体中的个体逐渐被分类，从而形成各个小的生存环 境，并维持了群体的多样性。 基于共享函数的小生境算法 共享函数(sharing function)：用来确定每个个体在群体中的 共享度。一个个体的共享度等于该个体与群体内的 各个其它个体之间的共享函数值的总和。 设 $d_{ij}$ 表示个体 i 和个体 j 之间的关系密切程度，S为共享函数，$S_{i}$ 表示个体 i 在群体中的共享度: $$ S_{i}=\\sum_{j=1}^{n}S(d_{ij}) $$ 个体适应度$f(i)$: $$ f_{s}(i)=f(i)/S_{i} $$ 通过反映个体之间相似程度的 共享函数 来调整群体中各个个体的适应度，从而在这以后的群体进化过程中，算法能够依据这个调整后的新适应度来进行选择运算，以维护群体的多样性，创造出小生境的进化环境。 应用多峰值函数全局最优化在多峰值函数全局最优化中的应用：（没啥用。。。） 首先两两比较群体中各个个体之间的距离，若这个距离在 预先指定的距离L之内的话，再比较两者之间的适应度大 小，并对其中适应度较低的个体施加一个较强的罚函数， 极大地降低其适应度，这样，对于在预先指定的某一距离 L之内的两个个体，其中较差的个体经处理后其适应度变 得更差，它在后面的进化过程中被淘汰掉的概率就极大。 也就是说，在距离L之内将只存在一个优良的个体，从而 既维护了群体的多样性，又使得各个个体之间保持一定的 距离，并使得个体能够在整个约束空间中分散开来，这样就实现了一种小生境遗传算法。 算法过程 设置进化代数计数器t⬅1；随机生成M个初始个体组成初始群体P(t)，并求出各个个体的适应度$F_{i}\\quad(i=1,2,···,M)$。 依据各个个体的适应度对其进行降序排序，记忆前N个个体(N&lt;M)。 遗传运算（选择算子、交叉算子和变异算子） 小生境淘汰。将变异算子得到的 M 个个体和②中所记忆的N个个体合并在一起，得到一个含有M+N个个体的新群体；对这M+N个个体，求出每两个个体$X_{i}$和$X_{j}$之间的海明距离。当 $X_{i}-X_{j}&lt;L$ 时，比较个体$X_{i}和X_{j}$的适应度大小，并对其中适应度较低的个体处以罚函数： $$ F_{min}(x_{i},x_{j})=Penalty $$ 依据这M+N个个体的新适应度对各个个体进行降序排序，记忆前N个个体。 结束判定 混合遗传算法特点 引入了局部搜索过程 增加了编码变换操作过程 基本原则 尽量采用原有算法的编码 利用原有算法的优点 改进遗传算子 *模拟退火算法基于金属退火的机理而建立起的一种全局最优化方法，它能够以随机搜索技术从概率的意义上找出目标函数的全局最小点。 构成要素 搜索空间 能量函数E(x) 状态转移规则P 冷却进度表T(t) 算法过程 随机产生一个初始解，以它作为当前最优解，并计算目标函数值。 设置初始温度：$T=T_{0}$。 设置循环计数器初值：t=1。 对当前最优解作一随机变动,产生一新的解。计算新的目标函数值，并计算 目标函数值的增量D。 如果D＜0，则接受该新产生的解为当前最优解； 如果D＞0，则以概率p = exp(-D/T)接受该新产生的解为当前最优解。 如果t＜终止步数，则：t=t+1，转向第4步。 如果未到达冷却状态，则：T=T(t)，转向第3步； 如果已到达冷却状态，则：输出当前最优点，计算结束。 略。。。 数值函数和多目标优化数值函数优化纯数值函数优化专门设计了一些具有复杂数学特征的纯数学函数，通过遗传算法对这些函数的优化计算情况来测试各种遗传算法的性能。 常用测试函数 连续函数或离散函数 凹函数或凸函数 二次函数或非二次函数 低维函数或高维函数 确定性函数或随机性函数 单峰值函数或多峰值函数 多目标优化*GA的性能评估 适应值函数计算次数 发现同样适应性的个体，或者找到同样质 量的可行解，所需要的关于个体评价的适应值函数的计算次数（function evaluations）。 该值越小说明相应GA的搜索效率越高。 在线和离线性能指标 在线性能指标 含义：表示了算法从开始运行一直到当前为止的 时间段内性能值的平均值，它反映了算法的动态性能。 在环境e下策略s的在线性能 $X_{e}(s)$定义为： $$ X_{e}(s)=\\frac{1}{T}\\sum_{t=1}^{T}f_{e}(t) $$ $f_{e}(t)$是在环境e下第t时刻的平均目标函数值或平均适应度。 离线性能指标 含义：表示了算法运行过程中各进 化代的最佳性能值的累积平均，它反映了算法的收敛性能。 在环境e下策略s的在线性能 $X_{e}^{*}(s)$定义为： $$ X_{e}^{}(s)=\\frac{1}{T}\\sum{t=1}^{T}f_{e}^{_}(t) $$ $f_{e}^{ *}(s)$是在环境 e 下［0, t］时间段内最好的目标函数值或最大的适应度。 最优解搜索性能 GA用于函数优化的目的就是发现问题的全局最优解， 所以通常采用当前群体发现的最佳可行解的改善情况作为度量GA搜索能力的基本指标。 基本概念 设$𝑋 ⊆ 𝑅^{𝑚}$是多目标优化模型的约束集， $𝑓(𝑥) ∈ 𝑅^{𝑝}$是多目标优化时的向量目标函数，$ 𝑥1 ∈ 𝑋, 𝑥2 ∈ 𝑋$ 。若 $$ 𝑓_{𝑘}(𝑥_{1}) ≤ 𝑓_{𝑘}(𝑥_{2}) (∀𝑘 = 1,2, ⋯ 𝑝) $$ 并且 $$ 𝑓_{𝑘}(𝑥1) &lt; 𝑓_{𝑘}(𝑥2) (∃𝑘 = 1,2, ⋯ 𝑝) $$ 则称解𝑥1比解𝑥2优越。 设$𝑋 ⊆ 𝑅^{𝑚}$ 是多目标优化模型的约束集， $𝑓(𝑥) ∈ 𝑅^{𝑝}$ 是向量目标函数。若 $𝑥^{∗} ∈ 𝑋$，并且$x^{}$比 X 中的所有其他点都优越，则称 $x^{}$是多目标极小化模型的最优解。 设$𝑋 ⊆ 𝑅^{𝑚}$ 是多目标优化模型的约束集，$ 𝑓(𝑥) ∈ 𝑅^{𝑝}$ 是向量目标函数。若 $\\tilde{𝑥}∈ 𝑋$，并且不存在比 $\\tilde{𝑥}$ 更优越的 $x $，则称 $\\tilde{𝑥}$ 为多目标极小化模型的 Pareto最优解，或称为非劣解。 多目标优化问题的最优解x *就是使向量目标函数f(x) 的每一个子目标函数都同时到达最优点的解. 多目标优化问题的Pareto最优解仅仅只是它的一个可以接受的“不坏”的解，并且通常的多目标优化问题大多都具有很多个Pareto最优解. 求解多目标优化问题的首要步骤和关键步骤是求出其 所有的Pareto最优解. 求解算法 权重系数变化法 对于一个多目标优化问题，若给其各个子目标函数 $𝑓_{𝑖 }(𝑥)\\quad (i＝1，2，…，p)$，赋予不同的权重$𝑤_{i}(i＝1，2，… ，p)$，其中各$𝑤_{𝑖}$的大小代表相应子目标$𝑓_{𝑖}(𝑥)$ 在多目标优化问题中的重要程度。则各个子目标函数的线性加权和可表示为: $$ u(f(x))=\\sum_{i=1}^{p}w_{i}f_{i}(x) $$ 以这个线性加权和作为多目标优化问题的评价函数，则多目标优化问题就可转化为单目标优化问题。 并列选择法 先将群体中的全部个体按子目标函数的数目均等地划分为一些子群体 对每个子群体分配一个子目标函数，各个子目标函数在其相应的子群体中独立地进行选择运算 各自选择出一些适应度较高的个体组成一个新的子群体 所有这些新生成的子群体合并为一个完整的群体，在这个完 整的群体中进行交叉运算和变异运算 不断地进行“分割—并列选择—合并”过程 最终可求出多目标优化问题的Pareto最优解。 排序选择法 基于“Pareto最优个体”的概念来对群体中的各个个体进行排序，依据这个排列次序来进行进化过程中的选择运算。从而使得排在前面的Pareto最优个体将有更多的机会遗传到下一代群体中。如此这样经过一定代数的循环之后，最终就可求出多目标优化问题的Pareto最优解。 *共享函数法 *混合法 粒子群优化算法简介定义粒子群优化算法（Particle Swarm Optimization，PSO）是进化计算的一个分支，是一种模拟自然界的生物活动的随机搜索算法。 PSO 模拟了自然界鸟群捕食和鱼群捕食的过程。通过群体中的协作寻找到问题的全局最优解。它是 1995 年由美国学者 Eberhart 和 Kennedy 提出的。 设想这样一个场景：一群鸟在随机搜索食物。已知在这块区域里只有一块食物，所有的鸟都不知道食物在哪里，但它们能感受到当前的位置离食物还有多远。 那么，找到食物的最优策略是什么呢？ 搜寻目前离食物最近的鸟的周围区域 根据自己飞行的经验判断食物的所在 PSO的基础——信息的社会共享 每个寻优的问题解都被想像成一只鸟，称为“粒子”，所有粒子都在一个 N 维空间进行搜索； 所有的粒子都由一个fitness function 确定适应值以判断目前的位置好坏； 每一个粒子必须赋予记忆功能，能记住所搜寻到的最佳位置；每一个粒子还有一个速度以决定飞行的距离和方向。这个速度根据它本身的飞 行经验以及同伴的飞行经验进行动态调整。 特点 优点 设置参数较少 易于理解和描述 收敛速度较好 实现容易 缺点 容易陷入局部最优 收敛精度不高 后期收敛速度较慢 算法流程 初始化 初始化粒子群体（群体规模为n），包括随机位置和速度。 评估 根据适应度函数，评估每个粒子的适应度。 找到局部最优 对每个粒子，将其当前适应值与其个体历史最佳位置（Pbest）对应的适应度作比较，如果当前的适应度更高，则将用当前位置更新历史最佳位置Pbest。 找到全局最优 对每个粒子，将其当前适应值与全局最佳位置（Gbest）对应的适应度作比较，如果当前的适应度更高，则将用当前粒子的位置更新全局最佳位置Gbest。 更新 根据公式 $$ v_{k+1}=c_{0}v_{k}+c_{1}\\xi (p_{k}-x_{k})+c_{2}\\eta(p_{g}-x_{k})\\ x_{k+1}=x_{k}+v_{k+1} $$ 更新每个粒子的速度和位置 若未达终止条件，则回到第2步","tags":["算法"],"categories":["学习笔记","专业技术"]},{"title":"安利几款Win10小软件","path":"//[object Object]/2022/05/09/安利几款win10小软件/","content":"1、coodesk一款开源免费、轻便的桌面管理工具。有一键整理、分类功能，让桌面变得整洁。👉官网下载链接 整理后我的桌面： 盗用一张效果网图：（原链） 2、ShareX一款开源免费截屏+Gif工具，支持自定义、序号、马赛克、水印等等。 官网下载：ShareX - The best free and open source screenshot tool for Windows (getsharex.com) GitHub下载：Releases · ShareX/ShareX (github.com) 效果图： 开源项目地址： 下载地址： 3、Typora+PicgoMarkdown笔记神器+图床。在座应该比我知道的还多…不再赘述有需求再问 关于typora的主题有一个小推荐：evgo2017/typora-theme-orange-heart: A Typora Theme - 一个 Typora 主题 (github.com) 样式效果： 4、TranslucentTBWin10透明桌面栏，有两种方法一个是MS store下载， 一个是Github下载 Releases · TranslucentTB/TranslucentTB (github.com) 效果图： 5、drwio一款免费、功能多的作图工具，可以支持制作流程图、UML等多种图。还能在VScode中直接使用！ win10下载地址：Download Draw.io for Windows - Free - 13.9.9 (digitaltrends.com) 官网：Flowchart Maker &amp; Online Diagram Software (draw.io) 6、sourcetree一款Git可视化管理工具，Mac也有，个人的一些Git服务以及树莓派搭建的gitea都是用这个来辅助管理的，很不错。 官网及下载地址：Sourcetree Free Git GUI for Mac and Windows (sourcetreeapp.com)","tags":["分享"],"categories":["生活点滴","工具"]},{"title":"给网站增加输入效果","path":"//[object Object]/2022/05/07/给网站增加输入效果/","content":"效果图： 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;script&gt;(function webpackUniversalModuleDefinition(a, b) &#123; if (typeof exports === &quot;object&quot; &amp;&amp; typeof module === &quot;object&quot;) &#123; module.exports = b() &#125; else &#123; if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123; define([], b) &#125; else &#123; if (typeof exports === &quot;object&quot;) &#123; exports[&quot;POWERMODE&quot;] = b() &#125; else &#123; a[&quot;POWERMODE&quot;] = b() &#125; &#125; &#125;&#125;)(this, function() &#123; return (function(a) &#123; var b = &#123;&#125;; function c(e) &#123; if (b[e]) &#123; return b[e].exports &#125; var d = b[e] = &#123; exports: &#123;&#125;, id: e, loaded: false &#125;; a[e].call(d.exports, d, d.exports, c); d.loaded = true; return d.exports &#125; c.m = a; c.c = b; c.p = &quot;&quot;; return c(0) &#125;)([function(c, g, b) &#123; var d = document.createElement(&quot;canvas&quot;); d.width = window.innerWidth; d.height = window.innerHeight; d.style.cssText = &quot;position:fixed;top:0;left:0;pointer-events:none;z-index:999999&quot;; window.addEventListener(&quot;resize&quot;, function() &#123; d.width = window.innerWidth; d.height = window.innerHeight &#125;); document.body.appendChild(d); var a = d.getContext(&quot;2d&quot;); var n = []; var j = 0; var k = 120; var f = k; var p = false; o.shake = true; function l(r, q) &#123; return Math.random() * (q - r) + r &#125; function m(r) &#123; if (o.colorful) &#123; var q = l(0, 360); return &quot;hsla(&quot; + l(q - 10, q + 10) + &quot;, 100%, &quot; + l(50, 80) + &quot;%, &quot; + 1 + &quot;)&quot; &#125; else &#123; return window.getComputedStyle(r).color &#125; &#125; function e() &#123; var t = document.activeElement; var v; if (t.tagName === &quot;TEXTAREA&quot; (t.tagName === &quot;INPUT&quot; &amp;&amp; t.getAttribute(&quot;type&quot;) === &quot;text&quot;)) &#123; var u = b(1)(t, t.selectionStart); v = t.getBoundingClientRect(); return &#123; x: u.left + v.left, y: u.top + v.top, color: m(t) &#125; &#125; var s = window.getSelection(); if (s.rangeCount) &#123; var q = s.getRangeAt(0); var r = q.startContainer; if (r.nodeType === document.TEXT_NODE) &#123; r = r.parentNode &#125; v = q.getBoundingClientRect(); return &#123; x: v.left, y: v.top, color: m(r) &#125; &#125; return &#123; x: 0, y: 0, color: &quot;transparent&quot; &#125; &#125; function h(q, s, r) &#123; return &#123; x: q, y: s, alpha: 1, color: r, velocity: &#123; x: -1 + Math.random() * 2, y: -3.5 + Math.random() * 2 &#125; &#125; &#125; function o() &#123; var t = e(); var s = 5 + Math.round(Math.random() * 10); while (s--) &#123; n[j] = h(t.x, t.y, t.color); j = (j + 1) % 500 &#125; f = k; if (!p) &#123; requestAnimationFrame(i) &#125; if (o.shake) &#123; var r = 1 + 2 * Math.random(); var q = r * (Math.random() &gt; 0.5 ? -1 : 1); var u = r * (Math.random() &gt; 0.5 ? -1 : 1); document.body.style.marginLeft = q + &quot;px&quot;; document.body.style.marginTop = u + &quot;px&quot;; setTimeout(function() &#123; document.body.style.marginLeft = &quot;&quot;; document.body.style.marginTop = &quot;&quot; &#125;, 75) &#125; &#125; o.colorful = false; function i() &#123; if (f &gt; 0) &#123; requestAnimationFrame(i); f--; p = true &#125; else &#123; p = false &#125; a.clearRect(0, 0, d.width, d.height); for (var q = 0; q &lt; n.length; ++q) &#123; var r = n[q]; if (r.alpha &lt;= 0.1) &#123; continue &#125; r.velocity.y += 0.075; r.x += r.velocity.x; r.y += r.velocity.y; r.alpha *= 0.96; a.globalAlpha = r.alpha; a.fillStyle = r.color; a.fillRect(Math.round(r.x - 1.5), Math.round(r.y - 1.5), 3, 3) &#125; &#125; requestAnimationFrame(i); c.exports = o &#125;, function(b, a) &#123; (function() &#123; var d = [&quot;direction&quot;, &quot;boxSizing&quot;, &quot;width&quot;, &quot;height&quot;, &quot;overflowX&quot;, &quot;overflowY&quot;, &quot;borderTopWidth&quot;, &quot;borderRightWidth&quot;, &quot;borderBottomWidth&quot;, &quot;borderLeftWidth&quot;, &quot;borderStyle&quot;, &quot;paddingTop&quot;, &quot;paddingRight&quot;, &quot;paddingBottom&quot;, &quot;paddingLeft&quot;, &quot;fontStyle&quot;, &quot;fontVariant&quot;, &quot;fontWeight&quot;, &quot;fontStretch&quot;, &quot;fontSize&quot;, &quot;fontSizeAdjust&quot;, &quot;lineHeight&quot;, &quot;fontFamily&quot;, &quot;textAlign&quot;, &quot;textTransform&quot;, &quot;textIndent&quot;, &quot;textDecoration&quot;, &quot;letterSpacing&quot;, &quot;wordSpacing&quot;, &quot;tabSize&quot;, &quot;MozTabSize&quot;]; var e = window.mozInnerScreenX != null; function c(k, l, o) &#123; var h = o &amp;&amp; o.debug false; if (h) &#123; var i = document.querySelector(&quot;#input-textarea-caret-position-mirror-div&quot;); if (i) &#123; i.parentNode.removeChild(i) &#125; &#125; var f = document.createElement(&quot;div&quot;); f.id = &quot;input-textarea-caret-position-mirror-div&quot;; document.body.appendChild(f); var g = f.style; var j = window.getComputedStyle ? getComputedStyle(k) : k.currentStyle; g.whiteSpace = &quot;pre-wrap&quot;; if (k.nodeName !== &quot;INPUT&quot;) &#123; g.wordWrap = &quot;break-word&quot; &#125; g.position = &quot;absolute&quot;; if (!h) &#123; g.visibility = &quot;hidden&quot; &#125; d.forEach(function(p) &#123; g[p] = j[p] &#125;); if (e) &#123; if (k.scrollHeight &gt; parseInt(j.height)) &#123; g.overflowY = &quot;scroll&quot; &#125; &#125; else &#123; g.overflow = &quot;hidden&quot; &#125; f.textContent = k.value.substring(0, l); if (k.nodeName === &quot;INPUT&quot;) &#123; f.textContent = f.textContent.replace(/\\s/g, &quot;\\u00a0&quot;) &#125; var n = document.createElement(&quot;span&quot;); n.textContent = k.value.substring(l) &quot;.&quot;; f.appendChild(n); var m = &#123; top: n.offsetTop + parseInt(j[&quot;borderTopWidth&quot;]), left: n.offsetLeft + parseInt(j[&quot;borderLeftWidth&quot;]) &#125;; if (h) &#123; n.style.backgroundColor = &quot;#aaa&quot; &#125; else &#123; document.body.removeChild(f) &#125; return m &#125; if (typeof b != &quot;undefined&quot; &amp;&amp; typeof b.exports != &quot;undefined&quot;) &#123; b.exports = c &#125; else &#123; window.getCaretCoordinates = c &#125; &#125;()) &#125;])&#125;);POWERMODE.colorful = true;POWERMODE.shake = false;document.body.addEventListener(&quot;input&quot;, POWERMODE);&lt;/script&gt; 粘贴到页面的 页尾脚本 即可生效。","tags":["Javascript"],"categories":["学习笔记"]},{"title":"TypeScript+Vue3.0笔记","path":"//[object Object]/2022/05/07/typescriptvue3-0笔记/","content":"一、什么是TypescriptTypeScript英文文档 TypeScript中文网，中文文档 JavaScript的超集，遵循最新的 ES6、Es5 规范。TypeScript 扩展了 JavaScript的语法，可以编译为JavaScript，添加了类型系统的JavaScript，可以适用与任何规模的项目。 TypeScript 是由微软开发的一款开源的编程语言。TypeScript 更像后端 java、C#这样的面向对象语言可以让 JS开发大型企业项目。 谷歌也在大力支持 Typescript 的推广，谷歌的 angular2.x+就是基于 Typescript 语法。 最新的 Vue 、React 也可以集成 TypeScript。 TypeScript特性类型系统 从TypeScript的名字就可以看出来， [类型] 是其最核心的特性。 我们知道，JavaScript是一门非常灵活的编程语言： 它没有约束类型，一个变量可能初始化时是字符串类型，过一会又被赋值为数字类型 由于隐式类型转化的存在，有的变量很难在运行前就确定 基于原型的的面向对象编程，使得原型上的属性或方法可以在运行时被修改。 函数是JavaScript中的一等公民，可以赋值给变量，也可以当做参数或返回值 这种灵活性就像一把双刃剑，一方面使得JavaScript蓬勃发展，无所不能，从2013年开始就一直蝉联最普遍使用的编程语言排行榜冠军；另一方面也使得的代码质量参差不齐，维护成本高，运行错误多。 而TypeScript的 类型 系统，很大程度弥补JavaScript的缺点。 TypeScript是静态类型类型系统按照 [类型检查的时机] 来分类，可以分为动态类型和静态类型。 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript是一门解释型语言，没有编译阶段，所以他是动态类型，以下这段代码在运行时才会报错： 1234let foo = 1；foo.split(&#x27; &#x27;);//Uncaught TypeError: foo.split is not a function//运行时报错：foo.split不是一个函数，造成线上bug 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript在运行前需要先编译为JavaScript，而在编译阶段就会进行类型检查，所以 TypeScript是静态类型 ，这段TypeScript代码在编译阶段就会报错： 1234let foo = 1；foo.split(&#x27; &#x27;);//Property &#x27;split&#x27; does not exist on type &#x27;number&#x27;//编译时报错：数字没有split方法，无法通过编译 你可能会奇怪，这段TypeScript代码看上去和JavaScript没有什么区别呀。 没错！大部分JavaScript代码都只需要经过少量的修改（或者完全不用修改）就变成了TypeScript的代码，这得益于TypeScript强大的 类型推论，即使不去手动声明变量 foo 的类型，也能在变量初始化的时候自动推论出他是一个 number 类型。 完整的TypeScript代码是这样的： 1234let foo: number = 1;foo.split(&#x27; &#x27;);//Property &#x27;split&#x27; does not exist on type &#x27;number&#x27;//编译时报错：数字没有split方法，无法通过编译 TypeScript是弱类型类型系统按照 [是否允许隐式类型转换] 来分类，可分为强类型和弱类型。 以下这段代码不管是在JavaScript还是TypeScript中都是正常运行的，运行时数字1会被隐式类型转化为字符串 ‘1’ ，加号 ‘+’ 被识别为字符串拼接，打印结果为 ‘11’: 12console.log(1 + &#x27;1&#x27;);//打印字符串 &#x27;11&#x27; TypeScript是完全兼容JavaScript的，他不会修改JavaScript运行时的特性，他们都是 弱类型语言。 二、安装并编译TypeScript安装TypeScript需要NodeJS环境，如果电脑没有npm命令，可以去官网下载并安装NodeJS 官网地址：Node.js (nodejs.org) TypeScript安装命令 12npm install -g typescript# 通过tsc --version可以查看版本号以确保是否安装成功 安装以后编译ts文件很简单，我们在电脑上新建一个目录code，新建一个文件index.ts,然后在当前目录下输入： 1tsc index.ts 编译完之后会在当前目录下输出一个index.js文件，则编译成功。如果想指定输出目录： 1tsc --outFile ./js/index.js index.ts 三、基本的数据类型布尔值布尔值是最基础的数据类型，在TypeScript中，使用boolean定义布尔值类型： 1let isDone:boolean = false; 数值使用number定义数值类型： 1let mynum:number = 1; 字符串使用string定义字符串类型： 12345let mystring:string = &#x27;TypeScript字符串&#x27;//模板字符串,要用反引号括起来let sentence:string = `Hello,This is $&#123;mystring&#125;.`;//也可以使用js的加号 + 语法let sentence2:string = &#x27;Hello,This is&#x27;+mystring; 空值JavaScript没有空值(void)的概念，在TypeScript中，用void表示没有任何返回值的函数： 123function alertName():void&#123; alert(&#x27;my name is tom&#x27;);&#125; 声明一个void类型的变量没有什么用，因为你只能将它赋值为undefined和null 1let unsable:void = undefined; Null和Undefined在TypeScript中，默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。可以使用null和undefined来定义这两个原始数据类型： 12let n:null = null;let u:undefined = undefined 数组TypeScript像JavaScript一样可以操作数组元素。有两种方式定义数组。 第一种是元素类型后加 [] 1let list:number[] = [1,2,3]; 第二种是使用数组泛型，Array&lt;元素类型&gt; 1let list:Array&lt;number&gt; = [1,2,3]; 元组元组（Tuple）类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。但定义变量时类型的顺序要一致。 12345let x : [string,number];x = [&#x27;hello&#x27;,10];//正常运行x = [20,&#x27;HELLO&#x27;];//报错：不能将类型“number”分配给类型“string”。ts(2322)；不能将类型“string”分配给类型“number”。ts(2322) 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // 正常运行console.log(x[1].substr(1)); // 报错： &#x27;number&#x27; does not have &#x27;substr&#x27; 当访问越界元素时： 12x[3] = &#x27;World&#x27;;//报错：不能将类型“&quot;World&quot;”分配给类型“undefined”。ts(2322)长度为 &quot;2&quot; 的元组类型 &quot;[string, number]&quot; 在索引 &quot;2&quot; 处没有元素。ts(2493) Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 使用object类型，就可以更好的表示像Object.create这样的API。例如： 12345678declare function create(o:objectnull):void;create(&#123;pro:0&#125;);create(null);create(undefined);create();//报错：应有 1 个参数，但获得 0 个。ts(2554)create(42);//报错：类型“number”的参数不能赋给类型“object”的参数。ts(2345)create(&quot;string&quot;); //报错： 类型“string”的参数不能赋给类型“object”的参数。ts(2345)create(false); //报错：类型“boolean”的参数不能赋给类型“object”的参数。ts(2345) 四、任意值(Any)任意值(Any)用来表示允许赋值为任意类型。 如果是一个普通类型，在赋值过程中改变类型是不被允许的： 123let myFavoriteNum:string = &#x27;seven&#x27;;myFavoriteNum = 7;//报错：不能将类型“number”分配给类型“string”。ts(2322) 但如果是any类型，则允许被赋值为任意类型。 12let myFavoriteNum:any = &#x27;seven&#x27;;myFavoriteNum = 7; 在任意值上访问任何属性都是允许的： 123let anything: any = &#x27;hello&#x27;;console.log(anything.Myname);console.log(anything.myname.length); 也允许调用任何方法: 1234let anything:any = &#x27;heloo&#x27;anything.setName(&#x27;Tom&#x27;);anything.setName(&#x27;Allen&#x27;).sayHello();anything.Myname.setFirstName(&#x27;Cat&#x27;); 所以，声明一个任意值(any)变量后，对它的任何操作，返回的内容的类型都是任意值。 五、类型推论如果没有明确的指定类型，那么TypeScript会依照类型推论（Type Inference）的规则推断出一个类型。 以下代码虽然没有指定类型，但在编译时会出错： 123let myFavoriteNum = &#x27;seven&#x27;;myFavoriteNum = 7;//报错：不能将类型“number”分配给类型“string”。ts(2322) 事实上，它等价于： 123let myFavoriteNum:string = &#x27;seven&#x27;;myFavoriteNum = 7;//报错：不能将类型“number”分配给类型“string”。ts(2322) TypeScript在没有明确指定变量类型时，会对变量的类型进行推测，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any类型而完全不被类型检查： 123let myFavoriteNum;myFavoriteNum = &#x27;seven&#x27;;myFavoriteNum = 7; 六、联合类型联合类型(Union Types)表示取值可以为多种类型中的一种。 举个例子 123let myFavoriteNum:stringnumber;myFavoriteNum = &#x27;seven&#x27;;myFavoriteNum = 7; 从代码可以看出来联合类型使用 来分隔每一个类型。 这里的 let myFavoriteNum:stringnumber;的含义是允许myFavoriteNum为string和number类型，而不能是其他类型。 比如下面这个就会报错： 123let myFavoriteNum:stringnumber;myFavoriteNum = true;//报错：不能将类型“boolean”分配给类型“string number”。ts(2322) 联合类型的属性或方法当TypeScript不确定一个联合类型的变量到底是哪个类型的时候，我们 只能访问此联合类型的 共有属性或共有方法。 1234function getLength(something:numberstring):number&#123; return something.length;&#125;//报错:类型“string number”上不存在属性“length”。类型“number”上不存在属性“length”。ts(2339) 上例中，因为number类型不存在length属性，所以会报错，正确的使用可以这样： 1234function getLength(something:numberstring):string&#123; return something.toString();&#125;//`toString()`方法是number和string类型的共有方法。 联合类型变量在被赋值的时候，会根据类型推论的推断变量的类型： 1234567let myFavoriteNum:numberstring;myFavoriteNum = &#x27;seven&#x27;;console.log(myFavoriteNum.length);//正常运行myFavoriteNum = 7;console.log(myFavoriteNum.length);//报错：类型“number”上不存在属性“length”。ts(2339) 上例中，第二行的myFavoriteNum被推断成了 string型，访问 length属性就不会报错 而第四行的myFavoriteNum被推断为number型，访问length属性就会报错 七、接口在TypeScript中，我们使用 interface 来定义一个接口类型的对象。 什么是接口在面向对象语言中，接口是一个重要的概念，它是对行为的抽象，而具体的行为则需要类去实现。 typesc的核心原则之一是对之所具有的结构进行类型检查。有时候被称作“鸭式辨型法”或者“结构性子类型化”。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 举个例子 123456789101112interface Person&#123; name:string; age:number; sex:string;&#125;;let Allen:Person = &#123; name:&#x27;Allen&#x27;, age:28, sex:&#x27;male&#x27;&#125;;//正常运行 上面例子中，我们定义一个接口Person，接着定义一个变量 Allen，他的类型是Person。这样，我们就约束了Allen的形状必须是和接口Person一致，如果少了XX属性就会报错，同理，多了未定义的XX属性也会报错： 123456789101112131415161718192021interface Person&#123; name:string; age:number; sex:string;&#125;;let Tom:Person = &#123; name:&#x27;Tom&#x27;, age:18,&#125;;//Tom报错：类型 &quot;&#123; name: string; age: number; &#125;&quot; 中缺少属性 &quot;sex&quot;，但类型 &quot;Person&quot; 中需要该属性。ts(2741) index.ts(23, 2): 在此处声明了 &quot;sex&quot;。//原因是Tom少了sex属性let Ketty:Person = &#123; name:&#x27;Ketty&#x27;, age:20, sex:&#x27;female&#x27;, grade:12&#125;//报错：不能将类型“&#123; name: string; age: number; sex: string; grade: number; &#125;”分配给类型“Person”。对象文字可以只指定已知属性，并且“grade”不在类型“Person”中。ts(2322)//原因是Ketty多了grade属性 定义Tom变量却少了sex属性就会报错，同理，多了未定义的grade属性也会报错。 可见，赋值的时候，变量的结构必须和接口的结构保持一致。 可选属性有时候我们希望不要完全匹配一个接口的所有结构，那么我们可以用可选属性(在定义接口时，属性后加上 ?关键字)： 12345678910111213141516interface Person&#123; name:string; age:number; sex?:string; //可选属性 sex&#125;;let Allen:Person = &#123; name:&#x27;Allen&#x27;, age:28, sex:&#x27;male&#x27;&#125;;//正常运行let Tom:Person = &#123; name:&#x27;Tom&#x27;, age:18,&#125;;//正常运行 任意属性有时候我们希望一个接口允许有任意的属性，可以用 [属性名:类型名]定义任意属性 1234567891011121314151617181920interface Person&#123; name:string; age?:number; [propName:string]:any;&#125;;let Allen: Person = &#123; name:&#x27;Allen&#x27;, gender:&#x27;female&#x27; //添加gender属性是允许的&#125;;let Tom:Person = &#123; name:&#x27;Tom&#x27;, gender:&#x27;male&#x27;, gender2:&#x27;male&#x27;, ID:123, 123:&#x27;asdasd&#x27;, isDone:false&#125;//添加任意多个属性且类型不一致也是允许的，有点违背接口的初衷 使用 [propName:string]:any;定义了任意属性取string类型的值。 任意属性有点违背接口的初衷，既然已经定义了接口的结构，就不能任意去增加修改他的结构了 只读属性有时候我们希望对象中一些字段只能在创建时被赋值，后续只能可读不可写，那么可以用 readonly关键字定义只读属性： 123456789101112interface Person&#123; readonly id:number; name:string; age:number;&#125;;let Tom:Person = &#123; id:12345, name:&#x27;Tom&#x27;, age:19 &#125;Tom.age = 29 //不报错Tom.id = 12345//报错：无法分配到 &quot;id&quot; ，因为它是只读属性。ts(2540) 上述例子中id属性被设置为只读属性，当再次赋值时就会报错。 八、数组数组是存放多个元素的集合 最简单的方法是使用 [ 类型 + 方括号] 来表示数组： 1let fibonacci:number[] = [1,1,2,3,5,8,13]; 数组中的项不允许出现其他的类型： 12let fibonacci:number[] = [1,&#x27;1&#x27;,2,3,5,8,13];//报错：不能将类型“string”分配给类型“number”。ts(2322) 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制： 123456let fibonacci:number[] = [1,1,2,3,5,8,13];fibonacci.push(21);//正常运行fibonacci.push(&#x27;34&#x27;);//报错：类型“string”的参数不能赋给类型“number”的参数。ts(2345)//原因是push()方法只允许传入number类型的参数，而&#x27;34&#x27;是字符串字面量类型，后续章节会介绍 也可以指定一个 any 类型数组： 1let list:any[] = [&#x27;Tom&#x27;,18,&#x27;male&#x27;,true,&#123;website:&#x27;https://wangwangyz.site&#x27;&#125;]; 九、函数01函数声明在JavaScript中，有两种常见的定义函数的方式——函数声明(Function Declaration)和函数表达式(Function Expression)： 123456789//函数声明(Function Declaration)function sum(x,y)&#123; return x+y;&#125;//函数表达式(Function Expression)let mySum = function (x,y)&#123; return x+y;&#125;; 一个函数有输入和输出，要在TypeScript中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义比较简单： 123function sum(x:numebr,y:number):number&#123; return x+y;&#125; 注意，输入多余(或少于)、类型不匹配的参数，是不被允许的： 123456function sum(x:numebr,y:number):number&#123; return x+y;&#125;sum(1,2,3)//报错：应有 2 个参数，但获得 3 个。ts(2554)sum(1)//报错：应有 2 个参数，但获得 1 个。ts(2554)sum(&#x27;srt&#x27;,1)//报错：类型“string”的参数不能赋给类型“number”的参数。ts(2345) 函数表达式如果我们现在写一个对函数表达式(Function Expression)的定义，可能会写成这样： 123let mysum = function(x:number,y:number):number&#123; return x + y;&#125;; 这是可以通过编译的，不过事实上，上面的代码只对 等号右侧的匿名函数进行了类型定义，而等号左边的mysum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给mysum添加类型，则是这样： 123456789//这里用的是类型推断//let mysum = function(x:number,y:number):number&#123;// return x + y;//&#125;;//如果是手动指定类型，应该是这样let mysum:(x:number, y:number) =&gt; number = function (x:number,y:number):number&#123; return x + y;&#125;; 注意不要混淆了TS中的 =&gt; 和ES6中的 =&gt;. 在TypeScript的类型定义中，=&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 在ES6中，=&gt;叫做箭头函数，应用十分广泛，可以参考ES6的箭头函数：参考链接：阮一峰ES6箭头函数教程 用接口定义函数的形状我们也可以使用接口的方式来定义一个符合某个形状的函数： 123456789101112131415161718interface SearchFunc&#123; (source:string,subString:string):boolean;&#125;let mySearchFunc:SearchFunc;mySearchFunc = function(source:string,subString:string)&#123; return source.search(subString) !== -1;&#125;let mySearchFunc1:SearchFunc;mySearchFunc1 = function(source:number,subString:string)&#123; return 1==1;&#125;//报错：不能将类型“(args1: number, args2: string) =&gt; boolean”分配给类型“SearchFunc”。参数“args1”和“source” 的类型不兼容。不能将类型“string”分配给类型“number”。ts(2322)let mySearchFunc2:SearchFunc;mySearchFunc2 = function(source:string,subString:string)&#123; return 1;&#125;//报错：不能将类型“(args1: string, args2: string) =&gt; number”分配给类型“SearchFunc”。不能将类型“number”分配给类型“boolean”。ts(2322) 采用函数表达式接口定义函数的方式是，对等号左侧进行类型限制，可保证以后对函数名赋值时保证 参数个数、参数类型、返回值类型 不变。 十、函数02可选参数前面提到，多余的(或者少于要求的)参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用关键字 ?表示可选的参数： 12345678910function buildName(firstName:string, lastName?:string)&#123; if(lastName)&#123; return firstName + &quot; &quot; + lastName; &#125;else &#123; return firstName; &#125;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;cat&quot;);let tom = buildName(undefined, &quot;Tom&quot;); 需要注意的是，可选参数必须接在必须参数的后面，换句话说，可选参数后面不允许再出现必须参数了。(这一点和Python很像) 123456789function buildName(firstName?:string, lastName:string)&#123;//报错：必选参数不能位于可选参数后。ts(1016) if(lastName)&#123; return firstName + &quot; &quot; + lastName; &#125;else &#123; return firstName; &#125;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;cat&quot;);let tom = buildName(undefined, &quot;Tom&quot;); 参数默认值在ES6中，我们允许给函数的参数添加默认值，TypeScript会将添加了默认值的参数识别为可选参数： 12345function buildName(firstName:string, lastName:string = &#x27;Cat&#x27;)&#123; return firstName + &quot; &quot; + lastName;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;ccccat&quot;);let tom = buildName(&quot;Tom&quot;); 此时就不受 [可选参数必须接在必需参数后面] 的限制了： 12345function buildName(firstName:string = &#x27;Tom&#x27;, lastName:string)&#123; return firstName + &quot; &quot; + lastName;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;cat&quot;);let tom = buildName(undefined, &quot;Tom&quot;); 十一、函数03ES6中，可以使用 ...rest 的方式获取函数中的剩余参数(rest参数): 1234567function push(array, ...items)&#123;//参数 &quot;array&quot; 隐式具有 &quot;any&quot; 类型 items.forEach(function(item)&#123; array.push(item); &#125;);&#125;let a :any[] = [];push(a,1,2,3,4); 事实上，items 是一个数组，所以我们可以用数组的类型来定义它： 1234567function push(array:any[], ...items:any[])&#123; items.forEach(function(item)&#123; array.push(item); &#125;);&#125;let a = [];push(a,1,2,3,4); 注意，rest参数只能是最后一个参数，关于rest参数，可以参考：阮一峰ES6 rest参数详解 重载重载允许一个函数接收不同数量或类型的参数，并做不同处理。 比如，我们需要实现一个函数reverse，输入数字123的时候，输出反转的数字321，输入字符串hello的时候，输出反转的字符串olleh。 利用联合类型，我们可以这么做： 123456function reverse(x: numberstring):number string void&#123; if(typeof x === &#x27;number&#x27;)&#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); &#125;else if (typeof x === &#x27;string&#x27;)&#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);&#125; 然而这样有个缺点，就是不能够精确地表达，输入为数字的时候，输出应该也为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用 重载 定义多个 reverse的函数类型： 1234567891011function reverse(x:number):number;function reverse(x:string):string;function reverse(x:numberstring):numberstringvoid&#123; if(typeof x === &#x27;number&#x27;)&#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); &#125;else if (typeof x === &#x27;string&#x27;)&#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);&#125; &#125;reverse(123) // function reverse(x: number): number (+1 overload)reverse(&#x27;12345&#x27;) // function reverse(x: number): number (+1 overload) 上例中，我们重复定义了多次函数reverse，前两次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确看到前两个提示。 注意，TypeScript中会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 十二、类型断言01基本语法、将一个联合类型断言为其中一个类型。 类型断言(Type Assertion)可以用来手动指定一个值的类型 通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 ——————引自基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn) 基本语法有两种表达： 值 as 类型 &lt;类型&gt;值 在tsx语法中（React的jsx语法的ts版）中必须使用 值 as 类型表示类型断言。 故建议大家在使用类型断言时，统一使用 值 as 类型这样的语法。 将一个联合类型断言为其中一个类型之前提过，当TypeScript中不确定一个联合类型的变量到底是哪个类型的时候，我们 只能访问联合类型所有类型的共有属性或方法： 1234567891011121314151617interface Cat&#123; name:string; run():void;&#125;interface Fish&#123; name:string; swim():void;&#125;function getName(animal:CatFish):string&#123; return animal.name;//正常运行&#125;function getName(animal:CatFish):string&#123; return animal.run();//报错：类型“Cat Fish”上不存在属性“run”。类型“Fish”上不存在属性“run”。ts(2339)&#125; 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或者方法，比如： 123456789101112131415interface Cat&#123; name:string; run():void;&#125;interface Fish&#123; name:string; swim():void;&#125;function isFish(animal:CatFish):boolean&#123; if(typeof animal.swim === &#x27;function&#x27;)&#123; return true; &#125; return false;&#125;//报错：类型“Cat Fish”上不存在属性“swim”。类型“Cat”上不存在属性“swim”。ts(2339) 上述例子中，获取 animal.swim时会报错， 此时可以使用类型断言，将animal断言为Fish： 1234567function isFish(animal:CatFish):boolean&#123; //将animal断言为Fish if(typeof (animal as Fish).swim === &#x27;function&#x27;)&#123; return true; &#125; return false;&#125; 这样就可以解决访问animal.swim时的报错问题了。 不过需要注意的是，类型断言只能够 ’欺骗‘TypeScript编译器，无法避免运行时的错误，滥用类型断言反而会导致运行时错误： 123456789function swim(animal:CatFish):void&#123; (animal as Fish).swim();&#125;const tom:Cat = &#123; name:&#x27;Tom&#x27;, run()&#123; console.log(&quot;I&#x27;m running...&quot;);&#125;&#125;;swim(tom)//编译时不报错，运行时报错：TypeError：animal.swim is not a function 上面例子中，编译时不会报错，但是运行时会报错，当我们执行 tsc命令编译时会看到输出的文件无内容。 原因是因为 (animal as Fish).swim() 这段代码隐藏了 animal可能为 Cat 的情况，将 animal 直接断言为 Fish了，而TypeScript编译器信任了我们的断言，故在调用 swim()时编译没有错误。 总之，使用断言一定要格外小心，尽量避免断言后调用方法或引用深层属性。以减少不必要的 运行时错误。 十三、类型断言02将一个父类断言为具体的子类 当类之间有继承关系时，类型断言也是很常见的： 12345678910111213class ApiError extends Error&#123; code:number = 0;&#125;class HttpError extends Error&#123; statusCode:number = 200;&#125;function isApiError(myError:Error)&#123; if(typeof (myError as ApiError).code === &#x27;number&#x27;)&#123; return true; &#125; return false;&#125; 上述例子中，我们声明了函数isApiError，它用来判断传入的参数是不是ApiError类型，为了实现这样一个函数，它的参数类型肯定得是比较抽象的父类Error，这样的话这个函数就能接受Error或他的子类作为参数了。 但是由于父类Error中没有code属性，故直接获取myError.会报错：类型“Error”上不存在属性“code”。这时候需要使用类型断言获取(myError as ApiError).code。 大家可能会注意到，在这个例子中会有一个更合适的方式来判断是不是ApiError，那就是使用instaceof： 123456789101112class ApiError extends Error&#123; code:number = 0;&#125;class HttpError extends Error&#123; statusCode:number = 200;&#125;function isApiError(myError:Error)&#123; if(myError instanceof ApiError)&#123; return true; &#125; return false;&#125; 上面的例子中，用instanceof确实是一个很好的方式，因为ApiError是一个JavaScript的类，能够通过instanceof判断是否是它的实例。 但是有的情况下ApiError和HttpError不是一个真正的类，而只是一个TypeScript接口，接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法用instanceof来判断： 12345678910111213interface ApiError extends Error&#123; code:number;&#125;interface HttpError extends Error&#123; statusCode:number;&#125;function isApiError(myError:Error)&#123; if(myError instanceof ApiError)&#123; return true; &#125; return false;&#125;//报错：“ApiError”仅表示类型，但在此处却作为值使用 此时就只能用类型断言，通过判断是否存在 code 属性来判断传入的参数是否为 ApiError了： 123456789101112interface ApiError extends Error&#123; code:number;&#125;interface HttpError extends Error&#123; statusCode:number;&#125;function isApiError(myError:Error)&#123; if(typeof (myError as ApiError).code === &#x27;number&#x27;)&#123; return true; &#125; return false;&#125; 十四、类型断言03将任何一个类型断言为 any 理想情况下，TypeScript的类型系统运转良好，每个值的类型都具体而精确。 当我们引用一个在此类型上不存在的属性或方法时，会报错： 123const foo: number = 1;console.log(foo.length);//报错：类型“number”上不存在属性“length”。ts(2339) 上面例子中，数字类型的变量foo上是没有length属性的，故TypeScript编译时给出了错误提示。 这种错误提示显然是很有用的。 但有的时候，我们非常确定这段代码不会出错，比如： 12window.foo = 1;//报错：类型“Window &amp; typeof globalThis”上不存在属性“foo”。ts(2339) 上面的例子中，我们需要将window上添加一个foo属性，但是TS会给我们报错，提示window不存在属性foo。 此时我们可以使用as any临时将window断言为any类型： 1(window as any).foo = 1; 在 any 类型中，访问任何属性都是可以的。 需要注意的是，将一个变量断言为any可以说是解决TypeScript中类型问题的最后一个手段。 但是它极有可能真正掩盖了类型错误，如果不是十分确定，就不要使用 as any。 总之，一方面不要滥用 any类型，另一方面也不要忽略他带来的作用。我们需要在类型的严格性和开发的方便性之间平衡利弊，才能发挥TypeScript最大的价值。 十五、类型断言04将any类型断言为一个具体的类型 在日常的开发中，我们不可避免的需要处理any类型的变量，它们可能是由于第三方库未能定义好自己的类型，也可能是历史遗留的或其它人编写的烂代码，还可能是受到TypeScript类型系统的限制而无法精确定义类型的场景。 遇到any类型的变量时，我们可以选择无视他，任由他滋生更多的any类型。 我们可以选择改进它，通过类型断言及时地吧any断言为精确的类型，亡羊补牢，使我们的代码向着可维护性高的目标发展。 举例来说，历史遗留的代码中有个getCacheData函数，它的返回值是any: 123function getCacheData(key:string):any&#123; return (window as any).cache[key];&#125; 那么我们在使用这个getCacheData函数的时候，最好能够将调用了getCacheData之后的返回值断言为一个精确的类型，这样就方便了后续的操作： 1234567891011function getCacheData(key:string):any&#123; return (window as any).cache[key];&#125;interface Cat&#123; name:string; run():void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run(); 上面例子中，我们调用完getCacheData之后，立即将她断言为Cat类型，这样的话明确了tom的类型，后续对tom的访问时就有了代码补全，提高了代码的可维护性。 题外话个人认为在遇到较多any类型变量时，尽量在接下来少用或者不用any类型，根据IDE给出的提示将类型规范化，能减少项目80%的潜在bug。 解决any出现次数过次的问题复杂类型的类型定义 细拆出重复定义的公共项，使用extents 关键字或者 &amp; 交叉运算符来进行整合，提高利用率； 例1： 123456789101112131415161718191. // bad interface Person &#123; firstName: string; lastName: string; &#125;interface PersonWithBirthDate &#123; firstName: string; lastName: string; birth: Date;&#125;// goodinterface Person &#123; firstName: string; lastName: string;&#125;interface PersonWithBirthDate extends Person &#123; birth: Date;&#125; 例2： 123456789101112131415161718export type List = &#123; creatTime: number string; creator: string; desc: string; id: string; modifier: string; token: string; updateTime: number string; &#125;;export type ProjectList = &#123; id: string; projectName: string;&#125; &amp; List;export type TaskList = &#123; name: string;&#125; &amp; List; 新的问题：如果很多字段要打问号怎么办？下面会讲到 使用typeof定义一个类型匹配初始值（常见的使用场景之一：固定的Schema配置适用） 12345678910111213141516const INIT_OPTIONS= &#123; width: 640, height: 480, color: &quot;#00FF00&quot;, label: &quot;VGA&quot;,&#125;;interface Options &#123; width: number; height: number; color: string; label: string;&#125;// 快速获取配置对象的形状type Options = typeof INIT_OPTIONS; 使用Ts 内置类型来解决？号太多的问题 Utility Types 充分利用lib.es5.d.ts中的Partial, Pick , Extract, Omit等方法，扩展第三方、或已存在的类型，不要重复定义完全一样的字段。 参考链接：TypeScript：为什么不要用any声明类型 - 掘金 (juejin.cn) 规范TS项目Any类型的使用_Jasmine_jiamei的博客-CSDN博客_ts 对象属性any 十六、类型断言05类型断言的限制 从上面的例子可以总结出： 联合类型可以被断言为其中一个类型 父类可以被断言为子类 任何类型都可以被断言为 any any可以被断言为任意类型 那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？ 答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。 具体来说，若A、B两者具有共同的属性或者方法，那么A能够被断言为B，B也能够断言为A。 下面我们通过一个简化的例子，来理解类型断言的限制： 1234567891011121314//两者是有共同的属性或者方法，比如Animal和Cat都有nameinterface Animal&#123; name:string;&#125;interface Cat&#123; name:string; run():void;&#125;function testAnimal(animal: Animal)&#123; return (animal as Cat);&#125;function testCat(cat : Cat)&#123; return (cat as Animal);&#125; 上述例子中是可以断言的，我们再看看下面的例子： 1234567891011121314//两者没有有共同的属性或者方法，interface Animal&#123; name:string;&#125;interface Cat&#123;// name:string; run():void;&#125;function testAnimal(animal: Animal)&#123; return (animal as Cat); //报错：类型 &quot;Animal&quot; 中缺少属性 &quot;run&quot;，但类型 &quot;Cat&quot; 中需要该属性。ts(2352)&#125;function testCat(cat : Cat)&#123; return (cat as Animal);//报错：类型 &quot;Cat&quot; 中缺少属性 &quot;name&quot;，但类型 &quot;Animal&quot; 中需要该属性。ts(2352)&#125; 这时候会报错，两者不能充分重叠，这意味着要想断言成功，需要具备一个条件： 要使得A和B能够被 互相断言，就要A兼容B或者B兼容A 十七、类型断言06双重断言 既然： 任何类型都可以被断言为any an可以被断言为任何类型 那么我们是不是可以使用双重断言 as any as foo 来将任何一个类型断言为另一个类型呢？ 12345678910interface Cat&#123; run():void;&#125;interface Fish&#123; swim():void;&#125;function testCat(cat : Cat)&#123; return (cat as any as Fish);&#125; 上述例子中，若直接使用 cat as Fish 会报错：类型 “Cat” 中缺少属性 “swim”，但类型 “Fish” 中需要该属性。因为Cat和Fish都互不兼容。 但是若使用双重断言，则可以打破 [要使得A能都断言B ,就要A兼容B或者B兼容A] 的限制，将任何一个类型断言为任何另一个类型。 若你使用了这种双重断言，那么十有八九都是非常错误。他很可能会导致运行时错误。 除非迫不得已，否则千万别用双重断言。（咋迫不得已？基本不用吧？） 十八、类型断言07类型断言VS类型转换 类型断言只会影响TypeScript编译时的类型，类型断言语句会在编译结果中被删除： 12345function toBoolean(something:any):boolean&#123; return something as boolean;&#125;toBoolean(1);//返回值为1 在上面的例子中，将something断言为boolean可以通过编译，但是并没有什么用，代码在编译后会变成： 12345function toBoolean(something) &#123; return something;&#125;toBoolean(1);//返回值为1 所以类型断言不是类型转换，他不会真的影响到变量的类型。 若要进行类型转化，需要直接调用类型转换的方法： 12345function toBoolean(something:any):boolean&#123; return Boolean(something);&#125;toBoolean(1);//返回值为true 十九、类型断言08类型断言VS类型声明 在这个例子中： 1234567891011function getCacheData(key:string):any&#123; return (window as any).cache[key];&#125;interface Cat&#123; name:string; run():void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run(); 我们使用 as Cat将any类型断言为了Cat类型。 但实际上还有其他方式可以解决这个问题： 12345678910function getCacheData(key:string):any&#123; return (window as any).cache[key];&#125;interface Cat&#123; name:string; run():void;&#125;const tom:Cat = getCacheData(&#x27;tom&#x27;);tom.run(); 上面的例子中，我们通过类型声明的方式，将tom声明为Cat，然后再将any类型的getCacheData(‘tom’)赋值给Cat类型的tom。 这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom在接下来的代码中都变成了Cat类型。 他们的区别，可以通过这个例子来理解： 1234567891011interface Animal&#123; name:string;&#125;interface Cat&#123; name:string; run():void;&#125;const animal: Animal = &#123; name:&#x27;tom&#x27;&#125;let tom = animal as Cat; 上述例子中，由于Animal兼容 Cat，故可以将 animal 断言为 Cat赋值给tom。 但是若直接声明tom为Cat类型： 123456789101112interface Animal&#123; name:string;&#125;interface Cat&#123; name:string; run():void;&#125;const animal: Animal = &#123; name:&#x27;tom&#x27;&#125;let tom: Cat = animal;//报错：类型 &quot;Animal&quot; 中缺少属性 &quot;run&quot;，但类型 &quot;Cat&quot; 中需要该属性。ts(2741) 则会报错，不允许将Cat类型的tom赋值为animal。 我们可以得出结论： A断言为B时，A和B有一个及以上相同的属性或方法即可 A声明为B时，A必须具备B的所有属性和方法 知道了他们的核心区别，就知道了类型声明是比类型断言更加严格的。 所以为了增加代码的质量我们最好优先使用类型声明，这也比类型断言的 as语法更有优势。 二十、类型断言09类型断言VS泛型 这是一个例子： 123456789function getCacheData(key:string):any&#123; return (window as any).cache[key];&#125;interface Cat&#123; name:string; run():void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run(); 我们还有第三种方式可以解决这个问题，那就是泛型： 123456789function getCacheData&lt;T&gt;(key:string):T&#123; return (window as any).cache[key];&#125;interface Cat&#123; name:string; run():void;&#125;const tom = getCacheData&lt;Cat&gt;(&#x27;tom&#x27;);tom.run(); 通过给getCacheData函数添加一个泛型 ,我们可以更加规范的实现对getCacheData返回值的约束，这也同时去除掉了代码中的any，是最优的一个解决方式。 关于泛型 是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。 泛型的定义 主要有以下两种： 在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义） 在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（现在人们大多把这称作模板） 不论使用哪个定义，泛型的参数在真正使用泛型时都必须作出指明。 参考：泛型_百度百科 (baidu.com) 二一、type关键字使用type关键字定义类型别名和字符串字面量类型 我们来看一个方法： 1234567function getName(n:string(() =&gt; string)):string&#123; if(typeof n === &#x27;string&#x27;)&#123; return n; &#125;else&#123; return n(); &#125;&#125; type关键字作为类型别名用来给一个类型起个新名字 12345678910type Name = string;type NameResolver = ()=&gt; string;type NameOrResolver = Name NameResolver;function getName(n:NameResolver):Name&#123; if (typeof n === &#x27;string&#x27;)&#123; return n; &#125;else&#123; return n(); &#125;&#125; 上述例子中，我们使用type关键字创建类型别名。 类型别名常用语联合类型。 字符串字面量类型用来约束取值只能是某几个字符串中的一个 12345678type EventsName = &#x27;click&#x27; &#x27;scroll&#x27; &#x27;mousemove&#x27;;function handleEvent(ele:Element null,event:EventsName)&#123; //do something&#125;handleEvent(document.getElementById(&#x27;hello&#x27;),&#x27;click&#x27;);//正常运行handleEvent(document.getElemnetById(&#x27;world&#x27;),&#x27;dbclick&#x27;);//报错：类型“&quot;dbclick&quot;”的参数不能赋给类型“EventsName”的参数。ts(2345) 二二、元组数组合并了相同类型的对象，而元组(Tuple)合并了不同类型的对象。 元组起源与函数编程语言(如F#，Python也有元组的概念)，这些语言中会频繁使用元组。 举个例子，定义一对值分别为 string和 number的元组： 1let tom:[string,number] = [&#x27;Tom&#x27;,15]; 当赋值或访问一个已知索引的元素时，会得到正确的类型： 123let tom:[string,number];tom[0] = &#x27;Tom&#x27;;tom[1] = 15; 也可以赋值其中一项： 12let tom:[string,number];tom[0] = &#x27;Tom&#x27;; 但是当直接对元组进行初始化赋值操作时，需要提供所有元组类型指定的项 12let tom:[string,number];tom = [&#x27;Tom&#x27;,18]; 下面这样就不行了： 123let tom:[string,number];tom = [&#x27;Tom&#x27;];//报错：不能将类型“[string]”分配给类型“[string, number]”。源具有 1 个元素，但目标需要 2 个。ts(2322) 越界元素 当添加越界元素时，他的类型会被限制为元组中每个类型的联合类型： 12345let tom:[string,number];tom = [&#x27;Tom&#x27;,18];tom.push(&#x27;male&#x27;);//可以添加stirng，此时tom为[&#x27;Tom&#x27;,18,&#x27;male&#x27;]tom.push(true);//不可以添加boolean//报错：类型“boolean”的参数不能赋给类型“string number”的参数。ts(2345) 二三、枚举枚举(Enum)类型用于取值被限定在一定范围的场景，比如一周只能有七天，颜色限定为红绿蓝等。 枚举使用enum关键字来定义： 1enum Days&#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射： 123456789101112enum Days&#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&#x27;Sun&#x27;] === 0);//trueconsole.log(Days[&#x27;Mon&#x27;] === 1);//trueconsole.log(Days[&#x27;Wed&#x27;] === 3);//trueconsole.log(Days[&#x27;Thu&#x27;] === 4);//console.log(Days[&#x27;Sun&#x27;] === 4);//false,且不能通过编译，IDE提示：此条件将始终返回 &quot;false&quot;，因为类型 &quot;Days.Sun&quot; 和 &quot;4&quot; 没有重叠。console.log(Days[0] === &#x27;Sun&#x27;);//trueconsole.log(Days[1] === &#x27;Mon&#x27;);//trueconsole.log(Days[3] === &#x27;Wed&#x27;);//trueconsole.log(Days[4] === &#x27;Sun&#x27;);//false，IDE不进行提示 上面的例子会被编译为JS代码： 1234567891011121314151617181920var Days;(function (Days) &#123; Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;; Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;; Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;; Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;; Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;; Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;; Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;&#125;)(Days (Days = &#123;&#125;));;console.log(Days[&#x27;Sun&#x27;] === 0); //trueconsole.log(Days[&#x27;Mon&#x27;] === 1); //trueconsole.log(Days[&#x27;Wed&#x27;] === 3); //trueconsole.log(Days[&#x27;Thu&#x27;] === 4);// console.log(Days[&#x27;Sun&#x27;] === 4);//false,IDE提示：此条件将始终返回 &quot;false&quot;，因为类型 &quot;Days.Sun&quot; 和 &quot;4&quot; 没有重叠。console.log(Days[0] === &#x27;Sun&#x27;); //trueconsole.log(Days[1] === &#x27;Mon&#x27;); //trueconsole.log(Days[3] === &#x27;Wed&#x27;); //trueconsole.log(Days[4] === &#x27;Sun&#x27;); //false，IDE不进行提示 二四、类01类的概念虽然JavaScript中有类的概念，但是可能大多数JavaScript程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。 类(Class):定义一件事物的抽象特点，包含它的属性和方法 对象(Object):类的实例，通过 new生成 面向对象编程(Object Oriented Programming，简称 OOP)三大特性：继承、封装、多态 继承(Inheritance):子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特征。 封装(Encapsulation):将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据。 多态(Polymorphism):由继承而产生相关的不同的类，对同一个方法可以有不同的响应。比如Cat和Fish都继承自Animal，但是分别实现了自己的eat方法。此时针对某一个实例，我们无须了解他是Cat还是Dog，就可以直接调用eat方法，程序会自动判断出来应该如何执行eat方法。 存取器(Getter &amp; Setter)：用于改变属性的读取和赋值行为 修饰器(Modifiers):修饰符是一些关键字，用于限定成员或类型的性质。比如public 表示共有的属性或方法。 抽象类(Abstract Class):抽象类是提供给其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现。 接口(Interface):不同类之间共有的属性或方法，可以抽象成一个接口，接口可以被类实现(implements)。一个类只能继承自另一个类，但是可以实现多个接口。 构造函数(Constructor):构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中 使用class关键字定义类，使用 constructor关键字定义构造函数。 通过new生成新的实例的时候，会自动调用构造函数： 123456789101112class Animal&#123; public _name; constructor(name:string)&#123; this._name = name; &#125; sayHello()&#123; return `My name is $&#123;this._name&#125;`; &#125;&#125;let tom = new Animal(&#x27;Tom&#x27;);console.log(tom.sayHello); //My name is tom 二五、类02类的存取器 ：get 、set 使用getter 和 setter 可以获取和改变类的属性： 12345678910111213141516class Animal&#123; // private name:string; constructor(name:string)&#123; this.name = name; &#125; get name()&#123; return &#x27;Jack&#x27;; &#125; set name(value)&#123; console.log(&#x27;This name:&#x27;+value); &#125;&#125;let a = new Animal(&#x27;Kitty&#x27;);//setter Kittya.name = &#x27;Tom&#x27;;//setter Tomconsole.log(a.name);//getter Jack 二六、类03类的静态方法 使用static修饰符修饰的方法成为静态方法，他们不需要实例化，而直接通过类来调用： 12345678910111213141516class Animal&#123; public _name; constructor(name:string)&#123; this._name = name; &#125; sayHi()&#123;//这是实例方法 return `My name is $&#123; this._name &#125;`; &#125; static sayHello()&#123;//这是类方法 return &quot;I&#x27;m Animal class&quot;; &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi());//My name is Jackconsole.log(Animal.sayHello());//I&#x27;m Animal class 二七、类04类的三种访问修饰符：public、private、protected 访问权限大小由大到小： public 全局的、公共的，当前所涉及到的地方都可以使用 1234567891011class Animal&#123;public _name; public constructor(name:string)&#123; this._name = name; &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a._name);// Jacka._name = &#x27;Tom&#x27;;console.log(a._name);// Tom protected 受保护的，允许子类访问，不允许公共访问： 12345678910111213class Animal&#123;protected name; public constructor(name:string)&#123; this.name = name; &#125;&#125;class Cat extends Animal&#123; public constructor(name:string)&#123; super(name); console.log(this.name); &#125;&#125; private 私有的，只能在类的内部使用，子类也无法访问，无法在实例后通过类的实例属性访问： 1234567891011class Animal&#123;private _name; public constructor(name:string)&#123; this._name = name; &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a._name);// 报错:属性“_name”为私有属性，只能在类“Animal”中访问。ts(2341)a._name = &#x27;Tom&#x27;; //报错:属性“_name”为私有属性，只能在类“Animal”中访问。ts(2341)console.log(a._name);// 报错:属性“_name”为私有属性，只能在类“Animal”中访问。ts(2341) 默认是public，但是 TSLint 可能会要求必须用限定符来表明这个属性或方法是什么类型。 二八、类05参数属性和只读属性关键字 修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更加简洁： 123456class Animal&#123; public name:string; public constructor(public myname:string)&#123; this.name = myname; &#125;&#125; 只读属性 12345678910class Animal&#123; readonly name:string; public constructor(myname:string)&#123; this.name = myname; &#125;&#125;let a = new Animal(&#x27;Tom&#x27;);console.log(a.name);//Toma.name = &#x27;Jack&#x27;;//报错：无法分配到 &quot;name&quot; ，因为它是只读属性。ts(2540) 二九、类06抽象类 abstract关键字用来定义抽象类和其中的抽象方法。 什么是抽象类？ 首先，抽象类是不允许被实例化的： 1234567891011abstract class Animal&#123; //public name:string;//这报错：属性“name”没有初始化表达式，且未在构造函数中明确赋值。 public name:any; public constrcutor(name:string)&#123; this.name = name; &#125; public abstract sayHi():void;&#125;let a = new Animal(&#x27;Tom&#x27;);//报错：无法创建抽象类的实例。ts(2511) 上面例子中，我们定义了一个抽象类类Animal，并且定义了一个抽象方法 sayHi，在实例化抽象类是报错了。 其次，抽象类中的抽象方法必须被子类实现： 123456789class Cat extends Animal&#123; /** * eat */ public eat() &#123; console.log(&#x27;Im eating&#x27;); &#125;&#125;//报错：非抽象类“Cat”不会实现继承自“Animal”类的抽象成员“sayHi”。ts(2515) 正确的抽象类例子： 1234567891011121314abstract class Animal&#123; public name: any; public constrcutor(name:string): void&#123; this.name = name; &#125; public abstract sayHi():void;&#125;class Cat extends Animal&#123; public sayHi(): void &#123; console.log(`This is Cat $&#123; this.name&#125;`); &#125;&#125;let a = new Cat(&#x27;Tom&#x27;); 上面例子为原视频的例子，却报错：应有 0 个参数，但获得 1 个。ts(2554) 找了一些资料还没找到原因，后续再来更 三十、类与接口类继承接口实现(implements)是面向对象的一个重要概念。一般来说，一个类只能继承自另一个类，有时候不用类之间可以有一些共有的特性，这时候就可以把特性提取成接口(interfaces)，用implements关键字来实现，这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法，这时候如果有另一个类：车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门，和车都去实现它： 12345678910111213141516interface Alert&#123; alert():void;&#125;class Door&#123;&#125;class SecurityDoor extends Door implements Alert&#123; alert()&#123; console.log(&#x27;SecurityDoor alert&#x27;); &#125;&#125;class car implements Alert&#123; alert()&#123; console.log(&#x27;Car alert&#x27;); &#125;&#125; 一个类可以实现多个接口： 12345678910111213141516171819interface Alert&#123; alert():void;&#125;interface Light&#123; lightOn():void; lightOff():void;&#125;class Car implements Alert, Light&#123; alert()&#123; console.log(&#x27;Car alert&#x27;); &#125; lightOff()&#123; console.log(&#x27;Light Off&#x27;); &#125; lightOn()&#123; console.log(&#x27;Light On&#x27;); &#125;&#125; 上述例子中，Car 实现了 Alert 和 Light接口，既能报警，也能开关灯。 接口继承接口接口和接口之间可以是继承关系： 1234567interface Alert&#123; alert():void;&#125;interface LightableAlert extends Alert&#123; lightOn():void; lightOff():void;&#125; 这很好理解，LightableAlert 继承了 Alert ，除了拥有alert方法之外，还可以拥有自己定义的两个新方法 lighton和lightoff。 接口继承类常见的面向对象语言中，接口是不能继承类的，但是在TypeScript中是可以的： 1234567891011121314class Point&#123; x:number; y:number; constructor(x:number,y:number)&#123; this.x = x; this.y = y; &#125;&#125;interface Point3d extends Point&#123; z:number;&#125;let point3d:Point3d = &#123;x:1,y:2,z:3&#125;; 但在这里不推荐这样使用，我们在定义接口的时候只做定义，具体实现交给实现接口的类去完成。 三一、泛型01泛型(Generics)是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候在指定类型的一种特性。 首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值。： 123456789function creatArray(length:number,value:any): Array&lt;any&gt;&#123; let result = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;creatArray(3,&#x27;x&#x27;);//[&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;] 上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。 这段代码编译不会报错，但是一个显而易见的缺陷是，他并没有准确的定义返回值的类型； Array&lt;any&gt;允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的value的类型。 这时候，泛型就派上用场： 12345678function createArray&lt;T&gt;(length: number, value: T):Array&lt;T&gt;&#123; let result: T[] = []; for(let i = 0; i&lt;length; i++)&#123; result[i] = value; &#125; return result&#125;creatArray&lt;string&gt;(3,&#x27;x&#x27;);//[&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;] 上例中，我们在函数名后添加了&lt;T&gt;，其中T 用来指代任意输入的类型，在后面的输入value:T 和输出 Array&lt;T&gt; 中即可使用了。接着在调用的时候，可以指定他的具体的类型为string 型。当然，也可以不手动指定，而让类型推论自动推算出来： 123456789function createArray&lt;T&gt;(length: number, value: T):Array&lt;T&gt;&#123; let result: T[] = []; for(let i = 0; i&lt;length; i++)&#123; result[i] = value; &#125; return result&#125;//不指定类型，通过类型推断来自动推断出类型 creatArray(3,&#x27;x&#x27;);//[&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;] 三二、泛型02多个类型参数 定义泛型的时候，可以一次定义多个类型参数： 1234function swap&lt;T, U&gt;(tuple:[T, U]): [U, T]&#123; return [tuple[1],tuple[0]];&#125;swap([7,&#x27;seven&#x27;]);//[&#x27;seven&#x27;, 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组 三三、泛型03泛型约束 在函数内部使用泛型变量的时候，由于事先不知道他是哪种类型，所以不能随意的操作它的属性或方法： 12345function loggingIdentity&lt;T&gt;(arg: T): T&#123; console.log(arg.length); return arg;&#125;//报错：类型“T”上不存在属性“length”。ts(2339) 上例中，泛型 T 不一定包含属性 length ，所以编译的时候报错了。 这时，我们可以对泛型进行约束，致允熙这个函数传入那些包含 length 属性的变量，这就是泛型约束： 1234567interface LengthWise&#123; length: number;&#125;function loggingIdentity&lt;T extends LengthWise&gt;(arg: T): T&#123; console.log(arg.length); return arg;&#125; 上例中，我们使用了 extends 约束了泛型 T 必须符合接口 LengthWise 的形状，也就是必须包含 length 属性。 此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length ，则会在编译时报错： 1234567891011interface LengthWise&#123; length: number;&#125;function loggingIdentity&lt;T extends LengthWise&gt;(arg: T): T&#123; console.log(arg.length); return arg;&#125;loggingIdentity(&#x27;1111&#x27;);// 4loggingIdentity(8);//报错：类型“number”的参数不能赋给类型“LengthWise”的参数。ts(2345) 三四、泛型04泛型接口 之前学习过，可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc&#123; (source: string, subString: string): boolean; &#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string)&#123; return source.search(subString) != -1;&#125; 当然也可以使用含有泛型的接口来定义函数的形状： 1234567891011121314interface CreateArrayFunc&#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt;&#123; let result:T[] = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray(3,&#x27;x&#x27;);//[&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;] 进一步，我们可以把泛型参数提前到接口名上： 12345678910111213141516171819interface CreateArrayFunc&lt;T&gt;&#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt;&#123; let result:T[] = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125;createArray(3,&#x27;x&#x27;);//[&#x27;x&#x27;,&#x27;x&#x27;,&#x27;x&#x27;]createArray(3,true);//[true,true,true]createArray(3,&#123;isExist:true&#125;);//[&#123;isExist:true&#125;,&#123;isExist:true&#125;,&#123;isExist:true&#125;] 三五、泛型05泛型类 与泛型接口类似，泛型也可以用于类的类型定义中： 1234567class GenericNumber&lt;T&gt;&#123; zeroValue!: T; //!为非空断言, 否则报错：属性“XXX”没有初始化表达式，且未在构造函数中明确赋值。 add!: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x,y)&#123; return x+y; &#125;; 泛型参数的默认类型 在TypeScript2.3以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T):Array&lt;T&gt;&#123; let result:T[] = []; for(let i = 0; i &lt; length; i++)&#123; result[i] = value; &#125; return result;&#125; 三六、声明合并同名函数、接口、类的合并 如果定义了两个相同的名字的函数、接口或类，那么他们会合并成一个类型： 函数的合并之前我们学习过，我们可以使用重载定义多个函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number string): number string&#123; if (typeof x === &#x27;number&#x27;)&#123; return Number(x.toString().split(&#x27;&#x27;).reverse.join(&#x27;&#x27;)); &#125; else if( typeof x === &#x27;string&#x27;)&#123; return x.split(&#x27;&#x27;).reverse.join(&#x27;&#x27;); &#125;&#125; 接口的合并接口中的属性在合并时会简单地合并到一个接口中： 123456interface Alarm&#123; price: number;&#125;interface Alarm&#123; weight: number;&#125; 相当于： 1234interface Alarm&#123; price: number; weight: number;&#125; 注意，合并的属性的类型必须是唯一的： 12345678interface Alarm&#123; price: number;&#125;interface Alarm&#123; price: number; //虽然重复了，但是类型还是number，所以不会报错 weight: number;&#125; 12345678interface Alarm&#123; price: number;&#125;interface Alarm&#123; price: string; //报错：后续属性声明必须属于同一类型。属性“price”的类型必须为“number”，但此处却为类型“string”。ts(2717) weight: number;&#125; 接口中的方法合并，和函数的合并一样： 12345678interface Alarm&#123; price: number; alert(s: string): string;&#125;interface Alarm&#123; weight: number; alert(s: string, n: number): string;&#125; 相当于： 123456interface Alarm&#123; price: number; weight: number; alert(s: string): string; alert(s: string, n: number): string;&#125; 类的合并类的合并与借口的合并一样 PS: 但是一般情况下，不建议创建多个同名接口或类，虽然可以自动合并，但是可能会发生意想不到的问题。代码不要写在两个地方，不然不好维护。 三七、写在结尾TypeScript 应用非常广泛，最新的 Vue 和 React 均集成了 TypeScript ，这里推荐大家使用 Vue3 ，Vue3 天然支持 TypeScript。 另一方面，TS 中有很多支持 ES 的语法，关系图： 最后，多看文档 TypeScript英文文档 TypeScript中文文档","tags":["Javascript","TypeScript","Vue"],"categories":["学习笔记"]},{"title":"GitHub三种方法加速访问","path":"//[object Object]/2022/05/06/github三种方法加速访问/","content":"一、镜像网站(不推荐)这里提供两个最常用的镜像地址： https://github.com.cnpmjs.org https://hub.fastgit.org GitHub: Where the world builds software · GitHub (fastgit.xyz) 有时候并不生效，依然被q，而且镜像网站随时可能跑路 二、修改hosts文件(安全、快速、不稳定)关于hosts文件：hosts 文件本来是用来提高解析效率。 在进行 DNS 请求以前，系统会先检查自己的 hosts 文件中是否有这个地址映射关系，如果有则调用这个 IP 地址映射，如果没有再向已知的 DNS 服务器提出域名解析。 也就是 hosts&gt; DNS 找到hosts文件 hosts文件在不同操作系统中的存放路径： Windows系统： C:\\Windows\\System32\\drivers\\etc Mac OS、Linux及其它类Unix系统： /etc/ Android系统： /system/etc/ 添加域名解析 在hosts文件末尾添加上以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940 # GitHub Start140.82.113.25 alive.github.com140.82.114.26 live.github.com185.199.108.154 github.githubassets.com140.82.114.21 central.github.com185.199.108.133 desktop.githubusercontent.com185.199.108.153 assets-cdn.github.com185.199.108.133 camo.githubusercontent.com185.199.108.133 github.map.fastly.net199.232.69.194 github.global.ssl.fastly.net140.82.113.3 gist.github.com185.199.108.153 github.io140.82.114.3 github.com192.0.66.2 github.blog140.82.114.6 api.github.com185.199.108.133 raw.githubusercontent.com185.199.108.133 user-images.githubusercontent.com185.199.108.133 favicons.githubusercontent.com185.199.108.133 avatars5.githubusercontent.com185.199.108.133 avatars4.githubusercontent.com185.199.108.133 avatars3.githubusercontent.com185.199.108.133 avatars2.githubusercontent.com185.199.108.133 avatars1.githubusercontent.com185.199.108.133 avatars0.githubusercontent.com185.199.108.133 avatars.githubusercontent.com140.82.113.9 codeload.github.com52.216.137.116 github-cloud.s3.amazonaws.com52.217.203.169 github-com.s3.amazonaws.com52.217.105.68 github-production-release-asset-2e65be.s3.amazonaws.com52.217.203.169 github-production-user-asset-6210df.s3.amazonaws.com52.216.241.132 github-production-repository-file-5c1aeb.s3.amazonaws.com185.199.108.153 githubstatus.com64.71.144.211 github.community40.68.78.177 github.dev140.82.113.21 collector.github.com13.107.42.16 pipelines.actions.githubusercontent.com185.199.108.133 media.githubusercontent.com185.199.108.133 cloud.githubusercontent.com185.199.108.133 objects.githubusercontent.com # GitHub End 注意：这些ip可能会发生改变，具体可自行百度搜索相关ip信息，该记录我使用了半年之久都有效。 刷新DNS缓存使之生效： Windows系统在cmd命令行中执行命令： 1ipconfig/flushdns Linux等系统一般修改后都即刻生效。 Github查看效果 总结 这种方法其实也不稳定，大部分时候是能正常快速访问，我也用了一年左右，但是还是会有时不时被墙。个人更喜欢这个~ 三、代理(稳定高速、部分收费)在这里我只是介绍一个使用代理服务快速访问github的方法，由该方法导致任何的后果概不负责。 有很多种方式加速访问github，听过的就有stream++、epic++、XXXX等，自行百度吧。在这里我介绍使用github上的一个项目Fastgithub来加速访问github，特点：免费高效、开源。 其实github上面就有很详细的教程，我只是复制一遍，方便目前还访问不了的人，以下是原文档，如有侵权请联系我删除： 2.1 windows-x64桌面 双击运行FastGithub.UI.exe 2.2 windows-x64服务 fastgithub.exe start // 以windows服务安装并启动 fastgithub.exe stop // 以windows服务卸载并删除 2.3 linux-x64终端 sudo ./fastgithub 设置系统自动代理为http://127.0.0.1:38457，或手动代理http/https为127.0.0.1:38457 2.4 linux-x64服务 sudo ./fastgithub start // 以systemd服务安装并启动 sudo ./fastgithub stop // 以systemd服务卸载并删除 设置系统自动代理为http://127.0.0.1:38457，或手动代理http/https为127.0.0.1:38457 2.5 macOS-x64 双击运行fastgithub 安装cacert/fastgithub.cer并设置信任 设置系统自动代理为http://127.0.0.1:38457，或手动代理http/https为127.0.0.1:38457 具体配置详情 2.6 docker-compose一键部署 准备好docker 18.09, docker-compose. 在源码目录下，有一个docker-compose.yaml 文件，专用于在实际项目中，临时使用github.com源码，而做的demo配置。 根据自己的需要更新docker-compose.yaml中的sample和build镜像即可完成拉github.com源码加速，并基于源码做后续的操作。 3 软件功能 提供域名的纯净IP解析； 提供IP测速并选择最快的IP； 提供域名的tls连接自定义配置； google的CDN资源替换，解决大量国外网站无法加载js和css的问题； 4 证书验证4.1 gitgit操作提示SSL certificate problem 需要关闭git的证书验证：git config --global http.sslverify false 4.2 firefoxfirefox提示连接有潜在的安全问题 设置-&gt;隐私与安全-&gt;证书-&gt;查看证书-&gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站” 5 安全性说明FastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。 6 合法性说明《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。 下载文件 这是总的下载链接：https://github.com/dotnetcore/FastGithub/releases/latest 截止到2022年5月6号最新的版本： fastgithub_linux-arm64.zip fastgithub_linux-x64.zip fastgithub_osx-arm64.zip fastgithub_osx-x64.zip fastgithub_win-x64.zip 对于下载慢的可以试着用github文件下载加速网站进行下载，这里推荐几个当前可用的加速下载网站 https://gh.api.99988866.xyz https://ghproxy.com/ https://toolwa.com/github/ 运行解压后的文件，以我的Windows10 64位系统为例 选择任意一个.exe运行程序运行即可 我运行fastgithub.exe的截图 接下来进入github的大门吧 题外话：github被 ‘半墙’是很让人恼火的，有时候PC访问不了，但是移动端又稳定得一批（没改hosts、没开代理）不管怎样，上面有很多很好地项目源码，我们学习离不开它。不过最近github上面开始出现了一些zz因素、传教等等，我们有义务保持理性的态度去面对，也不知道哪一天github也参与zz中来，搞的我们的项目代码不能正常使用。（本人开始试试自己搭建属于自己的git服务了，比如gitlab好像是不错的选择，后期更新看看）","tags":["分享"],"categories":["学习笔记"]},{"title":"Python3爬Bing所有壁纸","path":"//[object Object]/2022/04/27/python3爬bing所有壁纸/","content":"前期工作找bing的每日一图壁纸，观察网页结构 ①是图片的描述 ②是图片的时间 ③是图片的下载地址 ④是当前页面page的页数1和总页数187 编写功能函数捕获不同page网页html信息，用requests库： 1234567891011121314151617181920212223242526272829303132333435# param：页面的相应地址# return：成功则返回相应DOM文档，失败则返回信息msgdef get_response_text(pageNum): msg=&quot;&quot; try: currentSite = mainSite + &quot;/?p=&quot; + str(pageNum) respose = requests.get(url=currentSite,headers=myheader) status_code = respose.status_code if 200 &lt;= status_code &lt; 300: msg = &#x27;请求站点操作成功&#x27; return respose.text elif status_code == 401: msg = &#x27;请求站点匿名用户访问权限资源时的异常&#x27; elif status_code == 403: msg = &#x27;请求站点无访问权限，请联系管理员授予权限&#x27; elif status_code == 404: msg = &#x27;请求站点请求的资源不存在&#x27; elif status_code == 500: msg = &#x27;请求站点请求资源的系统异常，请稍后重试&#x27; else: msg = &#x27;请求站点未知返回代码&#x27; except requests.exceptions.ConnectionError as e: print(&quot;连接错误，请求站点是否可以访问？是否有网络或网络不稳定？ 请检查网络问题... &quot;+e) time.sleep(10) except requests.exceptions.InvalidURL as e: print(&quot;非法的URL，请验证URL是否正确或网站是否存在 &quot;+e) except requests.exceptions.ReadTimeout: print(&quot;请求站点远程服务器无响应数据&quot;) time.sleep(10) except: print(&quot;请求站点遇到未知错误...&quot;) time.sleep(10) finally: print(msg) return msg 返回当前page所有的图片信息 12345678910111213141516171819#根据不同页面返回图片的信息def get_PicUrlList(pageNum): url_list = [] mainText = get_response_text(pageNum) #正则规则 rule = re.compile(r&#x27;class=&quot;description&quot;&gt;&lt;h3&gt;(.*?) \\(©.*?&lt;em class=&quot;t&quot;&gt;(.*?)&lt;/em&gt;.*?class=\\&quot;ctrl download\\&quot; href=\\&quot;(.*?)\\&quot; target&#x27;) result_groups = re.findall(rule,mainText) #由网页结构可知：匹配结果i[0]、i[1]、i[2]分别代表图片的描述、图片的时间、图片的下载地址 if result_groups: for i in result_groups: img_info=&#123; &#x27;description&#x27;:i[0], &#x27;time&#x27;:i[1], &#x27;url&#x27;:mainSite+i[2] &#125; url_list.append(img_info) else: print(&quot;No match!!&quot;) return url_list 下载函数，用shell的wget，下载速度更快更稳定 123456789101112def downloadPic(img_info): global success,fail try: #利用Shell下载图片 os.system(&quot;sudo wget &quot;+img_info[&#x27;url&#x27;]+&quot; -q -O /mnt/c/Users/86199/OneDrive/图片/&quot;+img_info[&#x27;description&#x27;]+img_info[&#x27;time&#x27;]+&#x27;.jpg&#x27;) success.append(img_info) print(img_info[&#x27;description&#x27;]+img_info[&#x27;time&#x27;]+&#x27;.png&#x27;, &#x27;保存成功!&#x27;) #每隔一分钟下载一张 #time.sleep(60) except: fail.append(img_info) print(&quot;something wrong! &quot;) 增加一个程序退出时执行函数，把下载信息写入 123456@atexit.registerdef write_info(): with open(&#x27;info.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as file: file.write(&quot;fail:&quot;+str(fail)+(&quot; &quot;)+ &quot;total:&quot; + str(len(fail)) +&quot;success:&quot;+str(success)+(&quot; &quot;)+ &quot;total:&quot; + str(len(success)) +&quot;current-page:&quot;+str(currentPage)) 主运行功能函数 12345678910111213def main_run(): global completeCount,failCount,currentPage, totalPage for i in range(totalPage): url_list = get_PicUrlList(currentPage) for img_info in url_list: print(&quot;正在下载：&quot;+img_info[&#x27;description&#x27;]+&quot;\\t图片&quot;) downloadPic(img_info) print(&#x27;page:&#x27; + str(currentPage) + &#x27;complete&#x27;) currentPage += 1 with open(&#x27;info.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as file: file.write(&quot;fail:&quot;+str(fail)+(&quot; &quot;)+ &quot;total:&quot; + str(len(fail)) +&quot;success:&quot;+str(success)+(&quot; &quot;)+ &quot;total:&quot; + str(len(success)) +&quot;current-page:&quot;+str(currentPage)) 总文件main.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import osimport randomimport reimport timeimport requestsimport atexittotalPage = 187 #网站的总页数currentPage = 1 #当前爬取图片的页数myheader = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27; &#x27;Chrome/99.0.4844.74 Safari/537.36 Edg/99.0.1150.46 &#x27; &#125;statusCode = 0 #爬取时返回的HTTP状态码mainSite = &quot;https://bing.ioliu.cn&quot; #要爬的网页pic_url_list = [] #图片的下载地址fail=[] #下载失败的urlsuccess=[] #下载成功的url# param：页面的相应地址# return：成功直接返回相应DOM文档，失败返回 &quot;什么也没有&quot;def get_response_text(pageNum): msg=&quot;&quot; try: currentSite = mainSite + &quot;/?p=&quot; + str(pageNum) respose = requests.get(url=currentSite,headers=myheader) status_code = respose.status_code if 200 &lt;= status_code &lt; 300: msg = &#x27;请求站点操作成功&#x27; elif status_code == 401: msg = &#x27;请求站点匿名用户访问权限资源时的异常&#x27; elif status_code == 403: msg = &#x27;请求站点无访问权限，请联系管理员授予权限&#x27; elif status_code == 404: msg = &#x27;请求站点请求的资源不存在&#x27; elif status_code == 500: msg = &#x27;请求站点请求资源的系统异常，请稍后重试&#x27; else: msg = &#x27;请求站点未知返回代码&#x27; except requests.exceptions.ConnectionError as e: print(&quot;连接错误，请求站点是否可以访问？是否有网络或网络不稳定？ 请检查网络问题... &quot;+e) time.sleep(10) except requests.exceptions.InvalidURL as e: print(&quot;非法的URL，请验证URL是否正确或网站是否存在 &quot;+e) except requests.exceptions.ReadTimeout: print(&quot;请求站点远程服务器无响应数据&quot;) time.sleep(10) except: print(&quot;请求站点遇到未知错误...&quot;) time.sleep(10) finally: print(msg) return respose.text def get_PicUrlList(pageNum): url_list = [] mainText = get_response_text(pageNum) rule = re.compile(r&#x27;class=&quot;description&quot;&gt;&lt;h3&gt;(.*?) \\(©.*?&lt;em class=&quot;t&quot;&gt;(.*?)&lt;/em&gt;.*?class=\\&quot;ctrl download\\&quot; href=\\&quot;(.*?)\\&quot; target&#x27;) result_groups = re.findall(rule,mainText) if result_groups: for i in result_groups: img_info=&#123; &#x27;description&#x27;:i[0], &#x27;time&#x27;:i[1], &#x27;url&#x27;:mainSite+i[2] &#125; url_list.append(img_info) else: print(&quot;No match!!&quot;) return url_listdef downloadPic(img_info): global success,fail try: #利用Shell下载图片 os.system(&quot;sudo wget &quot;+img_info[&#x27;url&#x27;]+&quot; -q -O /mnt/c/Users/86199/OneDrive/图片/&quot;+img_info[&#x27;description&#x27;]+img_info[&#x27;time&#x27;]+&#x27;.jpg&#x27;) success.append(img_info) print(img_info[&#x27;description&#x27;]+img_info[&#x27;time&#x27;]+&#x27;.png&#x27;, &#x27;保存成功!&#x27;) #每隔一分钟下载一张 # time.sleep(60) except: fail.append(img_info) print(&quot;something wrong! &quot;)def main_run(): global completeCount,failCount,currentPage, totalPage for i in range(totalPage): url_list = get_PicUrlList(currentPage) for img_info in url_list: print(&quot;正在下载：&quot;+img_info[&#x27;description&#x27;]+&quot;\\t图片&quot;) downloadPic(img_info) print(&#x27;page:&#x27; + str(currentPage) + &#x27;complete&#x27;) currentPage += 1 with open(&#x27;info.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as file: file.write(&quot;fail:&quot;+str(fail)+(&quot; &quot;)+ &quot;total:&quot; + str(len(fail)) +&quot;success:&quot;+str(success)+(&quot; &quot;)+ &quot;total:&quot; + str(len(success)) +&quot;current-page:&quot;+str(currentPage))@atexit.registerdef write_info(): with open(&#x27;info.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as file: file.write(&quot;fail:&quot;+str(fail)+(&quot; &quot;)+ &quot;total:&quot; + str(len(fail)) +&quot;success:&quot;+str(success)+(&quot; &quot;)+ &quot;total:&quot; + str(len(success)) +&quot;current-page:&quot;+str(currentPage))if __name__== &quot;__main__&quot;: main_run() linux下挂起后台开跑1sudo nohup python3 main.py &gt; run.out 2&gt;&amp;1 &amp; 测试结果 info.txt: 注意事项在下载图片的那个功能函数里，需要根据自己的主机修改下载目录， 最好每下载一张就歇一会，我不知道网站有没有反爬，一直下载可能会被识别到时候IP被禁了就不好了。 源站有流量限制，本身下载就很慢（估计很多人都拿来爬。。。），如果没看到结果先自己用自己的电脑下载看能不能下 相关教程atexit — 退出处理器 — Python 3.10.4 文档 atexit模块定义了清理函数的注册和反注册函数. 被注册的函数会在解释器正常终止时执行. atexit会按照注册顺序的_逆序_执行; 如果你注册了 A, B 和 C, 那么在解释器终止时会依序执行 C, B, A. 注意: 通过该模块注册的函数, 在程序被未被 Python 捕获的信号杀死时并不会执行, 在检测到 Python 内部致命错误以及调用了os._exit() 时也不会执行. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162用法： wget [选项]... [URL]... 长选项所必须的参数在使用短选项时也是必须的。 启动： -V, --version 显示 Wget 的版本信息并退出。 -h, --help 打印此帮助。 -b, --background 启动后转入后台。 -e, --execute=COMMAND 运行一个“.wgetrc”风格的命令。 日志和输入文件： -o, --output-file=FILE 将日志信息写入 FILE。 -a, --append-output=FILE 将信息添加至 FILE。 -d, --debug 打印大量调试信息。 -q, --quiet 安静模式 (无信息输出)。 -v, --verbose 详尽的输出 (此为默认值)。 -nv, --no-verbose 关闭详尽输出，但不进入安静模式。 --report-speed=TYPE Output bandwidth as TYPE. TYPE can be bits. -i, --input-file=FILE 下载本地或外部 FILE 中的 URLs。 -F, --force-html 把输入文件当成 HTML 文件。 -B, --base=URL 解析与 URL 相关的 HTML 输入文件 (由 -i -F 选项指定)。 --config=FILE Specify config file to use. 下载： -t, --tries=NUMBER 设置重试次数为 NUMBER (0 代表无限制)。 --retry-connrefused 即使拒绝连接也是重试。 -O, --output-document=FILE 将文档写入 FILE。 -nc, --no-clobber skip downloads that would download to existing files (overwriting them). -c, --continue 断点续传下载文件。 --progress=TYPE 选择进度条类型。 -N, --timestamping 只获取比本地文件新的文件。 --no-use-server-timestamps 不用服务器上的时间戳来设置本地文件。 -S, --server-response 打印服务器响应。 --spider 不下载任何文件。 -T, --timeout=SECONDS 将所有超时设为 SECONDS 秒。 --dns-timeout=SECS 设置 DNS 查寻超时为 SECS 秒。 --connect-timeout=SECS 设置连接超时为 SECS 秒。 --read-timeout=SECS 设置读取超时为 SECS 秒。 -w, --wait=SECONDS 等待间隔为 SECONDS 秒。 --waitretry=SECONDS 在获取文件的重试期间等待 1..SECONDS 秒。 --random-wait 获取多个文件时，每次随机等待间隔 0.5*WAIT...1.5*WAIT 秒。 --no-proxy 禁止使用代理。 -Q, --quota=NUMBER 设置获取配额为 NUMBER 字节。 --bind-address=ADDRESS 绑定至本地主机上的 ADDRESS (主机名或是 IP)。 --limit-rate=RATE 限制下载速率为 RATE。 --no-dns-cache 关闭 DNS 查寻缓存。 --restrict-file-names=OS 限定文件名中的字符为 OS 允许的字符。 --ignore-case 匹配文件/目录时忽略大小写。 -4, --inet4-only 仅连接至 IPv4 地址。 -6, --inet6-only 仅连接至 IPv6 地址。 --prefer-family=FAMILY 首先连接至指定协议的地址 FAMILY 为 IPv6，IPv4 或是 none。 --user=USER 将 ftp 和 http 的用户名均设置为 USER。 --password=PASS 将 ftp 和 http 的密码均设置为 PASS。 --ask-password 提示输入密码。 --no-iri 关闭 IRI 支持。 --local-encoding=ENC IRI (国际化资源标识符) 使用 ENC 作为本地编码。 --remote-encoding=ENC 使用 ENC 作为默认远程编码。 --unlink remove file before clobber. 目录： -nd, --no-directories 不创建目录。 -x, --force-directories 强制创建目录。 -nH, --no-host-directories 不要创建主目录。 --protocol-directories 在目录中使用协议名称。 -P, --directory-prefix=PREFIX 以 PREFIX/... 保存文件 --cut-dirs=NUMBER 忽略远程目录中 NUMBER 个目录层。 HTTP 选项： --http-user=USER 设置 http 用户名为 USER。 --http-password=PASS 设置 http 密码为 PASS。 --no-cache 不在服务器上缓存数据。 --default-page=NAME 改变默认页 (默认页通常是“index.html”)。 -E, --adjust-extension 以合适的扩展名保存 HTML/CSS 文档。 --ignore-length 忽略头部的‘Content-Length’区域。 --header=STRING 在头部插入 STRING。 --max-redirect 每页所允许的最大重定向。 --proxy-user=USER 使用 USER 作为代理用户名。 --proxy-password=PASS 使用 PASS 作为代理密码。 --referer=URL 在 HTTP 请求头包含‘Referer: URL’。 --save-headers 将 HTTP 头保存至文件。 -U, --user-agent=AGENT 标识为 AGENT 而不是 Wget/VERSION。 --no-http-keep-alive 禁用 HTTP keep-alive (永久连接)。 --no-cookies 不使用 cookies。 --load-cookies=FILE 会话开始前从 FILE 中载入 cookies。 --save-cookies=FILE 会话结束后保存 cookies 至 FILE。 --keep-session-cookies 载入并保存会话 (非永久) cookies。 --post-data=STRING 使用 POST 方式；把 STRING 作为数据发送。 --post-file=FILE 使用 POST 方式；发送 FILE 内容。 --content-disposition 当选中本地文件名时 允许 Content-Disposition 头部 (尚在实验)。 --content-on-error output the received content on server errors. --auth-no-challenge 发送不含服务器询问的首次等待 的基本 HTTP 验证信息。 HTTPS (SSL/TLS) 选项： --secure-protocol=PR choose secure protocol, one of auto, SSLv2, SSLv3, TLSv1, TLSv1_1 and TLSv1_2. --no-check-certificate 不要验证服务器的证书。 --certificate=FILE 客户端证书文件。 --certificate-type=TYPE 客户端证书类型，PEM 或 DER。 --private-key=FILE 私钥文件。 --private-key-type=TYPE 私钥文件类型，PEM 或 DER。 --ca-certificate=FILE 带有一组 CA 认证的文件。 --ca-directory=DIR 保存 CA 认证的哈希列表的目录。 --random-file=FILE 带有生成 SSL PRNG 的随机数据的文件。 --egd-file=FILE 用于命名带有随机数据的 EGD 套接字的文件。 FTP 选项： --ftp-user=USER 设置 ftp 用户名为 USER。 --ftp-password=PASS 设置 ftp 密码为 PASS。 --no-remove-listing 不要删除‘.listing’文件。 --no-glob 不在 FTP 文件名中使用通配符展开。 --no-passive-ftp 禁用“passive”传输模式。 --preserve-permissions 保留远程文件的权限。 --retr-symlinks 递归目录时，获取链接的文件 (而非目录)。 WARC options: --warc-file=FILENAME save request/response data to a .warc.gz file. --warc-header=STRING insert STRING into the warcinfo record. --warc-max-size=NUMBER set maximum size of WARC files to NUMBER. --warc-cdx write CDX index files. --warc-dedup=FILENAME do not store records listed in this CDX file. --no-warc-compression do not compress WARC files with GZIP. --no-warc-digests do not calculate SHA1 digests. --no-warc-keep-log do not store the log file in a WARC record. --warc-tempdir=DIRECTORY location for temporary files created by the WARC writer. 递归下载： -r, --recursive 指定递归下载。 -l, --level=NUMBER 最大递归深度 (inf 或 0 代表无限制，即全部下载)。 --delete-after 下载完成后删除本地文件。 -k, --convert-links 让下载得到的 HTML 或 CSS 中的链接指向本地文件。 --backups=N before writing file X, rotate up to N backup files. -K, --backup-converted 在转换文件 X 前先将它备份为 X.orig。 -m, --mirror -N -r -l inf --no-remove-listing 的缩写形式。 -p, --page-requisites 下载所有用于显示 HTML 页面的图片之类的元素。 --strict-comments 用严格方式 (SGML) 处理 HTML 注释。 递归接受/拒绝： -A, --accept=LIST 逗号分隔的可接受的扩展名列表。 -R, --reject=LIST 逗号分隔的要拒绝的扩展名列表。 --accept-regex=REGEX regex matching accepted URLs. --reject-regex=REGEX regex matching rejected URLs. --regex-type=TYPE regex type (posixpcre). -D, --domains=LIST 逗号分隔的可接受的域列表。 --exclude-domains=LIST 逗号分隔的要拒绝的域列表。 --follow-ftp 跟踪 HTML 文档中的 FTP 链接。 --follow-tags=LIST 逗号分隔的跟踪的 HTML 标识列表。 --ignore-tags=LIST 逗号分隔的忽略的 HTML 标识列表。 -H, --span-hosts 递归时转向外部主机。 -L, --relative 只跟踪有关系的链接。 -I, --include-directories=LIST 允许目录的列表。 --trust-server-names use the name specified by the redirection url last component. -X, --exclude-directories=LIST 排除目录的列表。 -np, --no-parent 不追溯至父目录。","tags":["Linux","Python"],"categories":["学习笔记","文章"]},{"title":"优雅地使用WSL2","path":"//[object Object]/2022/04/24/优雅地使用WSL2/","content":"记录一次安装WSL 2的过程… 什么是WSL2WSL全称为Windows Subsystem for Linux，官网译为：适用于 Linux 的 Windows 子系统 (WSL)。 官方文档直达：适用于 Linux 的 Windows 子系统文档 | Microsoft Docs WSL1和WSL2的比较: 功能 WSL 1 WSL 2 Windows 和 Linux 之间的集成 ✅ ✅ 启动时间短 ✅ ✅ 与传统虚拟机相比，占用的资源量少 ✅ ✅ 可以与当前版本的 VMware 和 VirtualBox 一起运行 ✅ ✅ 托管 VM ❌ ✅ 完整的 Linux 内核 ❌ ✅ 完全的系统调用兼容性 ❌ ✅ 跨 OS 文件系统的性能 ✅ ❌ 为什么要WSL2官方解释：可让开发人员直接在 Windows 上按原样运行 GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。 我的观点：日常生活中程序的开发离不开Linux，而Windows的GUI界面又是我们常用的（微信、Office等）。我们可以有很多种方式使用Linux，如： 方案 优点 缺点 单主机双系统 能实实在的运行不同、完整的操作系统 切换系统都需要重启，麻烦 双主机双系统 物理隔离方式，真正实现双系统 真的有人那么有钱吗？开发程序用两台电脑？如果有，请问土豪缺朋友吗😁 远程服务器 和单主机双系统一样 性能、带宽、流量有局限 虚拟机VMware 和单主机双系统一样 资源消耗大、启动慢、运行效率低。我用过之后觉得有的时候卡死也不知道怎么弄。。 WSL！！！ 几乎能运行完整的操作系统，资源消耗小、启动快、切换快 有些软件可能不支持…（后续有什么毛病再更新） 重点：Windows与Linux子系统将共用同一文件系统!!!! 我们可以在WSL中使用三剑客命令查询分析windows文档、日志、使用shell命令或者bash脚本运行存储在windows中的linux程序、甚至在WSL中创建docker容器，在windows下使用docker desktop进行可视化管理。 总结：WSL2让我们既拥有Windows的操作界面又拥有Linux的命令行工具。 启用“虚拟机平台”WSL 2 需要启用 Windows 10 的 “虚拟机平台” 特性。它独立于 Hyper-V，并提供了一些在 Linux 的 Windows 子系统新版本中可用的更有趣的平台集成。 要在 Windows 10（2004）上启用虚拟机平台，请以管理员身份打开 PowerShell 或 cmd 并运行： 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 要在 Windows 10（1903，1909）上启用虚拟机平台，请以管理员身份打开 PowerShell或 cmd 并运行： 1Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart 为了确保所有相关部件都整齐到位，您应该在此时重启系统，否则可能会发现事情没按预期进行。 安装WSL2本次安装环境 处理器 Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz 2.11 GHz机带 RAM 8.00 GB (7.79 GB 可用)系统类型 64 位操作系统, 基于 x64 的处理器操作系统 Windows 10 家庭中文版 注意：本次安装之前没安装过WSL和Ubuntu，只运行过VMware虚拟机。 检查是否可以安装您的电脑需要以下配置： Windows 10 2020年5月(2004) 版, Windows 10 2019年5月(1903) 版，或者 Windows 10 2019年11月(1909) 版 一台支持 Hyper-V 虚拟化的计算机 查看是否支持Hyper-V的方法： 打开cmd，输入 1systeminfo 查看Hyper-V信息 比如我的电脑就可以支持 安装WSL用管理员身份运行PowerShell 1wsl --install –install 命令执行以下操作： 启用可选的 WSL 和虚拟机平台组件 下载并安装最新 Linux 内核 将 WSL 2 设置为默认值 下载并安装 Ubuntu Linux 发行版（可能需要重新启动） 注意： 上述命令仅在完全未安装 WSL 时才有效，如果运行 wsl --install 并查看 WSL 帮助文本，请尝试运行 wsl --list --online 以查看可用发行版列表并运行 wsl --install -d &lt;DistroName&gt; 以安装发行版。 等待一会会，去打局游戏再回来…. 顺便查看了一下可以支持的linux系统，大便、Kali、OpenSUSE、乌班图都有，默认安装Ubuntu。 1wsl --list --online 安装了好一会儿了。。。。发现还是在85.7%，等不下去了CTRL+C了。 重新安装，这次安装指定的系统 1wsl --install -d Ubuntu-20.04 重启，然后成功了! 配置Linux接下来打开已安装的Ubuntu，这时候会提示你配置用户和密码 配置完毕！即可享用 测试一下，用命令 cd / &amp;&amp; ls -la 查看所有文件，如下（是不是很熟悉） 更新一下镜像源： 1sudo vim /etc/apt/sources.list 将官方的源都注释掉，换成下面两个之一即可（我的是Ubuntu20.04，别的版本或者源可以自行网上搜） 阿里源 12345678910deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src https://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 清华源 12345678deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse Debian系统分好几种，wheezy、jessie、stretch、buster，它们分别对应： Debian版本 对应名称 Debian7 wheezy Debian8 jessie Debian9 stretch Debian10 buster Debian11 bullseye Debian 11（Bullseye）国内镜像源： 阿里 12345678deb https://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb https://mirrors.aliyun.com/debian-security/ bullseye-security maindeb-src https://mirrors.aliyun.com/debian-security/ bullseye-security maindeb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contribdeb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib 清华 12345678deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free 遇到问题：Certificate verification failed: The certificate is NOT trusted——更新Ubuntu20.04、Debian11的过程中遇到的证书验证失败问题。 解决办法： 更改源文件，将所有的https改成http 1sudo nano /etc/apt/sources.list 重新更新源 1sudo apt update 安装/更新证书ca-certificates 1sudo apt install --reinstall ca-certificates 参照步骤一将镜像源文件改回https 再次更新源 1sudo apt update &amp;&amp; sudo apt upgrade 大功告成 安装Windows TerminalWindows Terminal能帮助我们管理命令行工具、PowerShell和WSL等Shell用户的工具，能为我们提供最佳的 WSL 体验。 下载方式 https://www.microsoft.com/store/productId/9N0DX20HK701 MicroSoft Store （微软商店）找关键字 Windows Terminal 下载安装即可。功能确实很多哈哈哈，效果： 遇到的问题：过程中下载失败了好多次我不断点击重新下载才成功。 查看Linux版本信息 cat /etc/os-release cat /proc/version uname -a lsb_release -a neofetch 总结刚安装了还不知道怎么样，看网上的说法褒贬不一，我也在不断尝试，后续再更，说说感受。 参考： Winux之路-WSL 2的使用及填坑 - 知乎 (zhihu.com) 适用于 Linux 的 Windows 子系统文档 | Microsoft Docs","tags":["Linux","Windows"],"categories":["学习笔记","工具"]},{"title":"Untitled Post - 2","path":"//[object Object]/2022/04/20/1002/","content":"当你向程序员请教由他写的代码的问题时，千万不要直接说你这代码有bug，因为他会想：我的代码怎么可能有问题？（别问为什么会这么说，程序员的职业病）从而影响他回答你问题的心情和态度（我写的怎么会出现bug，肯定是你不对还来赖我写的代码。 而这时候最好的方式是问他：你这代码怎么run不起来啊？这时候他就会主动想怎么跑不起来？是不是我写的代码有bug了？从而他更愿意来帮你解决问题。 有时候换种说话方式有时候会有奇效哦~","tags":["感悟","生活"],"categories":["思想感悟","生活点滴"]},{"title":"Python脚本自动更新PIP源","path":"//[object Object]/2022/04/18/python脚本自动更新pip源/","content":"默认的pip源都在国外服务器上，下载速度慢，为了提高下载包的速度，每次都需要加上国内镜像源镜像，或者自己加上个pip配置文件，Linux为pip.conf，Windows为pip.ini。因此可以使用一个python脚本自动帮我们配置好。 其中配置文件的格式都为： 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/[install]trusted-host=pypi.tuna.tsinghua.edu.cn 源码 pipupdate.py: 1234567891011121314151617181920212223242526272829#!/usr/bin/python# coding: utf-8import platformimport osos_type = platform.system()if &quot;Linux&quot; == os_type: fileDirPath = &quot;%s/.pip&quot; % os.path.expanduser(&#x27;~&#x27;) filePath = &quot;%s/pip.conf&quot; % fileDirPath if not os.path.isdir(fileDirPath): os.mkdir(fileDirPath) fo = open(filePath, &quot;w&quot;) fo.write( &quot;[global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple/ [install] trusted-host=pypi.tuna.tsinghua.edu.cn &quot;) fo.close() print(&quot;Configuration is complete&quot;)elif &quot;Windows&quot; == os_type: fileDirPath = &quot;%s\\\\pip&quot; % os.path.expanduser(&#x27;~&#x27;) filePath = &quot;%s\\\\pip.ini&quot; % fileDirPath if not os.path.isdir(fileDirPath): os.mkdir(fileDirPath) fo = open(filePath, &quot;w&quot;) fo.write( &quot;[global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple/ [install] trusted-host=pypi.tuna.tsinghua.edu.cn &quot;) fo.close() print(&quot;Configuration is complete&quot;)else: exit(&quot;Your platform is unknow!&quot;) 上述例子以清华大学镜像源为例，其中还可以将index-url和trusted-host换成别的镜像源 国内几个镜像源： 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 直接运行源代码即可完成配置 此外，如果pip版本&gt;=10.0.0，可以使用如下命令进行设置： 12pip config set global.trusted-host mirrors.aliyun.compip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ Referenceshttps://www.cnblogs.com/sunnydou/p/5801760.html","tags":["Python"],"categories":["学习笔记"]},{"title":"Linux学习笔记","path":"//[object Object]/2022/04/17/linux学习/","content":"整理了一下学习Linux命令的笔记，特发此文，后续继续更新。 在初学Linux时推荐两种方法： 去相关社区、在线查询网站学习交流，我推荐两个： Linux工具快速教程 — Linux Tools Quick Tutorial (linuxtools-rst.readthedocs.io) Linux命令大全(手册) – 真正好用的Linux命令在线查询网站 (linuxcool.com) 使用man 命令 查看帮助文档 Shell echo输出字符串或提取Shell变量的值 $变量 ：提取变量的值 echo $PATH ：提取PATH环境变量并输出 $?：提取最近一次Shell命令的返回值（退出状态） 0表示没有错误，其它表示有错误 一般变量Linux下变量无需声明，一般做字符串处理，数值计算时转化为数字 创建或修改变量：变量名=变量值 (中间不能有空格) 显式变量值：echo $变量名 删除变量：unset 变量名 导出变量名：export 变量名 特殊的Shell变量$!:后台运行的最后一个进程的ID号 $@:与$*相同，但是使用时加引号，并在引号中返回每个参数，所有参数分解为包含若干个字符串的数组 $#:传递给脚本或者函数的参数个数 $$:执行本脚本程序的PID值 $*:所有参数组合成的一个字符串 $?:上一条语句的返回值 $0:脚本程序自身的名称(命令行名称) $1、$2、$3:传给脚本或者函数的第一、二、三个参数 编写一个shell脚本： 123456789#!/bin/bashif [ $# -gt 1 ];then echo &quot;\\$0程序名称:$0,\\$1第一个参数是:$1&quot; echo &quot;\\$2第二个参数是:$2,\\$*所有参数组合的字符串:$*&quot;else echo &quot;you need input beyond 2 pram&quot;fiecho &quot;\\$$程序运行的PID值:$$&quot; 分别用./specialshell.sh和source specialshell.sh执行脚本，结果： shell脚本当前目录创建一个test.sh, 加入: 123456#!/bin/bashfor x in apple banna cake fruitsdo echo &quot;I love eat $x&quot; sleep 1done 执行 source test.sh for语句1234for var in listdo statementsdone until语句1234until [expression]do statementsdone if语句123456789if [expression];then statementselif [expression];then statementselse statementsfi while语句1234while expressiondo statementsdone 函数1234function 函数名()&#123; statements&#125; test命令用来做字符串比较、数值比较、文件测试、逻辑操作符。 字符串比较 符号 含义 = 比较两个字符串是否相等。如：test “1” = “2” != 比较两个字符串是否不等 -n 检查字符串长度是否大于0。如：test -n “” -z 检查字符串长度是否等于0 数值比较 符号 含义 -eq 比较两个数值是否相等 -ge 比较前者是否大于等于后者 -le 比较后者是否大于等于前者 -ne 比较两个数值是否不等 -gt 比较前者是否大于后者 -lt 比较前者是否小于后者 文件测试 符号 含义 -d 检查是否是一个目录。如：test -d .inputrc -f 检查是否是一个文件 -e 检查文件名或者目录名是否存在 -r 检查对此文件是否有”读”权限 -s 检查文件长度是否大于0 -w 检查对此文件是否有”写”权限 -x 检查对此文件是否有”执行”权限 逻辑操作 符号 含义 ! 逻辑非（NOT）。如：test ! 1 -lt 2 -a 逻辑与（AND）。如：test 1 -lt 2 -a 2 -gt 3 -o 逻辑或（OR）。如：test 1 -lt 2 -o 2 -lt 3 GCCgcc是多种语言、自由、跨平台的编译器 编译流程GCC将源代码便以为可执行程序的流程 预处理(Preproccessing) 编译(Compilation) 汇编(Assemble) 链接(Linking) 常用参数 -version 查看版本 -v 输出编译的详细信息 -std 指定标准 -o 指定输出文件的名称 -Wall 输出所有警告信息 -c 直将源文件编译为object文件(.o)，而不进行链接，之后可用gcc -o 可执行文件名称 out1.o out2.o out3.o链接为可执行文件 -shared 编译为共享库(*.dll，.so) -S 编译为汇编代码 命令useradd [参数] 用户名新建一个用户 参数 作用 -D 改变新建用户的预设值 -c 添加备注文字 -d 新用户每次登录时所使用的家目录 -e 用户终止日期，格式为YYYY-MM-DD -f 用户过期几日后永久停权。当值为0时用户立即被停权，而值为-1时则关闭此功能，预设值为-1 -g 指定用户对应的用户组 -G 定义此用户为多个不同组的成员 -m 用户目录不存在时自动创建 -M 不建立用户家目录，优先于/etc/login.defs文件设定 -n 取消建立以用户名称为名的群组 -r 建立系统账号 -u 指定用户id 仅仅只是用useradd 用户名这个命令不能创建一个可以登录使用的用户，/home目录下没有对应的用户，也创建不了密码。 需要用useradd -m 用户名创建一个可登录的，可以创建密码的用户。创建后可以在etc目录下的passwd添加这个新用户的相关信息。 添加新用户www： 1[root@www ~]# useradd www 不创建家目录，并且禁止登陆： 1[root@www ~]# useradd -M -s /sbin/nologin www 添加新用户www，指定UID为666，指定shell类型为/bin/bash，指定归属用户组为root，cool成员： 1[root@www ~]# useradd -u 666 -s /bin/bash -G root,cool www 添加新用户www，设置家目录为/tmp/www，用户过期时间为2030/01/01.过期后两天停权： 1[root@www ~]# useradd -e &quot;2030/01/01&quot; -f 2 -d /tmp/www www 此外，新增的用户不具有sudo权限，需要手动在/etc/sudoer增加新用户权限 选项 说明 user ALL=(ALL) ALL 允许用户user执行sudo命令(需要输入密码). %user ALL=(ALL) ALL 允许用户组user里面的用户执行sudo命令(需要输入密码). user ALL=(ALL) NOPASSWD: ALL 允许用户user执行sudo命令,并且在执行的时候不输入密码. %user ALL=(ALL) NOPASSWD: ALL ALL=(ALL)允许用户组user里面的用户执行sudo命令,并且在执行的时候不输入密码. 更多信息查看文档 man useradd usermod [参数] 用户名改变用户的信息。其中参数选项的作用与 useradd 类似。 who产看当前shell用户 id查看当前用户的身份以及权限 makeMakefile 支持多线程并发操作make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译 Makefile 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是依赖的关系和执行的命令 umask [-S] (权限掩码)新建初始化文件的权限掩码 123umask #获取当前权限掩码umask -S #获取当前权限的可读权限信息umask 0000 #修改新建初始化目录文件的权限 666&amp; umask 新建初始化目录的权限 777&amp; umask ls [参数] (正则表达式)文件的分类 普通文件 - , 目录文件 d , （软）链接文件 l , 字符设备文件 c , 块设备文件 b , 管道文件 p 目录不是目录，是一种目录文件 目录 r: 可以ls目录中的内容 w: 可以删除增加目录文件 x: 可以cd进入这个目录 文件 r：read 可读 w：write 可写 x：增删 r：可运行 ls -ld /etc ： 查看目录拥有权限 chmod [选项] [文件或目录]赋予文件或目录权限 chmod u=wx etc ：赋予etc目录 w:增删 和 x:进入 的权限 chmod u-r etc ：删去etc目录 r：可ls 的权限 其中还可以用三位十进制数表示不同权限 r :含义为 “可读”，用数字 4 表示 w:含义为 “可写”用数字 2 表示 x：含义为“可执行”用数字 1 表示 -：含义为“无权限”用数字0 表示 所有者 群组 其他 三位代表权限的数字 rwx rwx rwx 实际结果 421 421 421 777 421 401 401 705 1234chmod 777 a.out #777给auth.log文件赋予任何可读，可写，可执行权限chmod 755 a.out#755代表用户对该文件拥有读，写，执行的权限，同组和其它用户有读和执行权限，没有写权限 which [命令]查看命令的安装路径 mout [参数]挂载文件系统 挂载：是指由操作系统使一个 存储设备 (如硬盘、CD-ROM或共享资源)上的计算机文件或目录可供用户通过计算机的 文件系统 访问的一个过程。 引自——挂载_百度百科 (baidu.com) 当访问挂载点的时候，系统就知道要用哪些数据组织形式访问哪些类型的文件系统(或者说是哪些物理设备)。 作用：将一个具体存储设备上的具体文件系统和操作系统中对应的文件系统驱动(模块)关联起来，并将这个具体文件系统中的文件和目录关系挂载到全局目录树上，形成一个“激活运行状态”的文件系统。 引自——https://www.zhihu.com/answer/2437952746 将/dev/sdb1分区挂载到/wg目录上的命令：mount /dev/sdb1 /wg umount实现文件系统的卸载 卸载/wg上的文件系统的命令：umount /wg export [参数]将shell变量/函数输出为环境变量 -p ：列出所有shell赋予程序的环境变量 -n ：删除指定变量 定义环境变量：# export MYENV 赋值：# export MYENV=1111 fdisk [选项] [设备]操纵磁盘分区表 -l：列出所有分区表 df [参数] [指定文件]显示磁盘空间使用情况 -a ：显示所有系统文件 -h ：以易于human的阅读方式显示 -l ：只显示本地文件 pwd打印当前工作目录(print working directory) source [指定文件]source命令通常用于执行刚修改的 初始化 文件，使之立即生效，不用注销重新登陆？ env查看Shell环境变量 statnetstatnetstat -ant grep 3306 fflushkill [参数]文件/etc/passwd系统用户配置文件，存储了系统中所有用户的基本信息。 权限：所有用户可读 1sudo vim /etc/passwd 名称 说明 用户名 已创建的用户名 加密口令 x代表加密密码保存在/etc/shadow文件中 用户ID 代表用户的ID号，每个用户都有一个唯一的ID 组ID 代表群组的ID好，每个群组都有一个唯一的ID 账号说明 描述用户的信息 主目录 代表用户所在的家目录 登录Shell 代表用户使用Shell的类型 /etc/profile建立全系统通用的初始环境变量，每次用户登录时 第一个 被执行 /etc/fstab系统启动时自动挂载。当系统启动时，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定内目录。 额外禁止root用户禁止root用户登录，并新建一个自己的用户 新建wyz用户（具体查看useradd） 赋予wyz 用户 sudo权限 禁止root登录 $ sudo vim /etc/ssh/sshd_config 将PermitRootLogin yes更改为 no 进程可执行(二进制)程序被系统加载到内存空间运行时，就是 进程。 每个进程都有唯一的标识号—— PID，进程可以产生新的进程，构成父子关系并形成进程树(pstree)。 进程都有一个 用户标识——对应运行此程序的用户ID。如果可执行文件没有设置suid和sgid，则进程的 有效用户标识 为此用户，否则为文件的所有者。 每一个进程属于且仅属于一个 进程组，向进程组发送信号，则组内所有进程都能收到。 每个进程都属于一个唯一的 会话 。用户登录后产生一个会话，会话包含若干进程组。会话的id是首进程组的id。一个会话中只有一个进程组是前台进程组，和控制终端交互，获取输入，接收信号。 控制终端关闭时，进程会收到 SIGHUP 信号。 除了PID为 0 的进程外，所有进程都有父进程。 进程优先级 = 优先级别(PR) + 谦让值(NI)。优先级别从父进程继承而来，不可更改，可以用 nice 将进程默认的谦让值从 0 改大(或改小)。 环境变量全局的环境变量：存放在 /etc/profile 特定用户的环境变量：存放在home目录的 .profile或 .bashhrc中 临时的环境变量：export定义，特定于此会话","tags":["Linux"],"categories":["学习笔记"]},{"title":"设置Wordpress伪静态链接","path":"//[object Object]/2022/04/08/apache2-4设置wordpress伪静态链接/","content":"设置Wordpress伪静态链接Apache2.4 本文是不在使用宝塔的情况下自行设定的, 有安装宝塔的请忽视 环境：Ubuntu20.04 Apache2.4 Wordpress5.9.2 重写规则 开启重写规则 1sudo a2enmod rewrite 设置根目录重定向 1sudo vim /etc/apache2/apache2.conf 找到 &lt;Directory /var/www/&gt; 将AllowOverride 后的 None 修改为 ALL 。 进入Wordpress后台选择自己喜欢的伪静态，并点击保存，自动生成 .hatccess 规则并复制，如下： 123456789RewriteEngine OnRewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;]RewriteBase /RewriteRule ^index\\.php$ - [L]RewriteRule ^^unsubscribe-comment-mailnotice/?(.*)$ //wp-con&gt;RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . /index.php [L] 在刚刚的 /var/www/ 目录下(即网站的根目录) 创建 .hatccess 文件 粘贴刚刚复制的规则代码并保存。 重启服务器即可 1sudo systemctl restart apache2 效果图 Nginx1.19 本文是不在使用宝塔的情况下自行设定的, 有安装宝塔的请忽视 环境：Raspi OS 64bit(Debian11) Wordpress5.9.2 打开配置文件 sudo vim /etc/nginx/sites-available/default 如果wordpress安装在网站根目录，在server中添加 12345location / &#123; if (!-e $request_filename) &#123; rewrite (.*) /index.php; &#125; &#125; 如果wordpress安装在网站二级目录，在server中添加: 12345location /二级目录/ &#123; if (!-e $request_filename) &#123; rewrite (.*) /cn/index.php; &#125; &#125; 重启 sudo /etc/init.d/ngnix restart 在wordpress后台设置伪静态即可","tags":["Apache","WordPress"],"categories":["学习笔记","文章"]},{"title":"树莓派4B+LCD1602, 检测网站访问情况","path":"//[object Object]/2022/04/04/树莓派4b驱动lcd1602-检测网站访问情况/","content":"树莓派4B+LCD1602+Python脚本, 检测网站情况硬件设备 5V 3A电源 树莓派4B 4G内存 液晶显示屏LCD1602 LCD液晶屏转接板 杜邦线 软件设备 镜像系统：2022-01-28-raspios-bullseye-arm64-full(Debian11) 语言：Python3.7 效果图 模块上有一颗可调电阻，用于调节显示的对比度。如果你新拿到一块屏幕无论怎么调试都不见显示，记得调节一下这里 接线1234GND --- GNDVCC --- 接树莓派 5VSDA --- I2C 数据SCL --- I2C 时钟 启动树莓派I2C123sudo apt-get install -y python-smbussudo apt-get install -y i2c-toolssudo raspi-config 重启 sudo reboot 测试1sudo i2cdetect -y 1 如上图说明已成功连接LCD1602。 添加驱动程序 LCD1602.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import timeimport smbusBUS = smbus.SMBus(1)LCD_ADDR = 0x27BLEN = 1def turn_light(key): global BLEN BLEN = key if key ==1: BUS.write_byte(LCD_ADDR, 0x08) else: BUS.write_byte(LCD_ADDR, 0x00)def write_word(addr, data): global BLEN temp = data if BLEN == 1: temp = 0x08 else: temp &amp;=0xF7 BUS.write_byte(addr, temp)def send_command(comm): buf = comm &amp; 0xF0 buf = 0x04 write_word(LCD_ADDR, buf) time.sleep(0.002) buf &amp;=0xFB write_word(LCD_ADDR, buf) # Send bit3-0 secondly buf = (comm &amp; 0x0F) &lt;&lt; 4 buf = 0x04 # RS = 0, RW = 0, EN = 1 write_word(LCD_ADDR ,buf) time.sleep(0.002) buf &amp;= 0xFB # Make EN = 0 write_word(LCD_ADDR ,buf)def send_data(data): # Send bit7-4 firstly buf = data &amp; 0xF0 buf = 0x05 # RS = 1, RW = 0, EN = 1 write_word(LCD_ADDR ,buf) time.sleep(0.002) buf &amp;= 0xFB # Make EN = 0 write_word(LCD_ADDR ,buf) # Send bit3-0 secondly buf = (data &amp; 0x0F) &lt;&lt; 4 buf = 0x05 # RS = 1, RW = 0, EN = 1 write_word(LCD_ADDR ,buf) time.sleep(0.002) buf &amp;= 0xFB # Make EN = 0 write_word(LCD_ADDR ,buf)def init_lcd(): try: send_command(0x33) # Must initialize to 8-line mode at first time.sleep(0.005) send_command(0x32) # Then initialize to 4-line mode time.sleep(0.005) send_command(0x28) # 2 Lines &amp; 5*7 dots time.sleep(0.005) send_command(0x0C) # Enable display without cursor time.sleep(0.005) send_command(0x01) # Clear Screen BUS.write_byte(LCD_ADDR ,0x08) except: return False else: return Truedef clear_lcd(): send_command(0x01) # Clear Screendef print_lcd(x, y, str): if x &lt; 0: x = 0 if x &gt; 15: x = 15 if y &lt;0: y = 0 if y &gt; 1: y = 1 # Move cursor addr = 0x80 + 0x40 * y + x send_command(addr) for chr in str: send_data(ord(chr))if __name__ == &#x27;__main__&#x27;: init_lcd() print_lcd(0, 0, &#x27;Hello, world!&#x27;) 添加自己的运行文件main.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/user/bin/env pythonimport smbusimport timeimport subprocessimport pymysqlfrom sshtunnel import SSHTunnelForwarderimport LCD1602 as LCD#获取网站访问数据def getVisit(): ssh_host = &quot;ip&quot; # 你的ip地址或主机名 ssh_port = 22 # 连接mysql服务器的端口号，一般都是22，必须是数字 ssh_user = &quot;user&quot; # 这是你的用户名 ssh_password = &quot;password&quot; # 这是你的用户密码 mysql_host = &quot;127.0.0.1&quot; # 这是你mysql服务器的主机名或ip地址 mysql_port = 3306 # 这是你mysql服务器上的端口，3306，mysql就是3306，必须是数字 mysql_user = &quot;root&quot; # 这是你mysql数据库上的用户名 mysql_password = &quot;password&quot; # 这是你mysql数据库的密码 mysql_db = &quot;wordpress&quot; # mysql服务器上的数据库名# 严格缩进要求，否则连接失败 with SSHTunnelForwarder( (ssh_host, ssh_port), ssh_username=ssh_user, ssh_password=ssh_password, remote_bind_address=(mysql_host, mysql_port)) as server: conn = pymysql.connect(host=mysql_host, port=server.local_bind_port, user=mysql_user, passwd=mysql_password, db=mysql_db) cursor = conn.cursor() cursor.execute(&quot;select * from wp_statistics_visit where last_counter=\\&quot;&quot; + time.strftime(&quot;%Y-%m-%d&quot;, time.localtime(time.time()))+&quot;\\&quot;&quot;) data = cursor.fetchall() for row in data: visit = row[3] cursor.execute(&quot;select * from wp_statistics_visitor where last_counter=\\&quot;&quot; + time.strftime(&quot;%Y-%m-%d&quot;, time.localtime(time.time()))+&quot;\\&quot;&quot;) data2 = cursor.fetchall() temp = 0 last = &quot;&quot; for row in data2: if row[0]&gt;temp: temp = row[0] last = row[7] cursor.execute(&quot;select * from wp_statistics_useronline&quot;) data3 = cursor.fetchall() onlineNum = 0 platform = &quot;&quot; if data3 !=pymysql.NULL: for row in data3: onlineNum+=1 platform=row[7] conn.commit() server.close() cursor.close() if conn != pymysql.NULL: print(&quot;conn is connect&quot;) return visit,last, onlineNum, platformif __name__ == &quot;__main__&quot;: LCD.init_lcd() LCD.turn_light(1) LCD.print_lcd(0, 0, &quot; Hello&quot;) LCD.print_lcd(0, 1, &quot;Raspberry Pi&quot;) time.sleep(5) while True: now = time.strftime(&quot;%m-%d %H:%M&quot;, time.localtime(time.time())) siteData = getVisit() LCD.clear_lcd() LCD.print_lcd(0, 0, &#x27;TIME:&#x27;+now)#显示当前时间 LCD.print_lcd(0, 1, &#x27;ONLINE:&#x27;+str(siteData[2])+&quot; &quot;+siteData[3]) time.sleep(5) LCD.clear_lcd() LCD.print_lcd(0, 0, &#x27;VISIT:&#x27;+str(siteData[0])+&quot; LAST:&quot;) LCD.print_lcd(0, 1, siteData[1]) time.sleep(5) 其中 LCD.print_lcd() 用来显示字符，前两个参数分别表示 X、Y 坐标（从 0 开始），后面的内容将从这个坐标的位置开始显示。第三个参数就是要显示的内容了。 LCD.turn_light(0) 表示关闭背光，LCD.turn_light(1) 表示打开背光。 最后运行程序（LCD1602.py和main.py要在同一个模块） 1sudo python3 main.py [video width=”476” height=”1280” mp4=”https://wangwangyz.site/wp-content/uploads/2022/04/树莓派测试视频.mp4&quot;\\]\\[/video\\] References树莓派通过 I2C 驱动 LCD1602 液晶屏 树莓派实验室 (nxez.com)","tags":["Linux","树莓派"],"categories":["学习笔记","文章"]},{"title":"解决Wordpress博客头像显示问题","path":"//[object Object]/2022/04/04/解决博客头像无法显示问题/","content":"每次给别人回复的时候头像只能是邮箱的哈希值颜色以及昵称第一个字。这是由于WordPress 用的是 Gravatar 头像，在国内访问慢甚至访问不了。比如这个瑶瑶（狗头保命） 所以这时候我们就需要Gravatar CDN服务。但是Argon主题给的Gravatar CDN都不太行，没事那就自己配置。这里我用的gravatar.loli.net(亲测有效) 打开 WordPress 目录 wp-includes/link-template.php。 查找 secure.gravatar.com 替换 gravatar.loli.net, 保存即可 查看效果，发现这时候已经可以访问到Gravatar了, 速度很快 分割线1 此外，如果我们没有在Gravatar上配置我们的站点头像，我们也还是使用不了评论头像。如果我们希望我们站点的头像使用的是自己的QQ头像或者别的图片，则可以这样配置（以配置qq头像为例）: 打开Argon主题选项的评论者QQ头像。 打开主题文件functions.php,在最后添加自己的qq邮箱头像。 1234567// //修改默认头像add_filter(&#x27;avatar_defaults&#x27;, &#x27;default_avatar&#x27;);function default_avatar($avatar_defaults) &#123;$myavatar = &#x27;https://q1.qlogo.cn/g?b=qq&amp;nk=你的QQ号&amp;s=640&#x27;;//图文url路径，也可以更换为其他的$avatar_defaults[$myavatar] = &quot;图片描述&quot;;//图片的描述名称return $avatar_defaults;&#125; 保存，来到设置的讨论这里，发现添加上了。然后选择自定义的那个默认头像，保存（这里没显示，但是讨论页面是正常访问） 效果, 可以看到头像链接已经指向QQ头像链接了。 分割线2 Argon主题输入QQ邮箱后依然不能访问QQ头像问题 继续打开主题文件functions.php，按住CTRL + F 查找 $_POST[&#39;qq&#39;] 把目光转移到这里。 在$_POST[&#39;qq&#39;]后面我们给他替换为$_POST[&#39;email&#39;]。 无论用户输入的邮箱是qq还是gmail或者是189等邮箱，在这里都会强制使用QQ号作为头像。（看个人需求配置） 此时，当用户在评论页面输入QQ邮箱就能正确获取QQ头像了","tags":["WordPress","Argon"],"categories":["学习笔记","文章"]},{"title":"解决Argon主题预览时只能点击标题进入文章","path":"//[object Object]/2022/04/04/解决argon主题预览时只能点击标题进入文章/","content":"找到自己相对应文章列表卡片布局。比如我的为布局1 进入不同的preview.php文件。 找到 class=”post-content”, 在后面添加：1onclick=&quot;window.location.href=&#x27;&lt;?php the_permalink(); ?&gt;&#x27;&quot; style=&quot;cursor: pointer&quot;","tags":["html","Argon"],"categories":["学习笔记","文章"]},{"title":"杂","path":"//[object Object]/2022/03/28/813/","content":"一般人欢喜谈玄，你说烦恼，他便从“哲学辞典”里拖出“厌世主义”、“悲观哲学”等等堂哉皇哉的字样来叙你的病由。我不知道你感觉如何。我自己从前仿佛也尝过烦恼的况味，我只觉得忧来无方，不但人莫之知，连我自己也莫名其妙，哪里有所谓哲学与人生观。 青年人比老年人易于发愁些，因为青年人的生机比较强旺。小孩子们的生机也很强旺，然而不知道愁苦，因为他们时时刻刻地游戏，所以他们的生机不至于被抑郁。小孩子们偶尔不很乐意，便放声大哭，哭过了气就消去。成人们感觉烦恼时也还要拘礼节，哪能由你放声大哭呢？黄连苦在心头，所以愈觉其苦。 静与闲也不同。许多闲人不必都能领略静中趣味，而能领略静中趣味的人，也不必定要闲。在百忙中，在尘市喧嚷中，你偶然丢开一切，悠然遐想，你心中便蓦然似有一道灵光闪烁，无穷妙悟便源源而来。这就是忙中静趣。 ——朱光潜《给青年的十二封信》","categories":["文学摘录"]},{"title":"数据库设计三大范式","path":"//[object Object]/2022/03/22/数据库设计三大范式/","content":"三大范式1、三大范式1.1 第一范式(1NF)确保每列的原子性，要求每列都是不可再分的最小数据单元。每个单一属性必须由基本的数据类型构成，如整数、字符串。 例如，这张表 编号 姓名 性别 联系电话 地址 1 王大宝 男 199000000 广东省广州市新华路tan90 号 问题：现实生活中每个人都有可能不止一个联系电话，而且地址可再分为省份和城市。不符合1NF 优化： 编号 姓名 性别 个人电话 家庭电话 省份 城市 详细地址 1 王大宝 女 15015246623 663323 广东 广州 新华路tan90 号 1.2 第二范式(2NF)在1NF基础上，要求表中每列都和主键相关，除了主键之外全部列依赖于该主键。 例如，设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键： 订单编号 商品编号 商品名称 数量 单位 商品单价 订单客户 所属单位 联系方式 0001 1 电风扇 5 台 99 王大宝 蓝翔技术 010-10086 问题：商品名称、单位与商品单价与订单编号主键无关，不符合2NF。 优化： 商品表 商品编号 商品名称 单位 商品单价 1 电风扇 台 99 订单项目表 订单编号 商品编号 0001 1 订单信息表 订单编号 订单客户 所属单位 联系方式 0001 王大宝 蓝翔技术 010-100086 1.3 第三范式(3NF)确保每列都和主键列直接相关, 不可包含间接依赖。 例如，这张表： 课程编号 课程名字 上课时间 任课老师 老师电话 老师职位 101 马克思理论基础 8:00 Lily 18016253155 讲师 102 经济学 14:00 Lucy 18055231233 教授 问题：老师电话和老师职位是直接依赖于任课老师的，而不是直接依赖主键课程编号，是传递依赖，不符合3NF。 优化： 课程表 课程编号 课程名字 上课时间 任课老师 101 马克思理论基础 8:00 Lily 102 经济学 14:00 Lucy 教师表 任课老师 老师电话 老师职位 Lily 18016253155 讲师 Lucy 18055231233 教授 必须先满足第一范式才能满足第二范式，必须同时满足第一第二范式才能满足第三范式 满足三大范式的数据库E-R图实例： 满足三大范式的数据库模型图：","tags":["MySQL"],"categories":["学习笔记","文章"]},{"title":"Python学习笔记二()","path":"//[object Object]/2022/03/19/python学习笔记二/","content":"1.、随机数 随机数 12345&gt;&gt;&gt;import random&gt;&gt;&gt;random.seed()#设置随机数种子&gt;&gt;&gt;random.randint(1,100)#生成1-100随机整数&gt;&gt;&gt;random.uniform(-100,100)#生成-100到100的随机浮点数&gt;&gt;&gt;round(random.uniform(-100,100),2)#保留两位小数 随机数组 1234&gt;&gt;&gt;import numpy as np&gt;&gt;&gt;rand = np.random&gt;&gt;&gt;rand.randint(1,100,(3,6))#生成3个数组，每个数组由6个1-100的随机整数组成&gt;&gt;&gt;rand.rand(4)*100#生成1个数组，由4个0-100的随机浮点数组成。rand()返回值为[0,1] 2、Numpy扩展包 ndarray(代表一种特殊的数据结构—n维数组)是numpy的灵魂，Python中的列表和元组内存大、计算时间长。使用数组能优化这些缺点。 2.1 ndarray创建12345678910#导入numpy包import numpy as np#第一种方法,和内置函数range类似,速度更快，返回的是ndarray类型myarray1 = np.arange(1,10,2)#[1 3 5 7 9]#第二种方法myarray2 = np.array([1,3,5,7,9])#[1 3 5 7 9]#第三种方法,返回几行几列填满相同一个元素的数组myarray3 = np.full((2,3),6)#[[6 6 6] [6 6 6]]#第四种，生成随机数组，可用np.random.RandomState()指定随机种子数myarray4 = np.random.randint(0,10,(2,3))#[[1 3 8] [8 4 2]] 2.2 主要特征 shape(形状) 指定数组是一维数组或多维数组，shape=(2,15)代表2行15列的数组，且shape=可以省略。 dtype(元素类型) 指定数组元素类型，dtype=np.int代表元素为numpy中的int型。ndarray的类型比Python自带的多 2.3 切片/读取 规则切片操作 ndarray数组支持像list那样的规则切片操作 不规则切片操作 也可以使用Fancy Indexing方法进行不规则切片操作, 格式为 [[index1,index2,index3...]], 即方括号内嵌套方括号。比如我想取数组的索引为第1个、第2个、第4个、第5个。 123fancy_index = np.arange(0,100)fancy_index[[1,2,4,5]]#[1 2 4 5] 2.4 多维数组的切片以二维数组为例 123456789101112131415161718192021222324#切片的使用，[行进行切片,列进行切片] 即[start:stop:step,start:stop:step]#获取所有行print(a[:,:])#结果：#[[ 0 1 2]# [ 3 4 5]# [ 6 7 8]# [ 9 10 11]]#获取所有行，部分列 &#123;所有行，第二列&#125;print(a[:,1])#[ 1 4 7 10]#获取所有行，部分列 &#123;所有行，第一、二列&#125;print(a[:,0:2])#[[ 0 1] [ 3 4] [ 6 7] [ 9 10]]#获取部分行，部分列 &#123;行的奇数行，列的第一、第二列&#125;print(a[::2,0:2])#[[0 1] [6 7]]#使用坐标获取[(1,2),(2,0)]，(1,2)均为行号，(2,0)均为列号，且1和2会自动结合，2和0会自动结合,3和结合print(a[(1,2,3),(2,0,1)])#结果：[5 6 10] 2.5浅拷贝和深拷贝浅拷贝是指拷贝过来的是—引用。 123456789import numpy as nparr1 = np.array([1,2,3,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;])arr2 = np.arange(1,10,2)arr1 = arr2 #此处arr1对arr2进行了浅拷贝，二者引用相同存储空间arr1[1] = 0print(arr1,arr2)#[1 0 5 7 9] [1 0 5 7 9]#对arr1的修改也会影响arr2 的值 深拷贝是指重新申请一个存储空间存放，使用的是 copy()方法。 123456789import numpy as nparr1 = np.array([1,2,3,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;])arr2 = np.arange(1,10,2)arr1 = arr2.copy() #此处arr1对arr2进行了深拷贝，arr1重新获得一个新的存储空间存放相同的arr2元素arr1[1] = 0print(arr1,arr2)#[1 0 5 7 9] [1 3 5 7 9]#arr2并未发生变化 2.6形状和重构查看形状，用 属性shape 12345678import numpy as nparr1 = np.array([1,2,3,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;])arr2 = np.random.randint(0,10,(2,3))print(arr1.shape)print(arr2.shape)#(6,)#(2,3) reshape(), 返回一个符合形状的多维数组，不改变原数组 12345678import numpy as nparr = np.arange(0,20)arr2 = arr.reshape(4,5)print(arr2)#[[ 0 1 2 3 4]# [ 5 6 7 8 9]# [10 11 12 13 14]# [15 16 17 18 19]] 注意：重构的数组必须是n × m = 原数组总元素个数，否则会报错 resize() 改变原数组 12345678import numpy as nparr = np.arange(0,20)arr.resize(4,5)print(arr)#[[ 0 1 2 3 4]# [ 5 6 7 8 9]# [10 11 12 13 14]# [15 16 17 18 19]] flatten() 将多维数组变为一维数组，返回值为一维数组，不改变原数组 swapaxes() 进行轴调换，实现转置矩阵。不改变数组本身 1234567891011121314import numpy as nparr = np.arange(0,20)arr.resize(4,5)arr_swap = arr.swapaxes(0,1)print(arr,arr_swap)#[[ 0 1 2 3 4]# [ 5 6 7 8 9]# [10 11 12 13 14]# [15 16 17 18 19]]#[[ 0 5 10 15]# [ 1 6 11 16]# [ 2 7 12 17]# [ 3 8 13 18]# [ 4 9 14 19]] 2.7 属性计算计算数组的秩，用 ndim 属性 12345import numpy as nparr = np.arange(0,20)arr.resize(4,5)print(arr.ndim)# 2 计算元素个数，用 size 属性 1234import numpy as nparr = np.arange(0,20)print(arr.size)# 20 数组的乘法，不改变原数组 123456import numpy as nparr = np.arange(0,20)arr1 = arr*10print(arr1)#[ 0 10 20 30 40 50 60 70 80 90 100 110 120 130 #140 150 160 170# 180 190] 2.8 插入和删除np.delete(ArrayName,index) 删除特定元素, 不改变数组np.insert(ArrayName,index,value) 插入特定元素, 不改变数组 12345678910import numpy as nparr = np.arange(0,10,2)###########delete#####arr1 =np.delete(arr,2)print(arr,arr1)#[0 2 4 6 8] [0 2 6 8]###########insert#######arr2 = np.insert(arr,1,999)print(arr,arr2)#[0 2 4 6 8] [ 0 999 2 4 6 8] 2.9 缺失值和广播规则其它 数组内排序： 使用 np.sort(ArrayNameaxis ) ,返回排序结果不改变数组本身。 其中参数axis则表示按行排序还是按列排序。","tags":["Python","Numpy"],"categories":["学习笔记","文章"]},{"title":"树莓派4b使用摄像头","path":"//[object Object]/2022/03/17/树莓派4b使用摄像头/","content":"树莓派4b使用摄像头1、先升级源： sudo apt-get update sudo apt-get upgrade 2、打开树莓派配置 sudo raspi-config 打开 Interfacing Option ,接着找到 Camera 选项,打开树莓派摄像头。 然后点击 finish, 重启即可 3、测试rapistill指令来截图 raspistill -o a.jpg 打开根目录，就可以看到a.jpg啦~ 相关参数： -v：调试信息查看 -w：图像宽度 -h：图像高度 -rot：图像旋转角度，只支持 0、90、180、270 度（这里说明一下，测试发现其他角度的输入都会被转换到这四个角度之上） -o：图像输出地址，例如image.jpg，如果文件名为“-”，将输出发送至标准输出设备 -t：获取图像前等待时间，默认为5000，即5秒 -tl：多久执行一次图像抓取 例如执行下面的指令： raspistill -o image%d.jpg -rot 180 -w 1024 -h 768 -t 20000 -tl 5000 -v 注意：如果没看到照片，先看看摄像头能否运行 ls -al /dev/ grep video 以上出现video则说明摄像头正常，再找找照片试试 如果在以上工作都完成的情况下，摄像头还是不能正常的使用或者驱动，请先检查硬件的连接的问题，可能是排线没有很好的插稳，或者是摄像头本身的问题 4、实时监控安装motion(开源监控软件) sudo apt-get install motion 首先将motion软件的后台进程改为开启，让它能够一直在后台运行。输入以下命令，将文件中 “start_motion_daemon=no” 的no改为yes。 sudo nano /etc/default/motion 之后输入命令打开motion的配置文件： sudo nano /etc/motion/motion.conf 要更改的参数有以下几行，在nano编辑器环境下可以使用快捷键ctrl+w对关键字进行查找。 123456daemon on #off改成onwidth 640 height 480 #根据摄像头像素自行更改framerate 50 #帧率stream_maxrate 200stream_localhost off #设为off，允许局域网内所有用户访问 然后重启motion sudo service motion.service restart 重启motion服务，也可以killsudo motion #开启motion 同局域网下访问 树莓派ip:8081 ,便能看到实时画面了","tags":["Linux","树莓派"],"categories":["学习笔记","文章"]},{"title":"树莓派4B点亮LED(Python实现)","path":"//[object Object]/2022/03/14/树莓派4b点亮ledpython实现/","content":"1、树莓派GPIO引脚图 [admonition title=”注意” color=”red”] 先简单了解一下引脚，我们对树莓派引脚的操作是有可能损坏我们的树莓派的。有必要提前了解。[/admonition] 功能名： 绿色背景：GPIO是标准引脚，可以用来打开和关闭设备。例如，一个LED。 浅蓝色背景：I2C(Inter-Integrated Circuit)引脚连接并与支持该协议(I2C协议)的硬件模块对话。这个协议通常会占用两个引脚。 紫色背景：SPI（串行外设接口总线）引脚可用于连接和对话SPI设备。和I2C差不多，但使用了不同的协议。 深蓝色背景：UART(Universal asynchronous receiver/transmitter，通用异步接收/发送器)是用于与其他设备通信的串行引脚。 黑色：GND是用来接地的引脚。使用哪个引脚并不重要，因为它们都连接在同一条线上。 2、主要实验材料 树莓派4B主板、SD卡、USB电源、1k欧姆电阻、红色LED发光二极管、杜邦线 3、实验步骤 连接电路 发光二极管正极接上1kΩ电阻，两边连接杜邦线。将二极管正极插入GPIO引脚21(BCM编码，也就是物理引脚的40)，二极管负极接入GND(这里插入物理引脚39) 树莓派编写程序代码 在这之前先检查Python是否安装了 RPI.GPIO 模块，Python2已经预装，Python3需要手动安装 12sudo apt-get updatesudo apt-get install python3-rpi.gpio 创建pi.py 文件,写入： 12345678910111213import RPi.GPIO as GPIOimport time#注意BOARD和BCM编码的不同，这里设置的是BCM编码GPIO.setmode(GPIO.BCM)GPIO.setup(21, GPIO.OUT)#闪5次for i in range(5): GPIO.output(21,GPIO.HIGH) time.sleep(1) GPIO.output(21,GPIO.LOW) time.sleep(1)#建议每次退出时都用cleanup设置GPIO引脚为低电平状态GPIO.cleanup() 运行py程序 1sudo python pi.py 观察到二极管灯一闪一闪既大功告成！ 4、总结关于在过程中遇到的一些问题 python版本问题 树莓派4B默认使用python2.7，我们可以将它删除更换为python3.7 123456//卸载python2.7sudo apt-get autoremove python2.7//链接python3.7sudo ln -s /usr/bin/python3.7 /usr/bin/python//链接pip3sudo ln -s /usr/bin/pip3 /usr/bin/pip 安装rpi.gpio库出现Requirement already satisfied问题 将安装的rpi模块直接指向文件目录 1pip install --target=/usr/lib/python3/dist-packages rpi.gpio","tags":["Linux","树莓派","Python"],"categories":["学习笔记","文章"]},{"title":"Argon主题文档","path":"//[object Object]/2022/03/13/argon主题文档/","content":"文档地址：https://argon-docs.solstice23.top/#/ 1、图标以下代码能实现下图中的效果 123&lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt; 首页&lt;i class=&quot;fa fa-link&quot;&gt;&lt;/i&gt; 友链&lt;i class=&quot;fa fa-rss&quot;&gt;&lt;/i&gt; RSS 首页 友链 RSS 请访问 Font Awesome 4 图标库自行查询对应的图标名。 2、标签[label 参数名=&quot;参数值&quot;]内容[/label] 123456789方形[label]默认标签[/label][label color=&quot;indigo&quot;]靛蓝标签[/label][label color=&quot;blue&quot;]蓝色标签[/label][label color=&quot;orange&quot;]橙色标签[/label]圆形[label color=&quot;indigo&quot; shape=&quot;round&quot;]靛蓝标签[/label][label color=&quot;blue&quot; shape=&quot;round&quot;]蓝色标签[/label][label color=&quot;orange&quot; shape=&quot;round&quot;]橙色标签[/label] 方形 [label]默认标签[/label] [label color=”indigo”]靛蓝标签[/label] [label color=”blue”]蓝色标签[/label] [label color=”orange”]橙色标签[/label] 圆形 [label color=”indigo” shape=”round”]靛蓝标签[/label] [label color=”blue” shape=”round”]蓝色标签[/label] [label color=”orange” shape=”round”]橙色标签[/label] 3、进度条[progressbar 参数名=&quot;参数值&quot;]进度条标签内容[/progressbar] 标签内容可以不填写 123456789[progressbar progress=&quot;20&quot;]默认进度条[/progressbar][progressbar progress=&quot;30&quot; color=&quot;indigo&quot;]靛蓝进度条[/progressbar][progressbar progress=&quot;40&quot; color=&quot;green&quot;]绿色进度条[/progressbar][progressbar progress=&quot;66&quot; color=&quot;red&quot;]红色进度条[/progressbar][progressbar progress=&quot;80&quot; color=&quot;blue&quot;]蓝色进度条[/progressbar][progressbar progress=&quot;100&quot; color=&quot;orange&quot;]橙色进度条[/progressbar] [progressbar progress=&quot;23&quot;][/progressbar][progressbar]没有指明参数的进度条[/progressbar][progressbar progress=&quot;66.66&quot;]小数进度条[/progressbar] [progressbar progress=”20”]默认进度条[/progressbar] [progressbar progress=”30” color=”indigo”]靛蓝进度条[/progressbar] [progressbar progress=”40” color=”green”]绿色进度条[/progressbar] [progressbar progress=”66” color=”red”]红色进度条[/progressbar] [progressbar progress=”80” color=”blue”]蓝色进度条[/progressbar] [progressbar progress=”100” color=”orange”]橙色进度条[/progressbar] [progressbar progress=”23”][/progressbar] [progressbar]没有指明参数的进度条[/progressbar] [progressbar progress=”66.66”]小数进度条[/progressbar] 4、警告[admonition 参数名=&quot;参数值&quot;]内容[/admonition] 123456789101112[admonition]默认警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;indigo&quot;]靛蓝警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;green&quot;]绿色警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;red&quot;]红色警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;blue&quot;]蓝色警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;orange&quot;]橙色警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;black&quot;]黑色警告[/admonition][admonition title=&quot;我是标题&quot; color=&quot;grey&quot;]灰色警告[/admonition][admonition title=&quot;我是标题&quot; icon=&quot;flag&quot; color=&quot;indigo&quot;]带标题和图标的警告[/admonition][admonition color=&quot;indigo&quot;]不带标题的警告[/admonition][admonition title=&quot;只有标题的警告&quot; color=&quot;indigo&quot;][/admonition][admonition title=&quot;只有标题和图标的警告&quot; icon=&quot;flag&quot; color=&quot;indigo&quot;][/admonition] [admonition]默认警告[/admonition] [admonition title=”我是标题” color=”indigo”]靛蓝警告[/admonition] [admonition title=”我是标题” color=”green”]绿色警告[/admonition] [admonition title=”我是标题” color=”red”]红色警告[/admonition] [admonition title=”我是标题” color=”blue”]蓝色警告[/admonition] [admonition title=”我是标题” color=”orange”]橙色警告[/admonition] [admonition title=”我是标题” color=”black”]黑色警告[/admonition] [admonition title=”我是标题” color=”grey”]灰色警告[/admonition] [admonition title=”我是标题” icon=”flag” color=”indigo”]带标题和图标的警告[/admonition] [admonition color=”indigo”]不带标题的警告[/admonition] [admonition title=”只有标题的警告” color=”indigo”][/admonition] [admonition title=”只有标题和图标的警告” icon=”flag” color=”indigo”][/admonition] 5、Github信息卡[github 参数名=&quot;参数值&quot;][/github] 1[github author=&quot;solstice23&quot; project=&quot;argon-theme&quot;][/github] [github author=”solstice23” project=”argon-theme”][/github] 参数名 可选值 默认 解释 是否必须 author 字符串 空 Repo作者名 是 color 字符串 空 Repo名 是 size full/mini full 尺寸 否 getdata frontend/backend 前端/后端获取Reop信息 否","categories":["专业技术"]},{"title":"网站性能测试","path":"//[object Object]/2022/03/12/网站性能测试/","content":"使用webbench测试网站，结果网站被自己搞挂了这几天一直想测试自己的网站性能，网上搜了一下教程，发现linux下有个webbench可以用来简单测试，挺好用的，就是我的破站承受不了… 首先按照教程 👉参考 先是测试150个客户，60秒内完成。结果看样子我的网站还不错？能承受150个并发访问✌ 我觉得七百个应该小破站受不了了,然后……居然???还可以??? 然后是模拟客户 1000个 ，时间 60秒，开始有failed了 这时候我再网页上访问我的主页,出问题了… 上服务器上面看我的数据库 果然数据库被搞挂了…. 最后，重启一下mysql服务器就好了 总结：其实我的小破站还是小破站，各位大佬别拿我的小破站进行测试，千万别搞什么DDos、SQL注入之类的啊，球球了🙏🙏🙏 不过有个缺点就是不支持HTTPS","tags":["Linux","MySQL","C"],"categories":["专业技术"]},{"title":"wordpress完整建站过程(二)","path":"//[object Object]/2022/03/10/wordpress完整建站过程二/","content":"通过FTP软件将下载的wordpress包传输到Linux的/var/www/html/目录下 或者通过wget获取我站点上的安装包（看情况万一我的OSS服务没了这个方法也就不行了） 在当前根目录获取安装包 sudo wget https://redamancy9189.oss-cn-beijing.aliyuncs.com/wordpress%E4%B8%BB%E9%A2%98%E5%8C%85/wordpress-5.9-zh_CN.zip 解压 unzip wordpress-5.9-zh_CN.zip 移动到根目录 mv wordpress /var/www/ 删除原本的html并修改wordpress为html cd /var/www rm -rf html mv wordpress html 打开服务器站点（一般为locahost）,根据提示输入数据库密码并进行安装 完成安装，进入后台页面 4.安装主题，开始编写自己的文章吧！ 解决wordpress安装主题时的问题 解决安装WordPress主题及插件需要输入FTP问题 安装一个WordPress好像挺简单，但是默认主题不喜欢，想更换一个，无奈本地可以更换，但是服务器更换的时候需要设置FTP 。OK，设置呗，好像我的用户名密码之类的都是正确的，就是不让我通过，因此，找了一下解决方案 进入WordPress根目录 1vim wp-config.php 添加以下三句代码 123define(&quot;FS_METHOD&quot;, &quot;direct&quot;);define(&quot;FS_CHMOD_DIR&quot;, 0777);define(&quot;FS_CHMOD_FILE&quot;, 0777); 接着重新访问你的网站，重新安装主题 无法建立目录wp-content/uploads/xxxx/xx。有没有上级目录的写权限？ 给wp-content目录添加权限 sudo chmod -R 777 wordpress/wp-content Nginx出现 413Request Entity Too Large 打开nginx.conf配置文件 sudo vim /etc/nginx/nginx.conf 在http{}中加入client_max_body_size 100M; 重启ngnix； Wordpress5.9要安装Markdown编辑器的话用 WP-githuber md首先要先禁用新版编辑器 古堡疼，在主题文件编辑器那里找到 function.php，在最后添加上 1234//禁用古腾堡编辑器add_filter(&#x27;use_block_editor_for_post&#x27;, &#x27;__return_false&#x27;);//屏蔽古腾堡的样式加载remove_action( &#x27;wp_enqueue_scripts&#x27;, &#x27;wp_common_block_scripts_and_styles&#x27; ); Wordpress插件推荐：WPvivid Backup Plugin、WP Statistics、WP Githuber MD","tags":["Linux","Apache","WordPress","MySQL","PHP"],"categories":["学习笔记","文章"]},{"title":"操作系统学习笔记（一）","path":"//[object Object]/2022/03/08/操作系统-进程学习/","content":"进程进程管理什么是进程进程是 进程(Process)包括 程序的代码 、程序的数据、指示下一条运行的指令、一组通用寄存器的当前值、 一组系统资源。 进程特征包括 结构特征、 动态性、 并发性、独立性、 异步性 进程三种基本状态： 就绪状态、执行状态、阻塞状态 （有的为五种：最前为 新建态、最后为 终止态） 进程状态转换关系 挂起状态(基本状态之外): 进程被从内存调出进驻外存，不再接受调度。 PCB[^PCB]: PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。PCB是进程存在的唯一标志。 上下文切换: 将CPU切换到另一进程需要保存原来进程的状态并装入新进程的保存状态。上下文切换时间与硬件支持密切相关。 进程控制 进程创建：在一个已经存在的进程（用户进程或系统进程）当中，通过系统调用来创建一个新的进程。 创建步骤：1、申请空白PCB 2、新进程分配资源 3、初始化PCB 4、进程插入就绪状态 进程终止 进程阻塞与唤醒 原因：请求系统服务、新数据尚未到达、无进程新任务 阻塞过程：调用 阻塞原语block 把自己阻塞、将PCB插入阻塞队列、重新调度。 唤醒过程：阻塞队列移出阻塞进程、PCB从阻塞改为就绪、PCB插入就绪队列。 进程挂起与激活 挂起过程：修改进程状态、PCB复制到指定内存块、（如有必要转调度程序）。 激活状态：进程调入内存、修改进程状态、（如抢占调度考虑是否执行） 进程同步 进程通信[^IPC] 临界区和临界资源 进程的工作分为两类：1、内部计算 2、对共享内存或共享文件的访问（竞争条件的产生） 完成第二类工作的程序片段就是 临界区， 需要互斥访问的共享资源就是 临界资源 。 整形信号量：Dijkstra提出：把整形信号量定义为一个整形量，除初始化外，仅能通过两个标准的 原子操作 (Atomic Operation) wait(S)和 signal(S)来访问。分别称为P、V操作。 12345678//P原语操作的定义procedure wait(S) var S:semaphore;begin S.value:=S.value-1; if S.value&lt;0 then block(S,L)end 12345678//V原语操作的定义procedure signal(S) var S:semaphore;begin S.value:=S.value+1; if S.value&lt;=0 then wakeup(S,L);end 记录型信号量 信号量被描述为一个记录(或者结构) S.value的处置表示为系统中某类资源的数目，因此也称资源信号量。每次wait操作进程请求该一个单位的该类资源；当S.value&lt;0时，进程调用block原语自我阻塞，并插入信号量链表S.L中。 AND型信号量 一次性将进程所需所有资源分配到进程里，待使用完释放(避免死锁) 利用信号量实现进程互斥 n个进程互斥地使用某个临界资源是，设定信号量mutex 用于互斥访问，初始化为1。 进程互斥还可能出现死锁 同步与互斥的混合问题 有一个仓库，可以存放A和B 两种产品。要求：1)每次只能存入一种产品(A或B)；2)-N&lt;A产品数量-B产品数量&lt;M。试用PV操作描述产品A与产品B的入库过程。 经典IPC问题 主要问题：如何选择信号量, 如何安排P、V原语的顺序。 生产者-消费者问题、哲学家进餐问题、读者-写者问题、理发师问题、和尚喝水问题。 信号量方法的缺点： 逻辑关系复杂，可读性差、维护困难、容易导致竞争状态或者死锁严重问题。 管程由Hoare和Hansen提出，基本思想：将共享变量以及对共享变量所进行的操作封装在一个模块中。 结构 由一组变量、数据结构和函数构成的软件模块。 特性 封装性、互斥性、语言相关性 等待与唤醒 条件变量[^条件变量] 用于描述等待的原因，通过 wait 和 signal 操作条件变量。wait 和 signal 类似P、V原语，但条件变量不取具体数值，不进行累加。 send 和 receive 12send(target,&amp;msg)//将消息msg发送到目标(进程)target中receive(src,&amp;msg)//接收src传来的msg,如果无消息可用，阻塞接受者 有可能面临ACK [^ACK]丢失问题 进程高级通信线程 线程与进程 进程=资源平台+线程 一个进程中可以同时存在多个线程; 各个线程之间可以并发地执行; 各个线程之间可以共享地址空间。 进程是资源分配单位，线程是CPU调度单位；线程可实现进程级的并发。 单线程与多线程的关系图： 用户线程 在用户空间实现，不依赖操作系统的内核。 内核线程 由内核来维护进程和线程的上下文信息（PCB[^PCB]和TCB[^TCB]）。线程的创建、终止和切换都是通过系统调用的方式来进行，需要从用户态转换到系统态，由内核来完成，系统开销较大。 用户态和内核态两种CPU状态：内核态（Kernel Mode，运行操作系统程序）、用户态（User Mode，运行用户程序 ） 指令划分特权指令：只能由操作系统使用、用户程序不能使用的指令。 举例：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止终端 停机 非特权指令：用户程序可以使用的指令。 举例：控制转移 算数运算 取数指令 访管指令（使用户程序从用户态陷入内核态） 特权级别特权环：R0、R1、R2和R3 R0相当于内核态，R3相当于用户态； 不同级别能够运行不同的指令集合； CPU状态之间的转换用户态 -&gt;内核态：唯一途径是通过中断、异常、陷入机制（访管指令） 内核态 -&gt;用户态：设置程序状态字PSW 内核态与用户态的区别内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当程序运行在0级特权级上时，就可以称之为运行在内核态。 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 这两种状态的主要差别是：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可被抢占的 ；而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的 并发和并行并发Concurrent，在操作系统中，一个时间段里有几个程序都处于已启动运行到运行完成之间，且这几个程序在同一个处理机上完成。 并行Parallel，当系统有一个以上CPU时，一个CPU执行一个进程，另一个CPU可以执行另一个进程，两个进程互不抢夺CPU资源，可以同时进行。 课后作业 操作系统的四个特征是什么？分别是什么含义？ 答：1、并发：两个或者多个事件在同一时间间隔内发生；2、共享：系统内资源可供多个并发进程共同使用；3、异步：进程以不可预知的速度向前推进；4、虚拟：通过某种技术把一个物理实体变成若干个逻辑上的对应物。 什么是操作系统内核？内核的主要功能是什么？ 答：内核是操作系统最基本部分。主要功能是为众多应用程序提供对计算机硬件的安全访问。 什么是系统调用？系统调用与一般程序有什么不同？ 答：系统调用是操作系统内核和用户运行程序之间的接口。不同：运行的状态不同，在程序中的过程一般或都是用户程序，或都是系统程序，都是运行在同一个系统状态的（用户态或内核态）。进入的方式不同，一般程序可以直接由调用过程直接转换到被调用过程，而系统调用则不允许，只能通过一条能产生异常的机器指令（”自陷指令”或叫”访管指令”）进入操作系统，再转到相应的应用处理程序。返回的方式不同。代码层次不同，一般程序是用户级程序，而系统调用是操作系统的代码程序，是系统级程序。^1 什么是进程，为什么OS要引入进程? 答：进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程；引入进程是为了提高计算机资源的利用率。 进程的基本状态有哪些？会由什么事件导致进程状态的转化？ 答：就绪(Ready)状态、执行(Running)状态、阻塞(Block)状态。等待I/O的结果、等待某一进程提供输入、运行进程用完时间片、高优先级进中断低优先级线程、调度程序选择新进程运行、等待事件发生。 什么是临界资源？什么是临界区？ 答：需要互斥访问的共享资源为临界资源。完成对共享内存和共享资源的访问工作叫做临界区。 什么是忙等？它有什么缺点？ 答：一个进程位于其临界区内时，任何试图进入其临界区的进程都必须在其进入代码中持续地循环。容易造成资源利用率低，系统阻塞。 m个共享进程共享一个临界资源，问信号量的变化范围。 答：信号量初始值为1，每进行一次P操作则其值减1，每进行一次V操作则其值加1，当有一个进程获得资源，其他m–1个进程在等待队列中时，其值为-(m-1) 什么是进程的同步？它包含哪两种形式？什么是临界资源、临界区？ 答：进程的同步是指：在多道程序环境下，进程是并发执行的，不同进程之间具有不同的互相制约条件。两种形式：同步代码块(被同步关键字封装的代码) 、同步函数(被同步关键字修饰的函数)。 男女生共同使用公共洗澡间。规则是：洗澡间门上有可以翻的牌子，牌子分别为“无人”、“男”“女”。若来洗澡的同学发现牌子显示为“无人”，则可以把牌子翻成和自己一样的性别，然后入室洗澡。若来洗澡的同学发现牌子和自己的性别相同，可以直接入室洗澡。若来洗澡的同学发现牌子和自己的性别不同，则须在室外等待。最后一个洗澡的同学离开洗澡间时需要将牌子翻成“无人”。请使用信号量和PV操作，设计男生和女生的同步机制。 答： 123456789101112131415161718192021222324252627282930//空闲资源数semaph mutex=1;//占用浴室男生数，占用浴室女生数int S_man=0,S_women=0;//等待的男生数,等待的女生数int man_wait = 0,women_wait = 0;//男生想要进入浴室void man_want_entry()&#123; if(S_women==0)&#123; P(mutex); S_man++; 洗澡... man_leave_bathroom(); &#125;else&#123; man_wait++; &#125;&#125;//男生离开浴室void man_leave_bathroom()&#123; S_man--; V(mutex);&#125;//女生想要进入浴室void woman_want_entry()&#123; P(mutex); if&#125; 某机房有N台电脑。门口有一个刷卡机。学生上机时，必须在刷卡机上刷卡登录，下机时也必须在刷卡机上刷卡结算费用。请用信号量方法给来上机的同学设计同步机制。 线程是什么？线程主要包含什么内容？内核级线程和用户级线程是什么？ 答：线程是操作系统能够进行运算调度的最小单位。主要包含线程ID、程序计数器、寄存器组合堆栈。内核级线程是由内核管理的线程。用户级线程是指不需要内核支持而在用户程序中实现的线程。 处理机调度和死锁处理机调度的基本概念处理 一个CPU中有多个进程的竞争(选择一个进程将处理机分配给它) 称为 调度程序, 该程序使用的算法叫做 调度算法。 三种调度进程调度(初级调度)、内存调度(中级调度)、作业调度(高级调度) 进程调度(内存—&gt;CPU) 频率最高。按照某种调度算法，从就绪队列选择一个进程分配给处理机。 内存调度(外存—&gt;内存) 频率中等。按照某种调度算法，从 挂起队列 选择合适进程将其数据调回内存。 作业调度(外存—&gt;内存) 频率最低。按照某种调度算法，从 后备队列 中选择合适的作业将其调入内存，并为其创建进程(PCB)。 进程行为进程分为计算密集型(CPU-Bound)和I/O密集型(I/O-Bound)。 CPU的提高比磁盘更快？越来越多的进程倾向于IO密集型 调度算法FCFS调度算法批处理系统的先来先服务调度算法(FCFS, First come First Served或叫FIFO First In First Out)，按照作业到达的先后次序进行调度。 优点：简单，易于实现，如排队。 缺点：若出现长作业出现在短作业之前的情况，会增加平均周转时间 SJF调度算法批处理系统的短作业优先调度算法(SJF, Shortest Job First)。 优点：减少了平均周转时间 缺点：大作业的的周转时间变长，不适合一些大项目？？ 两种实现方案 不可抢占方式 当前作业运行时不会被打断直到运行完毕或阻塞时，才让出CPU。 可抢占方式 当一个新的短作业到来时，若其运行时间小于当前正在运行作业的 剩余时间，则抢占CPU运行。（此方式也叫SRTF，Shortest Remaining Time First） 不可抢占式SJF例题，求平均周转时间 作业 进入时刻（H） 运行时间（H） 1 8 2 2 8.5 0.5 3 9 0.1 4 9.5 0.2 ​ 例题作业 抢占式SJF例题，求平均等待时间 HRRN调度算法批处理系统的最高响应比作业优先算法(HRRN, Highest Response Ratio Next) 优点：综合平衡了FCFS和SJF 响应比 R = 响应时间/需运行时间=1＋已等待时间 / 需运行时间。 作业 进入时刻（H） 运行时间（H） 1 8 2 2 8.5 0.5 3 9 0.1 4 9.5 0.2 ​ 例题作业 RR调度算法 交互式系统的时间片轮转调度算法（RR，Round-Robin） MQ调度算法 多级队列调度算法（MQ，Multilevel Queue） 多级反馈算法 实时调度多处理系统的调度死锁含义每个进程都占用着若干个资源，同时又在等待得到该组进程中另一进程所占用的资源，因而造成的所有进程都无法进展下去的现象。这一组进程就称为死锁进程。 计算机资源有：CPU、时钟、IO设备、内存空间、数据库记录等。 资源分为两大类： 可抢占的 存储器、内存、CPU等。当进程正在使用该类型资源时，抢占不会造成任何不良影响。 不可抢占的 刻录机、光盘、磁带机、打印机等。当一个进程正在使用该类型资源时，不可强行抢占，否则会导致进程运行失败。 注意:不可抢占性资源是临界资源，但是临界资源不是不可抢占性资源 死锁主要由不可抢占资源引起 死锁产生的原因 资源有限 进程中有多个共享资源如打印机、公共队列等 并发进程间的推进顺序不当 请求和释放资源的顺序不当，会导致产生进程死锁 预防死锁死锁的检测和解除课后作业 线程是什么？线程主要包含什么内容？内核级线程和用户级线程是什么？ 答：线程是操作系统能够进行运算调度的最小单位。线程的实体包括程序、数据和TCB。内核级线程是，用户级线程是在用户空间上实现，不依赖于系统内核。内核级线程是系统内核管理的线程，由内核完成调度。 假定在一台处理机上执行下表所示的作业，假定这些作业在0时刻，以1,2,3,4,5的次序顺序到达。说明分别用FCFS、RR（时间片1）、SJF、以及非抢占式优先级（优先级1最高）调度算法，给出平均周转时间。 作业 执行时间 优先级 1 10 3 2 1 1 3 2 3 4 1 4 5 5 2 FCFS： T = (10+10+11+11+15)/5=11.4 RR: T = (19+1+5+1+10)/5 = 11.2 SJF: 抢占式：T = () 非抢占式: T = () 非抢占式优先级：T = (10+10+17+17+12)/5 = 13.2 一带闸门的运河，其上有两架吊桥。吊桥坐落在一条公路上，为使该公路避开一块沼泽地而令其横跨运河两次。运河和公路的交通都是单方向的。运河上的基本运输由驳船担负。在一艘驳船接近吊桥A时就拉汽笛警告，若桥上无车辆，吊桥就吊起，直到驳船尾部通过此桥为止。对吊桥B也按同样次序处理。 一艘典型驳船的长度为200米，当它在河上航行时是否会产生死锁？若会，其理由是什么？ 答：会产生，假设A无车辆，迪奥条吊起驳船通过100米到达B，若此时B上有车辆，会发生A处吊桥不放下，汽车无法通过，B处吊桥不吊起驳船无法通过的现象。 如何能克服一个可能的死锁？请提出一个防止死锁的办法。 答：限制驳船的大小不超过100米；当AB上无车辆时且有驳船通过时，同时吊起AB桥。 如何利用信号灯上的P、V操作实现车辆和驳船的同步？ 答： 1int p,v 设系统中有三种类型的资源（A、B、C）和五个进程（P1、P2、P3、P4、P5），A资源的数量为17，B资源的数量为5，C资源的数量为20。在T0时刻系统状态如下表所示。系统采用银行家算法实施死锁避免策略。 T0时刻是否为安全状态若是，请给出安全序列。 在T0时刻若进程P2请求资源（0, 3, 4），是否能实施资源分配为什么 在（2）的基础上，若进程P4请求资源（2, 0, 1），是否能实施资源分配，为什么 在（3）的基础上，若进程P2请求资源（0, 2, 0），是否能实施资源分配，为什么 MAX* ALLOCTION* A B C A B C P1 5 5 9 2 1 2 P2 5 3 6 4 0 2 P3 4 0 11 4 0 5 P4 4 2 5 2 0 4 P5 4 2 4 3 1 4 存储器管理程序的装入和链接buffer和cache的解释 A buffer is something that has yet to be “written” to disk. A cache is something that has been “read” from the disk and stored for later use. 也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。 连续分配方式分页存储管理分页系统的地址转换机制 分段存储管理虚拟存储器的基本概念请求分页存储管理方式页面置换算法请求分段存储管理方式课后作业 什么是逻辑地址，什么是物理地址？ 答：逻辑地址是CPU所生成的地址。加载到内存地址寄存器中的地址，内存单元的真正地址。 什么是地址重定位？动态分区存储和分页存储如何进行地址重定位？ 答：地址重定向是把程序的逻辑地址空间转变为内存中的实际物理地址空间的过程。动态分区存储在程序运行时CPU每次访问内存单元才进行地址变换。分页存储 相对于分区存储管理，分页存储管理的优势是什么？分页过大或过小会带来什么问题？ 答：使得一个程序的逻辑地址可以分布在若干个离散的内存块上，减少内碎片和外碎片，提高内存利用率。过大会导致页内碎片增多。过小导致进程页表过长，占用大量内存，还降低页面换进换出的效率。 如何管理内存块的分配与回收？分别以内存分区表和位图来说明。 答： 编程题：求m个进程（序号0到m-1）, n个资源情况下，所有的安全序列。 输入 m,n m*n 矩阵 max m*n 矩阵 allo n维向量 avai 输出所有安全序列 [^PCB]: (Process Control Block,PCB,进程控制块) [^IPC]: (InterProcess Communication,IPC,) [^条件变量]: (Condition Variables,条件变量) [^ACK]: (Acknowledge character,ACK,确认字符) [^TCB]: (Thread Control Block,TCB,线程控制块 )","tags":["C","操作系统","线程","进程","锁"],"categories":["学习笔记","文章"]},{"title":"Javascript实现点击特效","path":"//[object Object]/2022/03/05/421/","content":"先看一下效果图点击我的博客就是效果啦 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;点击产生类似烟花效果&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; //粒子颜色,根据爱好来选择 const Colors = [ &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;gary&quot;, &quot;orange&quot;, &quot;pink&quot;, &quot;yellow&quot;, &quot;purple&quot;, &quot;black&quot;, ] ; //定义粒子数量 const particlesNumber = 20; function creatParticle(x,y)&#123; const ele = document.createElement(&quot;div&quot;); //设置成一个小园形，自己也可以根据爱好设置成其他如心型、星型 ele.style.height = &quot;10px&quot;; ele.style.width = &quot;10px&quot;; ele.style.borderRadius = &quot;5px&quot;; //设置绝对位置 ele.style.position = &quot;absolute&quot;; ele.style.top = `$&#123;y&#125;px`; ele.style.left = `$&#123;x&#125;px`; //光标位于方块中央 ele.style.transform = &quot;transform(-50%,-50%)&quot;; ele.style.backgroundColor = Colors[Math.floor(Math.random()*Colors.length)]; /*animate(keysframes,options)函数,options可以是动画持续时间，也可以是多个属性值的对象 duration：持续时间，iterations：动画迭代次数(Infinity表示无限动画)，delay：添加到动画的延迟 */ const animation = ele.animate( [ &#123; transform:`translate($&#123;(Math.random()-0.5)*500&#125;px,$&#123;(Math.random()-0.5)*500&#125;px) rotate($&#123;Math.random()*520&#125;deg)`, opacity: 0 &#125;, ], &#123; duration: 1000, iterations: 1 &#125; ); //向网页添加元素 document.body.appendChild(ele); //结束后将DOM产生的div去除 animation.onfinish = () =&gt; ele.remove(); &#125; //创建点击事件 document.addEventListener(&quot;click&quot;,(e) =&gt;&#123; //获取当前光标位置 const &#123;clientX: x, clientY: y &#125; = e; //创建多个粒子 for (let index = 0; index &lt; particlesNumber; index++) &#123; creatParticle(x,y); &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 这是之前我在C站的文章","tags":["html","Javascript"],"categories":["学习笔记","文章"]},{"title":"WordPress完整建站过程(一)","path":"//[object Object]/2022/03/02/wordpress完整建站过程/","content":"我的👉第一篇文章👈里面就写了些建站的经过，现在我打算把过程记录下来，也算是一种复习吧（是因为孩怕哪天服务器过期了要重新搭建。。。） 前期准备 一台有公网IP的主机（我的是👉阿里云轻量服务器） 域名以及DNS解析 wordpress安装包（👉官网下载，👉站长自存） 开始安装 云服务器最好先选择Ubuntu20.04环境（虽然云服务器上有wordpress环境和LAMP、LNMP环境，但还是想自己折腾） 域名解析(可选) 如何将域名解析到自己主机上的方法自行查找，先有了主机再买域名弄比较合适 在云服务器上安装LAMP或者LNMP LNMP是指Linux、Ngnix、MySql、PHP环境 LAMP是指Linux、Apache、MySql、PHP环境（我这里使用的是这个） 先更新一下云服务器Linux（为了获得系统当前最新的软件包） 12sudo apt-get updatesudo apt-get upgrade 安装Apache2(用来做wordpress的服务器) 1sudo apt-get install apache2 安装MySQL(用来存放网站的所有数据) 安装mysql-server 1sudo apt-get install mysql-server 初始化设置 1sudo mysql_secure_installation 检查mysql服务状态 1systemctl status mysql.service 配置远程连接 12sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf #找到 bind-address 修改值为 0.0.0.0(如果需要远程访问) 重启mysql 1sudo /etc/init.d/mysql restart 修改密码 1234&gt;&gt;use mysql;&gt;&gt;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;你的密码&#x27;; &gt;&gt;flush privileges;&gt;&gt;quit; 配置所有ip都可访问(否则后续访问PHPmyadmin会出现权限问题) 1UPDATE user SET host = &#x27;%&#x27; WHERE user = &#x27;root&#x27;; #允许远程访问 安装PHP(网页的后端语言) 1sudo apt-get install php 安装PHP-MySQL（用于PHP和MySQL之间的支持） ```c sudo apt-get install php-mysql -安装PHPmyadmin(用于在网页上管理mysql数据库) ```c sudo apt-get install phpmyadmin 由于phpmyadmin的文件在usr/share/phpmyadmin中，而网页访问的根目录在www/html中，需要在根目录创建快捷方式： 1sudo ln -s /usr/share/phpmyadmin /var/www 查看文件 1sudo gedit /etc/apache2/apache2.conf 进入文本编译器之后，会看到很长的代码 在末尾加上这句话: 1Include /etc/phpmyadmin/apache.conf 保存退出重启apache 1/etc/init.d/apache2 restart 网页上访问localhost/phpmyadim,用mysql数据库root/密码登陆 出现这类错误先查看是不是phpmyadmin的用户名和密码输错了 如何查看phpmyadmin的登陆用户名和密码 1vim /etc/phpmyadmin/config-db.php 再重新登录即可 登陆成功 (为什么不用宝塔面板之前那篇👉文章有介绍) WordPress完整建站过程(二)","tags":["Apache","WordPress","MySQL","PHP"],"categories":["学习笔记"]},{"title":"树莓派学习","path":"//[object Object]/2022/03/02/299/","content":"树莓派学习 1、前期工作 下载img镜像(去清华大学镜像源下载比较快) 使用win32imgdisk将iimg镜像烧录至大于8G的SD卡上 在sd卡上新建文件名为wpa_supplicant.conf，并在文本里添加 12345678910111213141516171819202122country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;TP-LINK_D8B2&quot; psk=&quot;&quot; key_mgmt=WPA-PSK/*无论使用WPA-PSK还是WPA2-PSK如果wifi没有密码，则key_mgmt=NONE*/ priority=100/*数字越大优先级越高*/&#125;network=&#123; ssid=&quot;&quot; psk=&quot;&quot; key_mgmt=WPA-PSK priority = 5&#125;network=&#123; ssid=&quot;&quot; psk=&quot;&quot; key_mgmt=WPA-PSK priority = 1&#125; 在sd卡上继续添加ssh文件(无后缀名，启动树莓派ssh服务) 接下来插入树莓派中通电启动 远程连接 同一个wifi下，查看树莓派IP地址并使用Putty远程连接 初识用户名：pi 初识密码：raspberry 修改root密码： sudo passwd root 然后输入两次密码ok（初次系统没有密码） 然后解锁root账户 sudo passwd --unlock root 切换进入root su root 在ssh客户端更新源，将系统默认的国外源换成国内源（以清华大学镜像源为例） 树莓派更新apt-get的源列表在/etc/apt/sources.list 1sudo nano /etc/apt/sources.list 另外，要注意查看已经的系统镜像是哪一个版本 树莓派的镜像源Debian系统分好几种，wheezy、jessie、stretch、buster，它们分别对应： Debian版本 对应名称 Debian7 wheezy Debian8 jessie Debian9 stretch Debian10 buster Debian11 bullseye 把官方给的源用#注释掉，我们这里可以看到官方源是buster版本，那么我们添加的清华的软件源就必须得是buster版本的； 加上阿里的源 12345678deb http://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb http://mirrors.aliyun.com/debian-security/ bullseye-security maindeb-src http://mirrors.aliyun.com/debian-security/ bullseye-security maindeb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib 注意！！！raspian与bullseye中间的空格不能删去！！不然无法更新 继续打开 sudo nano /etc/apt/sources.list.d/raspi.list 将第一行的官方Debian系统源注释掉，在前面加上 #，加上 1deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ bullseye main 保存、退出编辑器，再执行一遍sudo apt-get update和sudo apt-get upgrade,就成功了。 ``` sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install -y gcc g++ python3-pip openjdk-11-jdk ffmpeg cmatrix sl hollywood samba samba-common tmux vim htop s-tui python3-dev jq proxychains zsh iperf3 unzip curl screenfetch git cmake clang &amp;&amp; sudo apt autoremove 12345678910 ### 安装xrdp(实现Windows桌面远程连接)```cppsudo apt-get install xrdp //安装xrdp远程桌面服务sudo /etc/init.d/xrdp start //开启xrdp服务sudo update-rc.d xrdp defaults //将xrdp服务加入到默认系统启动列表 接下来使用桌面的远程连接程序连接用root用户即可 FTP Server安装（为了使用Filezilla进行Windows和树莓派之间的文件传输） 1sudo apt-get install vsftpd 启动服务 1sudo service vsftpd start 允许写入树莓派权限，vsftp 默认关闭了写入权限，需手动开启 1sudo vim /etc/vsftpd.conf 找到 write_enable=YES 的，将前面的 # 号删除即可。 重启vsftpd服务器： 1service vsftpd restart","tags":["Linux","树莓派"],"categories":["学习笔记","文章"]},{"title":"Python学习笔记(一)","path":"//[object Object]/2022/03/01/测试markdown/","content":"1.Python缩进12345elements = [&quot;Tom&quot;,&quot;Jack&quot;,&quot;Anne&quot;]for elem in elements: print(&quot;Hello&quot;,elem) #缩进表示一个代码块 print(&quot;I love you&quot;,elem)print(&quot;Bye My&quot;,elements)#不缩进代表一个独立的语句，不在for循环体内 2.基本类型 整数 浮点数 1.23e9可以表示很大的浮点数 字符串 可以使用&quot;或者&#39;括起来的，字符串内可用转义字符\\标识 布尔值 True和 False 布尔值还可以用布尔运算，有三种：and，or， not与之对应的逻辑是数理逻辑上的与或非 空值 是Python一个特殊值，用 None表示 列表、字典等 2.1变量大小写英文、数字和_的组合，且不能用数字开头 2.2常量Python里通常用全大写变量名表示常量，但不强制 2.3字符串编码 Python3采用Unicode编码，常见计算机系统内存统一采用Unicode编码，当需要保存到硬盘或者传输时，就转化为UTF-8编码，反之转化回Unicode。 Python对于 bytes 类型的数据用带 b 前缀的单引号或双引号表示： 1x = b&#x27;ABC&#x27; 字符串可用encode( )方法可以编码为指定的bytes 12345&gt;&gt;&gt; &#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)b&#x27;ABC&#x27;&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;&gt;&gt;&gt; &#x27;中文&#x27;.encode(&#x27;ascii&#x27;) len( )函数计算str字符数 1234&gt;&gt;&gt; print(len(&quot;你好&quot;))2&gt;&gt;&gt; print(len(&quot;nihao&quot;))5 如果是计算bytes，则是字节数 123456&gt;&gt;&gt; len(b&#x27;ABC&#x27;)3&gt;&gt;&gt; len(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)6&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6 坚持使用UTF-8编码避免乱码问题 3.格式化12&gt;&gt;&gt; print(&quot;hello ,%s,I&#x27;m %d years old,my score is %f&quot;%(&quot;jack&quot;,18,95.00))hello ,jack,I&#x27;m 18 years old,my score is 95.000000 另外一种是str.format( )方法，不推荐 4.list 和tuple list是一种有序的集合，可以增删， 123456789elements = [&quot;A&quot;,123,[&quot;C&quot;,&quot;D&quot;],True]elements.append(&quot;abcd&quot;)elements.insert(2,(&quot;2&quot;,&quot;3&quot;))elements.pop(0)print(elements)print(elements[-3][0])#如果是elements[-2][0]会报TypeErrorw###########输出结果自行理解[123, (&#x27;2&#x27;, &#x27;3&#x27;), [&#x27;C&#x27;, &#x27;D&#x27;], True, &#x27;abcd&#x27;]C tuple一旦初始化不能修改，没有append( ), insert( )这种方法，能使用-1…表示索引 tuple用 () 表示(注意和数学符号意义上的区别，通常用 , 如（ 1,）加以区分) tuple里面若有指向别的元素如list，指向的list不可改变，但是list指向的可以改变 1tuple = (&quot;A&quot;, &quot;B&quot;, [&quot;C&quot;,&quot;D&quot;])#tuple里面的元素[&quot;C&quot;,&quot;D&quot;]是一个list，list可以改变 5.dict和set dict 6.Python小结列表list []、元组tuple ()、字典 dict {key: value}、无序不重复集合 set (list[]) 7.函数 参数 位置参数 平时常用的按照顺序进行传参的参数 1234567891011def power(x,n): temp = 1 if n&lt;0: for t in range(n,0):#t表示n到-1的整数 temp = temp/x elif n&gt;0: for t in range(0,n):#range(n,m)表示返回n到m-1的整数list temp = temp*x return tempprint(&quot;power(5,3):&quot;,power(5,3))#power(5,3): 125print(&quot;power(5,-2):&quot;,power(5,-2))#power(5,-2): 0.04 默认参数 默认参数在后面，默认参数必须指向不变对象，不然下次调用时默认参数内容就变了 123456789101112def enroll(name,age,city=&quot;北京&quot;,sex=&quot;保密&quot;): print(&quot;My name is &quot;,name,&quot;,I`m &quot;,age) print(&quot;I`m come from &quot;,city,&quot;,my sex is&quot;,sex)enroll(&quot;李华&quot;,23,sex = &quot;女&quot;)#My name is 李华 ,I`m 23 #I`m come from 北京 ,my sex is 女 enroll(&quot;张三&quot;,18)#My name is 张三 ,I`m 18#I`m come from 北京 ,my sex is 保密 enroll(&quot;李四&quot;,45,&quot;上海&quot;,&quot;男&quot;)#My name is 李四 ,I`m 45#I`m come from 上海 ,my sex is 男 可变参数 在参数前加一个 * ，参数接收到的可以是一个tuple，也可以是任意个参数包括0个 对于已有的tuple和list，在前面加一个 * 就可变成可变参数传入函数 12345678910def calc(*numbers): sum = 0 for number in numbers: sum = sum + number return sumnums1 = [1,3,5,7]nums2 = (1,3,5,7)print(calc(1,3,5,7)) #16print(calc(*nums2)) #16print(calc(*nums1)) #16 关键字参数 允许传入0至多个参数，在函数内部自动组装为一个dict 1234567891011def info(name, age, **more): print(name,&quot; &quot;,age,&quot; &quot;,more) if &quot;city&quot; in more: pass if &quot;addr&quot; in more: print(&quot;my city:&quot;,more.get(&quot;addr&quot;)) #more相当于一个字典info(&quot;李华&quot;,12,addr=&quot;钦州市&quot;,sex = &quot;男&quot;)#结果都为：李华 12 &#123;&#x27;addr&#x27;: &#x27;钦州市&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;&#125; my city: 钦州市extra = &#123; &quot;addr&quot;:&quot;钦州市&quot;,&quot;sex&quot;:&quot;男&quot;&#125;info(&quot;李华&quot;,12,**extra)#这里相当于把extra的一份拷贝给函数info的关键字参数more 小结：对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。 递归 元信息 123#为函数添加元数据,描述函数的参数类型和返回类型def add(x:int, y:int) -&gt; int: return x+y 元信息只是为了帮助源码阅读。python解释器不会对这些注解添加任何的语义。即使返回类型不一致，程序也不会出错，因为它们不会被类型检查。 8.高级特性 切片 : 用来取list或tuple的部分元素 123456L = list(range(100,200))print(L[:3])#取list前三个元素print(L[1:3])#取list中索引值为1到索引值为3的元素print(L[-20:-10])#取倒数第十到倒数第二十也就是180-190（不包括190）之间的十个整数print(L[:10:2])#前十个元素，每隔2个元素取一个，结果为100,102,104,106,108print(L[::-1])#实现切片逆序 迭代 1、 通过for...in来完成迭代，不仅可以在 tuple 、 list 和 dict 上进行迭代，还可以作用于可迭代对象（可通过collections.abc 模块的 Iterable 类型判断) 1234&gt;&gt;&gt;isinstance(&#x27;abc&#x27;,Iterable)#str是否能迭代True&gt;&gt;&gt;isinstance(123,Iterable)#整数是否能迭代False 2、实现Java下标循环 12345&gt;&gt;&gt;for i,x in enumerate([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]):&gt;&gt;&gt; print(i,x)0 A1 B2 C 列表生成式 列表生成式可以嵌套一层至多层循环 12345678910111213#列表生成式直接一行代码生成list&gt;&gt;&gt;print([x*x for x in range(1,5)])[1,4,9,16]#还可以使用像for循环那样的两个变量即以上&gt;&gt;&gt;dictItem = &#123;&#x27;A&#x27;:&#x27;a&#x27;,&#x27;B&#x27;:&#x27;b&#x27;,&#x27;C&#x27;:&#x27;c&#x27;&#125;&gt;&gt;&gt;print([a+&#x27;=&#x27;+b for a,b in dictItem.items])[&#x27;A=a&#x27;,&#x27;B=b&#x27;,&#x27;C=c&#x27;]#for循环后还能添加if判断条件，注意！！这是筛选条件，和下面的if...else不一样&gt;&gt;&gt;print([x*x for x in range(1,10) if x%2==0])[4, 16, 36, 64]#还可以添加多层循环&gt;&gt;&gt;print([a+b for a in [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;] for b in [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]])[&#x27;1A&#x27;, &#x27;1B&#x27;, &#x27;1C&#x27;, &#x27;2A&#x27;, &#x27;2B&#x27;, &#x27;2C&#x27;, &#x27;3A&#x27;, &#x27;3B&#x27;, &#x27;3C&#x27;] if...else的使用(使用方法为在for循环前加上if…else) 123&gt;&gt;&gt;dictItem = &#123;&#x27;A&#x27;:2,&#x27;B&#x27;:&#x27;b&#x27;,&#x27;C&#x27;:&#x27;c&#x27;,&#x27;D&#x27;:3&#125;&gt;&gt;&gt;print([a+&#x27;=&#x27;+b if isinstance(b,str) else a+&#x27;=&#x27;+str(b) for a,b in dictItem.items()])[&#x27;A=2&#x27;, &#x27;B=b&#x27;, &#x27;C=c&#x27;,&#x27;D=3&#x27;] 生成器(Generator) next()、yelid、StopIteration generator函数返回一个generator对象 9. 高阶函数 map() 、 reduce() 和 filter() map() 接收一个函数和Iterator，将函数作用到所有Iterator元素上并将结果返回到新的Iterator，最终结果返回新的Iterator。 12345&gt;&gt;&gt; def f(x): return x * x&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)#最后要用list函数将Iterator转换为list[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce 接收一个函数和一个序列，该函数必须接收两个参数，reduce 负责将函数结果继续和 序列下一个元素 作为两个参数继续执行下一次函数，直到后序无元素，最终结果为计算结果 1234&gt;&gt;&gt;def add(x,y):&gt;&gt;&gt; return x+y&gt;&gt;&gt;reduce(add,[1,3,5,7])16 思考题：利用map和reduce编写一个str2float函数，把字符串&#39;123.456&#39;转换成浮点数123.456 filter 接收一个函数和一个序列，将 函数作用于每个元素 ，然后根据返回值是 True 还是 False 决定保留或者丢弃元素。 1234&gt;&gt;&gt;def not_empty(s):&gt;&gt;&gt; return s and s.strip()&gt;&gt;&gt;print(list(filter(not_empty,[&#x27;A&#x27;,None,&#x27;B&#x27;,&#x27;&#x27;]))[&#x27;A&#x27;, &#x27;B&#x27;] sorted() sorted() 可以对list进行排序，也是一个高阶函数，可以接收一个 key 函数自定义排序顺序 12&gt;&gt;&gt;sorted([9,-1,2,4,-5],key=abs)[-1, 2, 4, -5, 9] sorted()函数负责将key函数返回的结果进行排序，并按对应关系返回list中的元素 此外，要实现反向排序还可以传入 reverse 的值为 True 12&gt;&gt;&gt;print(sorted([9,-1,2,4,-5],key=abs,reverse=True))[9, -5, 4, 2, -1] sorted() 返回结果为list 10. 函数式编程 返回函数 一个函数可以返回值，也可以返回函数 123456789def lazy_sum(L): def sum(L): result = 0 for x in L: result = result + x return result return sum #注意返回sum和sum()的区别！！！test = lazy_sum([1,2,3,4,5])print(test())#返回的是sum，则需要调用test();如果返回的是sum(),则直接调用test ​ 上述例子，如果函数内只是返回函数名而不是返回执行函数，则为 闭包运算 ；此外，返回闭包时，要注意返回函数不能引用任何循环变量或者后续会发生变化的变量。 nonlocal 声明该变量不是当前函数的局部变量 匿名函数(lambda) 关键字 lambda 参数 x,y : 函数返回值 x+y 1lambda x,y: x+y 多数时候配合高阶函数 map()、filter()、reduce()、sorted() 使用 装饰器(decorator) 在代码运行期间动态增加功能的方式。(动态语言的函数和类的定义，是在运行时动态创建的。) 要借助Python的 @ 语法，把decorator放在函数 定义处： 12345678910import timedef log(func): def wrapper(*args,**kw): print(&#x27;call %s()&#x27;%func.__name__) return func(*args,**kw) return wrapper@log #相当于执行 now = log(now)def now(): print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)) 偏函数 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&#x27;1000000&#x27;)64&gt;&gt;&gt; int2(&#x27;1010101&#x27;)85 11. 模块 作用域 _xxx 或者 _xxx_ 表示的 函数 或者 变量 一般为非公开的(private)，不应该被直接引用(但依然可以在其它模块强制引用)。 1234567891011121314151617#这是工具类.py模块&gt;&gt;&gt;import datetime&gt;&gt;&gt;import time&gt;&gt;&gt;def showtime():&gt;&gt;&gt; print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))&gt;&gt;&gt;__t = time.strftime(&quot;%Y&quot;)&gt;&gt;&gt;def __showyear():&gt;&gt;&gt; print(__t)#这是test.py模块&gt;&gt;&gt;from 工具类 import showtime,__showyear,__t&gt;&gt;&gt;showtime()&gt;&gt;&gt;print(__t)#不推荐直接使用其它模块的private变量或函数，即使可以正常使用&gt;&gt;&gt;__showyear()2022-02-26 18:36:4920222022 只有外部需要的函数或者变量才定义为public。 安装第三方模块 包管理工具 pip 12.面向对象编程 类和实例及其访问权限 1234567891011121314151617181920212223242526272829#新建Student类，并继承Object类class Student(object): #__init__方法初始化对象，相当于java的构造子 #定义类时，self代表&quot;实例的引用&quot; def __init__(self, name, gender): #__xxx习惯上设置访问权限为private，但还是可以强制访问 self.__name = name self.__gender = gender #设置对象里的方法 def get_gender(self): return self.__gender def set_gender(self,s): if s ==&#x27;male&#x27;or&#x27;female&#x27;: print(self.__gender) self.__gender = s print(self.__gender) else: raise ValueError(&#x27;值错啦&#x27;)# 测试:bart = Student(&#x27;Bart&#x27;, &#x27;male&#x27;)if bart.get_gender() != &#x27;male&#x27;: print(&#x27;测试失败!&#x27;)else: bart.set_gender(&#x27;female&#x27;) if bart.get_gender() != &#x27;female&#x27;: print(&#x27;测试失败!&#x27;) else: print(&#x27;测试成功!&#x27;) 方法 Python中的方法分为三种：实例方法、类方法、静态方法。 实例方法 参数里面有 self ，如： 12def set_self(self,name): self.__name = name 类方法 前面带有装饰器 @classmethod ,且参数里面有 cls ，如： 1234@classmethoddef class_func(cls): cls.name = &quot;我是类名&quot; print(&quot;my name is %s&quot;%(cls.name)) 静态方法 形参中没有 cls 和 self，甚至没有参数，如： 123456import random@staticmethoddef static_func(): #返回0-9的随机数 randomNum = random.randint(0,9) return randomNum 类方法和静态方法都可以通过类名和实例名调用 获取对象信息 type()方法 123456&gt;&gt;&gt; type(123)==intTrue&gt;&gt;&gt; type(&#x27;abc&#x27;)==type(&#x27;123&#x27;)True&gt;&gt;&gt; type(&#x27;abc&#x27;)==strTrue 该方法返回对应的Class类型 id()方法 1234567891011&gt;&gt;&gt;str1 = &#x27;test&#x27;&gt;&gt;&gt;str2 = &quot;test&quot;&gt;&gt;&gt;str3 = str1&gt;&gt;&gt;int1 = 123&gt;&gt;&gt;list1 = [1,2,&#x27;3&#x27;]&gt;&gt;&gt;tuple1 = (1,2,3,[1,2,&#x27;3&#x27;])&gt;&gt;&gt;total =[&#x27;test&#x27;,str2,str3,int1,list1,tuple1]&gt;&gt;&gt;print(list(id(i) for i in total[:3] if &gt;&gt;&gt;type(i)==str))&gt;&gt;&gt;print(list(id(i) for i in total))[2408464217968, 2408464217968, 2408464217968][2408464217968, 2408464217968, 2408464217968, 2408455690416, 2408507421120, 2408507410448] 从输出结果可以看出程序运行时str1、str2、str3的id值是一样的 isinstance()方法 如果有继承关系：Object -&gt;Animal -&gt;Dog -&gt;Husky 那么则 1234567a = Animal()b = Dog()h = Husky()&gt;&gt;&gt;isinstance(h,Husky)True&gt;&gt;&gt;isinstance(h,Animal)True isinstance()还可以判断其类型及其子类,一般情况下优先使用isinstance()判断类型 isinstance()还可以判断是否为某些变量其一 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True __doc__属性 12&gt;&gt;&gt;print(len.__doc__)Return the number of items in a container. 用于查看某对象支持的方法或属性清单 此外还有 help()方法，可以帮助显示方法或属性信息 类属性 直接定义在类中，区别于实例属性self.xxx 动态绑定 动态绑定允许我们在程序运行的过程中动态给class加上功能 1234567891011121314class Student(object): def __init__(self,name): self.__name__ = namestu1 = Student(&#x27;张三&#x27;)#动态绑定给实例绑定一个属性stu1.sex = &#x27;male&#x27;print(stu1.sex)# 动态绑定给实例绑定一个方法def set_name(self,name): self.__name__ = namefrom types import MethodTypestu1.set_name = MethodType(set_name, stu1) stu1.set_name(&#x27;李四&#x27;)print(stu1.__name__) 为了限制类外动态绑定属性或方法，可以定义在定义类时用__slots__变量，来限制该class实例能添加的属性。 1234class Student(object): __slots__ = (&#x27;name&#x27;,&#x27;__name__&#x27;) def __init__(self,name): self.__name__ = name 此时如果向Student类添加sex属性则会报AttributeError 注意：__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用 练习：利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution 123456789101112131415161718192021222324class Screen(object): @property def width(self): return self.__width__ @width.setter def width(self,size): if isinstance(size,(int,float))==False: raise TypeError(&#x27;请输入正确的int或其它数值类型&#x27;) if size &lt; 0 or size &gt; 2048: raise ValueError(&#x27;请输入正确范围的数&#x27;) self.__width__ = size @property def height(self): return self.__height__ @height.setter def height(self,size): if isinstance(size,(int,float))==False: raise TypeError(&#x27;请输入正确的int或其它数值类型&#x27;) if size &lt; 0 or size &gt; 2048: raise ValueError(&#x27;请输入正确范围的数&#x27;) self.__height__ = size @property def resolution(self): return self.__width__*self.__height__ 多重继承 通过多重继承，一个子类就可以同时获得多个父类的所有功能 123class Dog(Mammal,Runnable): def __init__(): pass MixIn 用于分清主父类和额外功能(类似于Java的继承单一父类和多继承接口) 123class Dog(Mammal,RunnableMixIn): def __init__(): pass __str__ Python里面的 __str__ 相当于Java 的 toString()方法 12345678class Student(object): __slots__ = (&#x27;name&#x27;,&#x27;__name__&#x27;) def __init__(self,name): self.__name__ = name def __str__(self) -&gt; str: return &#x27;my name is%s &#x27;%(self.__name__)stu1 = Student(&#x27;张三&#x27;)print(stu1) #结果为：my name is 张三 同样的还有 __getattr__、 __call__、 __iter__、 __getitem__ 等 可根据需要前往官网文档查阅相关资料，不再赘述。 13. 异常、错误、调试 错误与错误 高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外 123456789101112131415try: #可能发生异常的语句except IOError as e : #发生IOError异常时要执行的语句 print(&quot;An EOF error occurred.&quot;) raise eexcept (Ex2,Ex3): #发生异常Ex2或Ex3时要执行的语句except Exception: #发生其它异常时要执行的语句else: #无异常时要执行的语句finally: #无论有没有异常都要执行的语句 #如文件资源、数据库、图形句柄资源的释放 调试 有三种方式：Python Debugger、%xmode、assert Python学习笔记(二)","tags":["Python"],"categories":["文章","专业技术"]},{"title":"建站成功了记录一下","path":"//[object Object]/2022/03/01/建站成功了记录一下/","content":"1、一开始花了两天多的时间来搭建LAMP的环境，（本想着宝塔面板会方便很多，没想到宝塔居然无法识别出我先前安装的AMP环境。。。） 2、接着又在wordpress主题上面纠结了很久（本想着sakurairo主题看起来不错，但是运行起来太耗时间了） 3、接着就是找到了现在这个Argon主题（嗯不错，界面简洁清晰，而且至少现在来看不卡了。） 4、接着就是一堆配置问题了（具体的就不说了…因为都忘记哪些bug了） 5、不过在我可爱女朋友瑶瑶子的鼓励下，终于和完成了大部分了！ 6、接下来计划给自己网站添加一些样式和功能，比如导航栏那一块还没有图标、对于一些错误的操作和重复的点击导致网站负担加大也没进行限制，还有对于评论的筛查也要弄一下。 嗯 就 这 样End~","categories":["生活点滴","文章"]},{"title":"遇到的Wordpress问题集","path":"//[object Object]/2022/03/01/wordpress注意问题/","content":"在网站的搭建过程中难免会遇到一些问题，本篇文章将过程记录下来，分享给大家，希望对大家有帮助。各位遇到的问题也欢迎留言讨论，一起学习~ 问题链接: Wordpress头像显示问题 解决Argon主题预览时只能点击标题进入文章 Wordpress伪静态链接问题 一些小问题: 1、Wordpress5.9要安装Markdown编辑器的话用 WP-githuber md首先要先禁用新版编辑器 古堡疼，在主题文件编辑器那里找到 function.php，在最后添加上 1234//禁用古腾堡编辑器add_filter(&amp;#039;use_block_editor_for_post&amp;#039;, &amp;#039;__return_false&amp;#039;);//屏蔽古腾堡的样式加载remove_action( &amp;#039;wp_enqueue_scripts&amp;#039;, &amp;#039;wp_common_block_scripts_and_styles&amp;#039; ); Wordpress插件推荐：WPvivid Backup Plugin(备份插件)、WP Statistics(统计插件，PC端右侧的统计信息就是使用该插件)、WP Githuber MD （Markdown语法支持插件） 2、后台修改WordPress Address（URL）后导致无法登陆后台的解决办法登陆数据数据库，进入wordpress数据库 1234sudo mysql -u root -puse wordpress;update wp_options set option_value=&quot;http://xx.xx.xx.xx&quot; where option_name=&quot;siteurl&quot;;update wp_options set option_value=&quot;http://xx.xx.xx.xx&quot; where option_name=&quot;home&quot;; option_value要设置回原服务器的ip/域名，注意要加协议名http或https(根据网站是否配置了https证书选择) 3、关于phpmyadmin出现404原因 环境：Ubuntu20.04 Apache2.4 一、由于phpmyadmin的文件在usr/share/phpmyadmin中，而网页访问的根目录在www/html中，需要在根目录创建快捷方式 ：sudo ln -s /usr/share/phpmyadmin /var/www 查看文件 1sudo gedit /etc/apache2/apache2.conf 进入文本编译器之后，会看到很长的代码 在末尾加上这句话: 1Include /etc/phpmyadmin/apache.conf 保存退出重启apache 1/etc/init.d/apache2 restart 访问localhost/phpmyadim,用mysql数据库root/密码登陆 4、解决配置CDN后台IP定位不准确 wordpress版本：5.9.2 在根目录下找到 wp-config.php,在最后给它添加上： 1234if (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $list=explode(&#x27;,&#x27;,$_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $list[0];&#125;","tags":["WordPress","MySQL","PHP"],"categories":["学习笔记","文章"]}]