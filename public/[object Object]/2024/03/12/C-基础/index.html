
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 5.4.2">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>C++基础 - Wtoy's Blog</title>

  
    <meta name="description" content="Bustub前置知识：C++STLC++ STL详解超全总结(快速入门STL)-CSDN博客 string 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt; &#x2F;&#x2F; 引入 string 头文件int main () &amp;#123;    string s1 &#x3D; &quot;123&quot;;    string s2">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础">
<meta property="og:url" content="https://blog.wtoy.top/[object%20Object]/2024/03/12/C-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Wtoy&#39;s Blog">
<meta property="og:description" content="Bustub前置知识：C++STLC++ STL详解超全总结(快速入门STL)-CSDN博客 string 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt; &#x2F;&#x2F; 引入 string 头文件int main () &amp;#123;    string s1 &#x3D; &quot;123&quot;;    string s2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-497f3dddeca16e784dc74de20887bec4_720w.webp">
<meta property="og:image" content="https://redamancy9189.oss-cn-beijing.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/image-20240309204057829.png">
<meta property="article:published_time" content="2024-03-12T10:55:12.000Z">
<meta property="article:modified_time" content="2024-03-12T10:55:47.046Z">
<meta property="article:author" content="wtoy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-497f3dddeca16e784dc74de20887bec4_720w.webp">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  
    <link rel="shortcut icon" href="/static/images/favicon.ico">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://redamancy9189.oss-cn-beijing.aliyuncs.com/Icons/%E7%AB%99%E7%82%B9logo.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Wtoy's Blog</div><div class="sub normal cap">十年饮冰</div><div class="sub hover cap" style="opacity:0"> 难凉热血</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="探索" href="/explore/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="社交" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/%5Bobject%20Object%5D/2024/03/16/99%E8%A1%8C%E5%AE%9E%E7%8E%B0C-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB/"><span class="title">99行实现C++线程池类</span></a><a class="item title" href="/%5Bobject%20Object%5D/2022/03/28/813/"><span class="title">杂</span></a><a class="item title" href="/%5Bobject%20Object%5D/2024/03/15/C-%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/"><span class="title">C++实现LRU算法</span></a><a class="item title" href="/%5Bobject%20Object%5D/2024/03/12/C-%E5%9F%BA%E7%A1%80/"><span class="title">C++基础</span></a><a class="item title" href="/%5Bobject%20Object%5D/2022/03/10/wordpress%E5%AE%8C%E6%95%B4%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B%E4%BA%8C/"><span class="title">wordpress完整建站过程(二)</span></a><a class="item title" href="/%5Bobject%20Object%5D/2023/03/10/vue%E5%88%B6%E4%BD%9Cchatgpt%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"><span class="title">制作网页ChatGPT聊天机器人</span></a><a class="item title" href="/%5Bobject%20Object%5D/2022/05/07/typescriptvue3-0%E7%AC%94%E8%AE%B0/"><span class="title">TypeScript+Vue3.0笔记</span></a><a class="item title" href="/%5Bobject%20Object%5D/2022/03/19/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"><span class="title">Python学习笔记二()</span></a><a class="item title" href="/%5Bobject%20Object%5D/2022/04/18/python%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0pip%E6%BA%90/"><span class="title">Python脚本自动更新PIP源</span></a><a class="item title" href="/%5Bobject%20Object%5D/2023/02/26/litechat%E8%81%8A%E5%A4%A9%E5%AE%A4/"><span class="title">LiteChat 即时通讯</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-03-12T10:55:12.000Z">2024-03-12</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-03-12T10:55:47.046Z">2024-03-12</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>C++基础</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="Bustub前置知识：C"><a href="#Bustub前置知识：C" class="headerlink" title="Bustub前置知识：C++"></a>Bustub前置知识：C++</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_50285142/article/details/114026148">C++ STL详解超全总结(快速入门STL)-CSDN博客</a></p>
<p><strong>string</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// 引入 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">	string s = s1 + s2; <span class="comment">// 支持 + 连接符</span></span><br><span class="line">    </span><br><span class="line">    string s;</span><br><span class="line">	cin &gt;&gt; s; <span class="comment">//读入字符串，遇空格，回车结束</span></span><br><span class="line">    string s = <span class="string">&quot;xing ma qi&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch[] = s.<span class="built_in">c_str</span>(); <span class="comment">// 实现string向char数组的转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>s.size() 、s.length()</td>
<td>字符串的字符个数</td>
</tr>
<tr>
<td>s.max_size()</td>
<td>string对象最多包含的字符数</td>
</tr>
<tr>
<td>s.capacity()</td>
<td>同上？？？</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">push_back</span>()	<span class="comment">//在末尾插入</span></span><br><span class="line">s.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//末尾插入一个字符a</span></span><br><span class="line">s.<span class="built_in">insert</span>(pos,element)	<span class="comment">//在pos位置插入element</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27;1&#x27;</span>)	<span class="comment">//在第一个位置插入1字符</span></span><br><span class="line">s.<span class="built_in">append</span>(str)	<span class="comment">//在s字符串结尾添加str字符串</span></span><br><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">erase</span>(iterator p)	<span class="comment">//删除字符串中p所指的字符</span></span><br><span class="line"><span class="built_in">erase</span>(iterator first, iterator last)	<span class="comment">//删除字符串中迭代器区间[first,last)上所有字符</span></span><br><span class="line"><span class="built_in">erase</span>(pos, len)	<span class="comment">//删除字符串中从索引位置pos开始的len个字符</span></span><br><span class="line"><span class="built_in">clear</span>()	<span class="comment">//删除字符串中所有字符</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">substr</span>(pos,n)	<span class="comment">// 截取从pos索引开始的n个字符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p>
<p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p>
<h2 id="C-11新功能"><a href="#C-11新功能" class="headerlink" title="C++11新功能"></a>C++11新功能</h2><ul>
<li>auto关键字</li>
<li>Lambda</li>
<li>智能指针(unique_ptr, shared_ptr, weak_ptr)</li>
<li>右值引用</li>
<li>元组</li>
</ul>
<h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><ol>
<li><p>常用在循环中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterating using auto</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = mapOfStrs.<span class="built_in">begin</span>(); itr != mapOfStrs.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">&quot;::&quot;</span> &lt;&lt; itr-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>auto类型确定后不可变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// This will cause a compile-time error because &#x27;x&#x27; is of type int</span></span><br><span class="line"><span class="comment">// x = &quot;dummy&quot;;</span></span><br></pre></td></tr></table></figure></li>
<li><p>返回类型为 auto</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling the function that returns &#x27;auto&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> value = <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><p>可变参数模板是<strong>可以接受任意数量参数的模板</strong>。</p>
<p>log函数工作原理：</p>
<ol>
<li>它打印第一个参数。</li>
<li>它以递归方式调用其余参数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to end the recursion of variadic template function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This can be empty or used to print something that marks the end of output.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(T first, Args... args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; , &quot;</span>;</span><br><span class="line">        <span class="built_in">log</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; std::endl; <span class="comment">// New line for the last element</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Calling log() functio with 3 arguments</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="number">1</span> , <span class="number">4.3</span> , <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling log() functio with 4 arguments</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">78L</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling log() functio with 2 arguments</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;sample&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="delete关键字"><a href="#delete关键字" class="headerlink" title="delete关键字"></a>delete关键字</h3><p><code>delete</code>关键字可以应用于函数，使它们不可调用</p>
<p>下面是删除函数的简单示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> someFunction（） = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>隐式类型转换</strong>可能很方便，但很危险。如果类型意外转换，它们可能会导致数据丢失或逻辑错误。删除特定的构造函数可以防止这些不需要的转换。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A constructor that might lead to implicit conversions</span></span><br><span class="line"><span class="built_in">User</span>(<span class="type">int</span> userId, std::string userName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an object with potentially problematic conversions</span></span><br><span class="line"><span class="function">User <span class="title">obj4</span><span class="params">(<span class="number">5.5</span>, <span class="string">&quot;Riti&quot;</span>)</span></span>;  <span class="comment">// double to int</span></span><br><span class="line"><span class="function">User <span class="title">obj5</span><span class="params">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;Riti&quot;</span>)</span></span>;   <span class="comment">// char to int</span></span><br></pre></td></tr></table></figure>

<p>若要防止这些转换，请将这些构造函数声明为 deleted：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deleting constructors to prevent implicit conversions</span></span><br><span class="line"><span class="built_in">User</span>(<span class="type">double</span> userId, std::string userName) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="built_in">User</span>(<span class="type">char</span> userId, std::string userName) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，我们将删除两个可能导致隐式转换的构造函数：</p>
<p><strong>限制在堆上创建对象</strong>, 要确保仅在堆栈（而不是堆上）创建类的实例，您可以删除 new 运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Delete the new operator to prevent heap allocation</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此行确保 new 运算符不能与 User 类一起使用。因此，以下代码将触发编译时错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: Use of deleted function &#x27;static void* User::operator new(size_t)&#x27;</span></span><br><span class="line">User* userPtr = <span class="keyword">new</span> <span class="built_in">User</span>(<span class="number">1</span>, <span class="string">&quot;Riti&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><p>是一种通用工具，用于通过<strong>将参数绑定到给定函数</strong>来创建新的函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 包含这个头文件以使用 std::bind</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add_func = std::<span class="built_in">bind</span>(&amp;add, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result:&quot;</span> &lt;&lt; <span class="built_in">add_func</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> exception -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[capture]</p>
<ul>
<li><code>[]</code>：未捕获任何内容。</li>
<li><code>[x, &amp;y]</code>：<code>x</code>按值捕获，<code>y</code>按引用捕获。</li>
<li><code>[=]</code>：作用域中的所有变量都按值捕获。</li>
<li><code>[&amp;]</code>：作用域中的所有变量都通过引用捕获。</li>
</ul>
<p>三个示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [&amp;y](<span class="type">int</span> x) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    y = x * y; <span class="comment">// 这是有效的，因为 y 是通过引用捕获的，并且 lambda 是 &#x27;mutable&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda</span>(<span class="number">5</span>); <span class="comment">// 输出 50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> discount = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值捕获</span></span><br><span class="line">    std::for_each(arr,</span><br><span class="line">                  arr + <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">                  [=](<span class="type">int</span> x) <span class="keyword">mutable</span> &#123;</span><br><span class="line">                        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        <span class="comment">// 无法在此处修改“discount”，因为它是按值捕获的，除非使用“mutable”。</span></span><br><span class="line">                        discount = <span class="number">20</span>;</span><br><span class="line">                  &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;discount Vaue: &quot;</span> &lt;&lt; discount &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 </span></span><br><span class="line"><span class="comment">discount Vaue: 50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>用<strong>花括号</strong>初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    std::vector&lt;T&gt; v;</span><br><span class="line">    <span class="built_in">S</span>(std::initializer_list&lt;T&gt; l) : <span class="built_in">v</span>(l) &#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;constructed with a &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;-element list\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(std::initializer_list&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">const</span> T*, std::<span class="type">size_t</span>&gt; <span class="title">c_arr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>()&#125;;  <span class="comment">// 在 return 语句中复制列表初始化</span></span><br><span class="line">                                   <span class="comment">// 这不使用 std::initializer_list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">templated_fn</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 复制初始化</span></span><br><span class="line">    s.<span class="built_in">append</span>(&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;);      <span class="comment">// 函数调用中的列表初始化</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The vector size is now &quot;</span> &lt;&lt; s.<span class="built_in">c_arr</span>().second &lt;&lt; <span class="string">&quot; ints:\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : s.v)</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Range-for over brace-init-list: \n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) <span class="comment">// auto 的规则令此带范围 for 工作</span></span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> al = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;   <span class="comment">// auto 的特殊规则</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The list bound to auto has size() = &quot;</span> &lt;&lt; al.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    templated_fn(&#123;1, 2, 3&#125;); // 编译错误！“ &#123;1, 2, 3&#125; ”不是表达式，</span></span><br><span class="line">                             <span class="comment">// 它无类型，故 T 无法推导</span></span><br><span class="line">    templated_fn&lt;std::initializer_list&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">    templated_fn&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);           <span class="comment">// 也 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="什么是左值什么是右值？"><a href="#什么是左值什么是右值？" class="headerlink" title="什么是左值什么是右值？"></a>什么是左值什么是右值？</h2><p><a target="_blank" rel="noopener" href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C/C++ 中的左值和右值 | nettee 的 blog</a></p>
<p><strong>左值 (lvalue, locator value)</strong> 表示占据<u>内存</u>中<u>某个可识别的位置</u> 的 <u> 对象</u>。</p>
<p><strong>右值 (rvalue)</strong> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <strong>不表示</strong>内存中某个可识别位置的对象的表达式。</p>
<h3 id="左-右值转换"><a href="#左-右值转换" class="headerlink" title="左/右值转换"></a>左/右值转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// a, b, c是左值，但在 &quot;+&quot; 运算时转换为了右值。即左值隐式转化为右值。</span></span><br></pre></td></tr></table></figure>

<p><strong>但是</strong>，右值不能转换为左值！不过右值可以显式转化为左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">*(p+<span class="number">1</span>) = <span class="number">10</span>; <span class="comment">// p+1 为右值，但指针符号 * 将 p+1 转换为左值。</span></span><br></pre></td></tr></table></figure>

<h3 id="⭐右值引用"><a href="#⭐右值引用" class="headerlink" title="⭐右值引用"></a>⭐右值引用</h3><p>右值引用，这个功能自C++11起才可用。<strong>移动语义</strong>是C++11新增的重要功能，其重点是对右值的操作。右值可以看作程序运行中的临时结果，右值引用可以避免复制提高效率。<code>&amp;&amp;</code>用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  ~<span class="built_in">Foo</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;destruction&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">FooFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;before copy constructor...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  Foo foo1 = <span class="built_in">FooFactory</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;after copy constructor...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// 引用右值，避免生成新对象</span></span><br><span class="line">  Foo&amp;&amp; foo2 = <span class="built_in">FooFactory</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;life time ends!&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>clang</code>编译器编译上述代码， 运行结果如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">before</span> copy <span class="built_in">constructor</span>...</span><br><span class="line"><span class="built_in">destruction</span></span><br><span class="line"><span class="built_in">destruction</span></span><br><span class="line"><span class="built_in">after</span> copy <span class="built_in">constructor</span>...</span><br><span class="line"></span><br><span class="line"><span class="built_in">destruction</span></span><br><span class="line">life <span class="built_in">time</span> ends!</span><br><span class="line"></span><br><span class="line"><span class="built_in">destruction</span></span><br><span class="line"><span class="built_in">destruction</span></span><br></pre></td></tr></table></figure>

<p>从输出结果看，第二种写法少了一次<code>destruction</code>输出，<u>特别是这里调用了额外的一对构造器/析构器，用来创建和销毁一个临时的对象</u>。这意味着通过右值引用(<code>&amp;&amp;</code>)，<code>foo2</code>直接引用<code>FooFactory</code>返回的对象，<strong>避免了对象复制</strong>。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/347977300">认识C++移动语义与右值引用 - 知乎 (zhihu.com)</a></p>
<p><strong>移动语义的“移动”，意味着把某对象持有的资源或内容转移给另一个对象。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vec_red = vec_orange;            // vec_orange被绑定到const std::vector&lt;int&gt; &amp;类型</span></span><br><span class="line">vec_red = std::<span class="built_in">move</span>(vec_orange);    <span class="comment">// vec_orange被绑定到std::vector&lt;int&gt; &amp;&amp;类型</span></span><br></pre></td></tr></table></figure>

<p><strong>vec_orange</strong>是一个左值（它有名字），不经过<code>std::move()</code>的转型则会绑定到一个左值引用；而<code>std::move()</code>则把它转为一个右值引用，从而匹配到移动赋值运算符函数。</p>
<p>例子：<code>std::unique_ptr</code> 简易实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line">    T* ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数和移动赋值函数</span></span><br><span class="line">    <span class="built_in">my_unique_ptr</span>(my_unique_ptr&amp;&amp; other): <span class="built_in">ptr_</span>(std::<span class="built_in">exchange</span>(other.ptr_, <span class="literal">nullptr</span>))&#123;&#125;</span><br><span class="line">    my_unique_ptr&amp; <span class="keyword">operator</span>=(my_unique_ptr&amp;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ptr_) &#123;  <span class="comment">// 释放当前拥有的指针</span></span><br><span class="line">               <span class="keyword">delete</span> ptr_;</span><br><span class="line">           &#125;</span><br><span class="line">           ptr_ = std::<span class="built_in">exchange</span>(rhs.ptr_, <span class="literal">nullptr</span>); <span class="comment">// 夺取rhs的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁止复制构造函数和复制赋值函数</span></span><br><span class="line">    <span class="built_in">my_unique_ptr</span>(<span class="type">const</span> my_unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    my_unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> my_unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p><code>noexcept</code> 是一个异常说明符，用于告诉编译器一个函数不会抛出任何异常。</p>
<blockquote>
<p>如上图所示那般，老的元素是被拷贝到新的内存空间中的。是的，classes容器确实使用的是拷贝构造函数。那么此时我们会想到，既然classes容器已经不需要之前的内存中的数据了，那么将老数据放到新的内存空间中应该使用移动语义，而非拷贝操作。</p>
<p>那么为什么classes容器没有使用移动语义呢？</p>
<p>此时，我们需要提及一个概念，即”强异常保证（strong exception guarantee）”。所谓强异常保证，即当我们调用一个函数时，如果发生了异常，那么应用程序的状态能够回滚到函数调用之前：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://pic1.zhimg.com/80/v2-497f3dddeca16e784dc74de20887bec4_720w.webp" alt="img"></p>
<p>那么强异常保证和决定使用移动语义或拷贝操作又有什么关系呢？</p>
<p>这是因为容器的push_back函数是具备强异常保证的，也就是说，当push_back函数在执行操作的过程中（由于内存不足需要申请新的内存、将老的元素放到新内存中等），如果发生了异常（内存空间不足无法申请等），push_back函数需要确保应用程序的状态能够回滚到调用它之前。以上面的例子来说，当第2次执行<code>classes.push_back(A);</code>时，如果发生了异常，应用程序的状态会回滚到第1次执行<code>classes.push_back(A);</code>之后，即classes容器中只有一个元素。</p>
<p>由于我们的移动构造函数没有使用noexcept说明符，也就是我们没有保证移动构造函数不会抛出异常。因此，为了确保强异常保证，就只能使用拷贝构造函数了。那么拷贝构造函数同样没有保证不会抛出异常，为什么就能用呢？这是因为拷贝构造函数执行之后，被拷贝对象的原始数据是不会丢失的。因此，即使发生异常需要回滚，那些已经被拷贝的对象仍然完整且有效。但移动语义就不同了，被移动对象的原始数据是会被清除的，因此如果发生异常，那些已经被移动的对象的数据就没有了，找不回来了，也就无法完成状态回滚了。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>移动语义让程序员在复制对象时有所选择。</strong></li>
<li><strong>右值引用是C++语法层面表示移动语义的机制。</strong></li>
<li><strong><code>std::move()</code>没有移动任何东西，只是把一个表达式转型（cast）为右值。</strong></li>
<li><strong>尽量让具有移动语义的函数<code>noexcept</code></strong></li>
</ul>
<h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++多线程"></a>C++多线程</h2><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/721543?utm_content=g_1000224569">C++并发编程（C++11到C++17）-阿里云开发者社区 (aliyun.com)</a></p>
<p>C++11提供如下4种语义的互斥量（mutex） ：</p>
<ol>
<li>std::mutex，独占的互斥量，不能递归使用。</li>
<li>std::timed_mutex，带超时的独占互斥量，不能递归使用。</li>
<li>std::recursive_mutex，递归互斥量，不带超时功能。</li>
<li>std::recursive_timed_mutex，带超时的递归互斥量。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRY_MUTEX       0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MUTEX        1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// non-atomic counter</span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increases10k</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRY_MUTEX</span></span><br><span class="line">                <span class="keyword">if</span>(mtx.<span class="built_in">try_lock</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                        ++counter;</span><br><span class="line">                        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> MY_MUTEX</span></span><br><span class="line">                mtx.<span class="built_in">lock</span>();</span><br><span class="line">                ++counter;</span><br><span class="line">                mtx.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        std::thread threads[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                threads[i]=std::<span class="built_in">thread</span>(increases10k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; th:threads)</span><br><span class="line">                th.<span class="built_in">join</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; successful increases of the counter &quot;</span> &lt;&lt; counter &lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o mutex_test mutex_test.c -std=c++11 -lpthread</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># try_lock</span></span><br><span class="line">$ ./mutex_test </span><br><span class="line"> successful increases of the counter 53612</span><br><span class="line"><span class="comment"># lock</span></span><br><span class="line">$ vim mutex_test.c</span><br><span class="line"> successful increases of the counter 100000</span><br></pre></td></tr></table></figure>

<p>可以看到try_lock只是尝试加锁，不管是否成功都不阻塞，而lock如果加锁失败会一直阻塞直到加锁成功。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>C++标准</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock_guard</td>
<td>C++11</td>
<td>实现严格基于作用域的互斥体所有权包装器</td>
</tr>
<tr>
<td>unique_lock</td>
<td>C++11</td>
<td>实现可移动的互斥体所有权包装器</td>
</tr>
<tr>
<td>shared_lock</td>
<td>C++14</td>
<td>实现可移动的共享互斥体所有权封装器</td>
</tr>
<tr>
<td>scoped_lock</td>
<td>C++17</td>
<td>用于多个互斥体的免死锁 RAII 封装器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>锁定策略</th>
<th>C++标准</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>defer_lock</td>
<td>C++11</td>
<td>类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td>
</tr>
<tr>
<td>try_to_lock</td>
<td>C++11</td>
<td>类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr>
<td>adopt_lock</td>
<td>C++11</td>
<td>类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td>
</tr>
</tbody></table>
<p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做RAII的编程技巧。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://redamancy9189.oss-cn-beijing.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/image-20240309204057829.png" alt="image-20240309204057829"></p>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><table>
<thead>
<tr>
<th>API</th>
<th>C++标准</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>async</td>
<td>C++11</td>
<td>异步运行一个函数，并返回保有其结果的<code>std::future</code></td>
</tr>
<tr>
<td>future</td>
<td>C++11</td>
<td>等待被异步设置的值</td>
</tr>
<tr>
<td>packaged_task</td>
<td>C++11</td>
<td>打包一个函数，存储其返回值以进行异步获取</td>
</tr>
<tr>
<td>promise</td>
<td>C++11</td>
<td>存储一个值以进行异步获取</td>
</tr>
<tr>
<td>shared_future</td>
<td>C++11</td>
<td>等待被异步设置的值（可能为其他 future 所引用）</td>
</tr>
</tbody></table>
<p>可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p>
<p><code>std::future</code>可以看成存储器，存储一个未来返回值。先在主线程内创建一个promise对象，从promise对象中获得future对象；再将promise引用传递给任务线程，在任务线程中对promise进行<code>set_value</code>，主线程可通过future获得结果。</p>
<p><code>std::future</code>提供了一个重要方法就是<code>.get()</code>，这将阻塞主线程，直到future就绪。注意：<code>.get()</code>方法只能调用一次。</p>
<p>此外，<code>std::future</code>不支持拷贝，支持移动构造。c++提供的另一个类<code>std::shared_future</code>支持拷贝。</p>
<p>可以通过下面三个方式来获得<code>std::future</code>。</p>
<ul>
<li><code>std::promise</code>的get_future函数</li>
<li><code>std::packaged_task</code>的get_future函数</li>
<li><code>std::async</code> 函数</li>
</ul>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>std::async</code>的第一个参数：<code>std::launch::deferred</code>【延迟调用】和<code>std::launch::async</code>【强制创建一个线程】。</p>
<ol>
<li><code>std::launch::deferred</code>:<br>表示线程入口函数调用被延迟到<code>std::future</code>对象调用<code>wait()</code>或者<code>get()</code>函数 调用才执行。<br>如果<code>wait()</code>和<code>get()</code><strong>没有调用</strong>，则不会创建新线程，也不执行函数；<br>如果调用<code>wait()</code>和<code>get()</code>，实际上<strong>也不会创建新线程</strong>，而是在主线程上继续执行；</li>
<li><code>std::launch::async</code>:<br>表示强制这个异步任务在 <strong>新线程</strong>上执行，在调用<code>std::async()</code>函数的时候就开始创建线程。</li>
<li><code>std::launch::deferred|std::launch::async</code>:<br>这里的“|”表示或者。如果没有给出launch参数，默认采用该种方式。<br>操作系统会自行评估选择async or defer，如果系统资源紧张，则采用defer，就不会创建新线程。避免创建线程过长，导致崩溃。</li>
</ol>
<p>嘶，async默认的launch方式将由操作系统决定，这样好处是不会因为开辟线程太多而崩溃，但坏处是这种不确定性会带来问题。std::async在使用时不仅要注意launch的不确定性，还有一个坑：<strong>async返回的future对象的析构是异步的</strong>。</p>
<h3 id="⭐总结"><a href="#⭐总结" class="headerlink" title="⭐总结"></a>⭐总结</h3><ol>
<li><strong>互斥量</strong>（Mutex）：<br>作用：互斥量用于实现临界区的互斥访问，确保在同一时刻只有一个线程可以访问被互斥锁保护的共享资源。</li>
</ol>
<p>  特点和使用：使用 std::mutex 或其变体（如 std::recursive_mutex）来创建互斥锁。通过 std::lock_guard 或 std::unique_lock 来管理互斥锁的锁定和解锁。适用于需要保护共享资源免受并发访问的场景。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 互斥区，对共享资源的访问受到保护</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;  <span class="comment">// 锁在此处自动释放</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>条件变量</strong>（Condition Variable）</li>
</ol>
<p>  作用：条件变量用于实现线程之间的协同操作，允许一个线程等待某个特定条件的发生，而其他线程可以在条件满足时通知等待的线程。</p>
<p>  特点和使用：使用 std::condition_variable 创建条件变量。与互斥锁一起使用，通常需要 std::unique_lock 进行锁的管理。适用于线程之间需要等待某个条件满足才能继续执行的情况。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> condition = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    condition = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> condition; &#125;);</span><br><span class="line">    <span class="comment">// 条件满足后继续执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>期望</strong>（std::future 和 std::promise）：</li>
</ol>
<p>  作用：期望用于异步编程，允许一个线程获取另一个线程的异步任务的结果。</p>
<p>  特点和使用：使用 std::future 表示异步任务的未来结果，使用 std::promise 设置异步任务的值。<br>  通过 std::async 或 std::packaged_task 创建异步任务。<br>  适用于在一个线程中执行任务，而另一个线程等待任务的结果。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise_result;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future_result = promise_result.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">thread</span>([&amp;](std::promise&lt;<span class="type">int</span>&gt;&amp; p) &#123;</span><br><span class="line">        p.<span class="built_in">set_value</span>(<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;, std::<span class="built_in">ref</span>(promise_result)).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = future_result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>互斥量用于保护共享资源，防止并发访问。</li>
<li>条件变量用于线程之间的协同操作，等待某个条件满足后继续执行。</li>
<li>期望用于异步编程，允许一个线程获取另一个线程的异步任务的结果。</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2>
<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/%5Bobject%20Object%5D/2024/03/15/C-%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/">C++实现LRU算法</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/%5Bobject%20Object%5D/2024/03/12/Hello-Stellar/">Hello World</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body beaudar'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="invalidsyntaxxx/invalidsyntaxxx.github.io" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">wtoy</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Bustub%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9AC"><span class="toc-text">Bustub前置知识：C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL"><span class="toc-text">STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">C++11新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">auto关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">可变参数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">delete关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind"><span class="toc-text">std::bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda"><span class="toc-text">Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">列表初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A6%E5%80%BC%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E5%80%BC%EF%BC%9F"><span class="toc-text">什么是左值什么是右值？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6-%E5%8F%B3%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-text">左&#x2F;右值转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">⭐右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept"><span class="toc-text">noexcept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">C++多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#future"><span class="toc-text">future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E6%80%BB%E7%BB%93"><span class="toc-text">⭐总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.error(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
